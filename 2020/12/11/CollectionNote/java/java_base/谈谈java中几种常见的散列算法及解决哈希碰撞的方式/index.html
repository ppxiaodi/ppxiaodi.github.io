<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="momo"><meta name="copyright" content="momo"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>谈谈java中几种常见的散列算法及解决哈希碰撞的方式 | 我的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ppxiaodi.gitee.io","root":"/","title":"momo的小站","version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="谈谈java中几种常见的散列算法及解决哈希碰撞的方式 ¶什么是哈希表 引用：严蔚敏 《数据结构（C语言版）》中的内容    哈希表就是 依据关键字可以根据一定的算法（哈希函数）映射到表中的特定位置 的思想建立的表。因此哈希表最大的特点就是可以根据f(K)函数得到其在数组中的索引。 接下来来看看Java中Object对hashCode()方法的说明，当然此方法和equals(Object obj)方">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈java中几种常见的散列算法及解决哈希碰撞的方式">
<meta property="og:url" content="https://ppxiaodi.gitee.io/2020/12/11/CollectionNote/java/java_base/%E8%B0%88%E8%B0%88java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E7%9A%84%E6%96%B9%E5%BC%8F/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="谈谈java中几种常见的散列算法及解决哈希碰撞的方式 ¶什么是哈希表 引用：严蔚敏 《数据结构（C语言版）》中的内容    哈希表就是 依据关键字可以根据一定的算法（哈希函数）映射到表中的特定位置 的思想建立的表。因此哈希表最大的特点就是可以根据f(K)函数得到其在数组中的索引。 接下来来看看Java中Object对hashCode()方法的说明，当然此方法和equals(Object obj)方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://segmentfault.com/img/bVZlmE?w=800&amp;h=364">
<meta property="og:image" content="https://segmentfault.com/img/bVZl3F?w=328&amp;h=20">
<meta property="og:image" content="https://segmentfault.com/img/bVZmau?w=151&amp;h=20">
<meta property="og:image" content="https://segmentfault.com/img/bVZmaR?w=220&amp;h=20">
<meta property="og:image" content="https://segmentfault.com/img/bVZmbc?w=221&amp;h=20">
<meta property="og:image" content="https://segmentfault.com/img/bVZmbt?w=498&amp;h=486">
<meta property="article:published_time" content="2020-12-10T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-11T08:54:53.939Z">
<meta property="article:author" content="momo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="java_base">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://segmentfault.com/img/bVZlmE?w=800&amp;h=364"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="momo"><img width="96" loading="lazy" src="/yun.png" alt="momo"></a><div class="site-author-name"><a href="/about/">momo</a></div><a class="site-name" href="/about/site.html">我的笔记</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">199</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">58</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ 群 1050458482" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">谈谈java中几种常见的散列算法及解决哈希碰撞的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">什么是哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E4%B8%AD%E7%9A%84equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95%EF%BC%88%E6%96%87%E7%AB%A0%E5%86%85%E6%BA%90%E7%A0%81%E5%9D%87%E5%9F%BA%E4%BA%8EJDK8%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Object类中的equals和hashCode方法（文章内源码均基于JDK8）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">equals方法官方文档：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode%E6%96%B9%E6%B3%95%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">hashCode方法官方文档：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">String的equals和hashCode方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E7%9A%84equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">Integer的equals和hashCode方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%EF%BC%88hash%E5%86%B2%E7%AA%81%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">哈希碰撞（hash冲突）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">冲突处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.</span> <span class="toc-text">开放地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">再哈希法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">链地址法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="toc-number">1.12.</span> <span class="toc-text">建立公共溢出区</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ppxiaodi.gitee.io/2020/12/11/CollectionNote/java/java_base/%E8%B0%88%E8%B0%88java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E7%9A%84%E6%96%B9%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="momo"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">谈谈java中几种常见的散列算法及解决哈希碰撞的方式</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-11T00:00:00+08:00">2020-12-11</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-07-11 16:54:53" itemprop="dateModified" datetime="2021-07-11T16:54:53+08:00">2021-07-11</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/java-base/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java_base</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a><a class="tag-item" href="/tags/java-base/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java_base</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1>谈谈java中几种常见的散列算法及解决哈希碰撞的方式</h1>
<h2 id="什么是哈希表"><a class="header-anchor" href="#什么是哈希表">¶</a>什么是哈希表</h2>
<p>引用：严蔚敏 《数据结构（C语言版）》中的内容</p>
<blockquote>
<p><img src="https://segmentfault.com/img/bVZlmE?w=800&amp;h=364" alt="严蔚敏 《数据结构（C语言版）》 截图" loading="lazy"></p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">哈希表就是 依据关键字可以根据一定的算法（哈希函数）映射到表中的特定位置 的思想建立的表。因此哈希表最大的特点就是可以根据f(K)函数得到其在数组中的索引。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来来看看Java中Object对hashCode()方法的说明，当然此方法和equals(Object obj)方法是相辅相成的。</p>
<h2 id="Object类中的equals和hashCode方法（文章内源码均基于JDK8）"><a class="header-anchor" href="#Object类中的equals和hashCode方法（文章内源码均基于JDK8）">¶</a>Object类中的equals和hashCode方法（文章内源码均基于JDK8）</h2>
<h2 id="equals方法官方文档："><a class="header-anchor" href="#equals方法官方文档：">¶</a>equals方法官方文档：</h2>
<blockquote>
<p>public boolean equals(Object obj)</p>
<p>Indicates whether some other object is “equal to” this one.</p>
<p>The equals method implements an equivalence relation on non-null<br>
object references:</p>
<p><strong>·</strong> It is reflexive: for any non-null reference value x, x.equals(x) should return true.<br>
<strong>·</strong> It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.<br>
<strong>·</strong> It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.<br>
<strong>·</strong> It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.<br>
<strong>·</strong> For any non-null reference value x, x.equals(null) should return false.</p>
<p>The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).</p>
<p>Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</p>
<p><strong>Parameters:</strong><br>
obj the reference object with which to compare.<br>
<strong>Returns:</strong><br>
true if this object is the same as the obj argument; false otherwise.<br>
<strong>See Also:</strong><br>
hashCode(),java.util.HashMap</p>
</blockquote>
<p>在官方说明中，指明了equals方法具有自反性、对称性、传递性、一致性，同时也提醒在在继承Object的时候，如果要重写hashCode方法，通常都需要重写该方法，因为hashCode要求（下面也有提及）：如果两个对象执行equals方法结果为true，则两对象的哈希码应该是相等的。</p>
<h2 id="hashCode方法官方文档："><a class="header-anchor" href="#hashCode方法官方文档：">¶</a>hashCode方法官方文档：</h2>
<blockquote>
<p>public native int hashCode();</p>
<p>Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by java.util.HashMap.</p>
<p>The general contract of hashCode is:</p>
<p><strong>·</strong> Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.<br>
<strong>·</strong> If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.<br>
<strong>·</strong> It is not required that if two objects are unequal according to the java.lang.Object.equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.<br>
As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java™ programming language.)<br>
<strong>Returns:</strong><br>
<strong>a</strong> hash code value for this object.<br>
<strong>See Also:</strong><br>
java.lang.Object.equals(java.lang.Object),java.lang.System.identityHashCode</p>
</blockquote>
<p>该方法返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。此方法为native方法，取决于JVM的内部设计，一般是某种C地址的偏移。</p>
<p><strong>文档中给出了三条规定：</strong></p>
<ol>
<li>在对象没有被修改的前提下，执行多次调用，该hashCode方法必须始终返回相同的整数。</li>
<li>如果两个对象执行equals方法结果为true，则分别调用hashCode方法产生的整数结果是相等的。</li>
<li>非必要要求：两个对象执行equals方法结果为false，则分别调用hashCode方法产生的整数结果是不相等的。</li>
</ol>
<p>第三个要求虽然为非必需，但如果实现，则可以提高散列表的性能。</p>
<p>接下来分析几个常见的实现方式。</p>
<h2 id="String的equals和hashCode方法"><a class="header-anchor" href="#String的equals和hashCode方法">¶</a>String的equals和hashCode方法</h2>
<ul>
<li><strong>hashCode方法源码：</strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public int hashCode() &#123;
    int h &#x3D; hash;
    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;
        char val[] &#x3D; value;

        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;
            h &#x3D; 31 * h + val[i];
        &#125;
        hash &#x3D; h;
    &#125;
    return h;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数很简单，以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模，达到了目的——只要字符串的内容相同，返回的哈希码也相同。但是乘子31在此需要解释一下。选31作为乘子，是因为：</p>
<ol>
<li>31是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。</li>
<li>31可以被JVM优化：31 * i = (i &lt;&lt; 5) - i。</li>
</ol>
<ul>
<li><strong>equals方法源码：</strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public boolean equals(Object anObject) &#123;
    if (this &#x3D;&#x3D; anObject) &#123;
        return true;
    &#125;
    if (anObject instanceof String) &#123;
        String anotherString &#x3D; (String)anObject;
        int n &#x3D; value.length;
        if (n &#x3D;&#x3D; anotherString.value.length) &#123;
            char v1[] &#x3D; value;
            char v2[] &#x3D; anotherString.value;
            int i &#x3D; 0;
            while (n-- !&#x3D; 0) &#123;
                if (v1[i] !&#x3D; v2[i])
                    return false;
                i++;
            &#125;
            return true;
        &#125;
    &#125;
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此equals方法包含了&quot;==&quot;，双等号比较的是地址，存储地址相同，内容则相同。当地址不同的时候，先验证了比较对象是否为String，接着比较了两个字符串的长度，最后才循环比较每个字符是否相等。</p>
<h2 id="Integer的equals和hashCode方法"><a class="header-anchor" href="#Integer的equals和hashCode方法">¶</a>Integer的equals和hashCode方法</h2>
<ul>
<li><strong>hashCode方法源码：</strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@Override
public int hashCode() &#123;
    return Integer.hashCode(value);
&#125;
public static int hashCode(int value) &#123;
    return value;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>equals方法源码：</strong></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none"> public boolean equals(Object obj) &#123;
    if (obj instanceof Integer) &#123;
        return value &#x3D;&#x3D; ((Integer)obj).intValue();
    &#125;
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由此可见，Integer哈希码就是Integer对象里所包含的那个整数的数值，且equals方法比较的也是两者的整数数值，即两个数值大小的Integer对象，计算出的哈希码是相等的。</p>
<p><strong>最后</strong>，像int，char这样的基础类，它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法同Integer。</p>
<h2 id="哈希碰撞（hash冲突）"><a class="header-anchor" href="#哈希碰撞（hash冲突）">¶</a>哈希碰撞（hash冲突）</h2>
<p>在计算hash地址的过程中会出现对于不同的关键字出现相同的哈希地址的情况，即key1 ≠ key2，但是f(key1) = f(key2)，这种情况就是Hash 冲突。具有相同关键字的key1和key2称之为同义词。<br>
通过优化哈希函数可以减少这种冲突的情况（如：均衡哈希函数），但是在通用条件下，考虑到于表格的长度有限及关键值（数据）的无限，这种冲突是不可避免的，所以就需要处理冲突。</p>
<h2 id="冲突处理"><a class="header-anchor" href="#冲突处理">¶</a>冲突处理</h2>
<p>冲突处理分为以下四种方式：</p>
<ol>
<li>开放地址</li>
<li>再哈希</li>
<li>链地址</li>
<li>建立公共溢出区</li>
</ol>
<p>其中开放地址又分为：</p>
<blockquote>
<ul>
<li>线性探测再散列</li>
<li>二次探测再散列</li>
<li>伪随机探测再散列</li>
</ul>
</blockquote>
<p><strong>下面谈谈几种方法的原理：</strong></p>
<h2 id="开放地址"><a class="header-anchor" href="#开放地址">¶</a>开放地址</h2>
<p>开放地址法处理冲突的基本原则就是出现冲突后按照一定算法查找一个空位置存放。公式：<br>
<img src="https://segmentfault.com/img/bVZl3F?w=328&amp;h=20" alt="clipboard.png" loading="lazy"><br>
Hi为计算出的地址，H(key)为哈希函数，di为增量。其中di的三种获取方式既是上面提到的开放地址法的三种分类（线性探测再散列、二次探测再散列、伪随机探测再散列）。</p>
<ul>
<li>线性探测再散列<br>
<img src="https://segmentfault.com/img/bVZmau?w=151&amp;h=20" alt="clipboard.png" loading="lazy"><br>
，即依次向后查找。</li>
<li>二次探测再散列<br>
<img src="https://segmentfault.com/img/bVZmaR?w=220&amp;h=20" alt="clipboard.png" loading="lazy">，即依次向前后查找，增量为1、2、3的二次方。</li>
<li>伪随机探测再散列<br>
伪随机，顾名思义就是随机产生一个增量位移。</li>
</ul>
<h2 id="再哈希法"><a class="header-anchor" href="#再哈希法">¶</a>再哈希法</h2>
<p>再哈希法，就是出现冲突后采用其他的哈希函数计算，直到不再冲突为止。</p>
<p><img src="https://segmentfault.com/img/bVZmbc?w=221&amp;h=20" alt="clipboard.png" loading="lazy">，其中RHi为不同的哈希函数。</p>
<h2 id="链地址法"><a class="header-anchor" href="#链地址法">¶</a>链地址法</h2>
<p>链接地址法不同与前两种方法，他是在出现冲突的地方存储一个链表，所有的同义词记录都存在其中。形象点说就行像是在出现冲突的地方直接把后续的值摞上去。例如HashMap，如下图。</p>
<p><img src="https://segmentfault.com/img/bVZmbt?w=498&amp;h=486" alt="clipboard.png" loading="lazy"></p>
<h2 id="建立公共溢出区"><a class="header-anchor" href="#建立公共溢出区">¶</a>建立公共溢出区</h2>
<p>建立公共溢出区的基本思想是：假设哈希函数的值域是[1,m-1]，则设向量HashTable[0…m-1]为基本表，每个分量存放一个记录，另外设向量OverTable[0…v]为溢出表，所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>momo</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://ppxiaodi.gitee.io/2020/12/11/CollectionNote/java/java_base/%E8%B0%88%E8%B0%88java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E7%9A%84%E6%96%B9%E5%BC%8F/" title="谈谈java中几种常见的散列算法及解决哈希碰撞的方式">https://ppxiaodi.gitee.io/2020/12/11/CollectionNote/java/java_base/%E8%B0%88%E8%B0%88java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E7%9A%84%E6%96%B9%E5%BC%8F/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/12/11/CollectionNote/java/java_base/%E8%AF%A6%E8%A7%A3list.toArray(new%20String%5B0%5D)/" rel="prev" title="详解list.toArray(new String[0])"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">详解list.toArray(new String[0])</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/12/11/CollectionNote/java/java_base/%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/" rel="next" title="转发和重定向的区别和使用"><span class="post-nav-text">转发和重定向的区别和使用</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> momo</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>