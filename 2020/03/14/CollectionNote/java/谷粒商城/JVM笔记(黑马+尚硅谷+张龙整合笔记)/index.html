<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="momo"><meta name="copyright" content="momo"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>JVM笔记(黑马+尚硅谷+张龙整合笔记) | 我的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ppxiaodi.github.io","root":"/","title":"momo的小站","version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="JVM笔记(黑马+尚硅谷+张龙整合笔记)  本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net  ¶前要 本身整合了如下视频的笔记，并进行了整理：尚硅谷周阳、张龙、黑马程序员  黑马 ppt 非常好：https:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;hancoder&#x2F;12834607 本文及 JVM 系列笔记地址：https:&#x2F;&#x2F;blog.csdn.n">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM笔记(黑马+尚硅谷+张龙整合笔记)">
<meta property="og:url" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="JVM笔记(黑马+尚硅谷+张龙整合笔记)  本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net  ¶前要 本身整合了如下视频的笔记，并进行了整理：尚硅谷周阳、张龙、黑马程序员  黑马 ppt 非常好：https:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;hancoder&#x2F;12834607 本文及 JVM 系列笔记地址：https:&#x2F;&#x2F;blog.csdn.n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a1.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a2.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a3.jpg">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823165459877.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200328142826.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a4.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a5.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a6.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a7.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a8.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a9.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200401213601820-1712399995.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402095033111-1956475857.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100253935-1789842330.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100334236-1637713126.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100351272-751766212.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100449299-194786867.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a10.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a11.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402110625116-1337433158.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a12.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a13.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a14.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a15.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a16.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a17.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a18.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a19.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a20.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160812143114843">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a21.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/8189e84069fb7da05aaebfa345c6c18a4d095945.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20180704121146905">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a22.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203247146">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203303115">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203323021">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203343662">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160823154637228">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160823155446893">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160823161625964">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a28.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a29.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a23.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a24.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a25.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a26.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a27.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819021246.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a30.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/2019082910552275.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a31.jpg">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a32.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a33.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a34.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a35.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829134936398.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a36.jpg">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a37.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-b7decc099979b0ef.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/2184951-4eb4f86a4db07c72.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/2184951-c1622c7b27675950.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a38.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-2d308c6f85c9ee53.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-381bc3a45bc4d46d.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b1.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-381bc3a45bc4d46d-1615736853651.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b2.jpg">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b3.jpg">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829142240241.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829142257572.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b4.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819011849.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819135645.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819135817.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829145909560.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/201908291459186.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819011727.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829150653481.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819144217.png">
<meta property="og:image" content="https://fermhan.oss-cn-qingdao.aliyuncs.com/img/20200819135913.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200910150955.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b5.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174548869.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174604652.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174617549.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174625924.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b6.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b7.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823162256476.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b8.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823162350340.png">
<meta property="og:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823162417381.png">
<meta property="article:published_time" content="2020-03-13T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-11T08:54:54.083Z">
<meta property="article:author" content="momo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="谷粒商城">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a1.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="momo"><img width="96" loading="lazy" src="/yun.png" alt="momo"></a><div class="site-author-name"><a href="/about/">momo</a></div><a class="site-name" href="/about/site.html">我的笔记</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">198</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">58</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ 群 1050458482" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">JVM笔记(黑马+尚硅谷+张龙整合笔记)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A6%81"><span class="toc-number">1.0.1.</span> <span class="toc-text">前要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-number">1.0.2.</span> <span class="toc-text">文章目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1_介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2_类装载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8A%A0%E8%BD%BD%EF%BC%9A"><span class="toc-number">1.2.0.0.1.</span> <span class="toc-text">1、加载：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.2.0.0.2.</span> <span class="toc-text">2、连接：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.0.0.3.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">1.2.0.0.4.</span> <span class="toc-text">3、初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.0.0.5.</span> <span class="toc-text">代码执行顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.0.0.6.</span> <span class="toc-text">实例执行顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1_类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1_类装载器的分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2_自定义加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%EF%BC%9A"><span class="toc-number">1.2.1.2.0.1.</span> <span class="toc-text">类加载器深入剖析：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98-%E6%B4%BE-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3_双亲委托 (&#x2F; 派) 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4_命名空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2_链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3_类的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">3_内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%9Ajavap-%E5%B7%A5%E5%85%B7%E4%B8%8E-JVM-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.0 预备知识：javap 工具与 JVM 参数设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A9%E8%AE%B0%E7%AC%A6"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">助记符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">JVM 参数设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.1_程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JVM-%E6%A0%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.2_JVM 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.2.1 局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A7%BD-slot-%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">变量槽 slot 的理解与演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#slot-%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">slot 的重复利用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%8F%8A%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">静态变量与局部变量的对比及小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.2.2 操作数栈（Operand Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">操作数栈特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">操作数栈代码追踪</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF-ToS%EF%BC%88Top-of-Stack-Cashing%EF%BC%89"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">栈顶缓存技术 ToS（Top-of-Stack Cashing）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.2.3 动态链接（Dynamic Linking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-1-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">3.2.3.1 方法的调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-2-%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.3.2.</span> <span class="toc-text">3.2.3.2 虚方法和非虚方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">1.3.3.3.2.1.</span> <span class="toc-text">虚方法表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.3.3.</span> <span class="toc-text">多态原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.3.3.3.1.</span> <span class="toc-text">继承的多态</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.3.3.3.2.</span> <span class="toc-text">接口的多态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%EF%BC%88%E4%B8%BB%E8%A6%81%E9%92%88%E5%AF%B9%E4%BA%8E%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.2.4 方法返回地址（主要针对于正常退出的情况）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.3_本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%A0%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.4_堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">堆内存诊断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.5_方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.6.1.1.</span> <span class="toc-text">字段信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.6.1.2.</span> <span class="toc-text">方法信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F-%E5%8D%B3-static-%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">1.3.6.1.3.</span> <span class="toc-text">类变量 (即 static 变量）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.6.1.4.</span> <span class="toc-text">对类加载器的引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9-Class-%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.6.1.5.</span> <span class="toc-text">对 Class 类的引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">1.3.6.1.6.</span> <span class="toc-text">方法表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1-intern"><span class="toc-number">1.3.6.1.7.</span> <span class="toc-text">字符串对象.intern()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.3.6.1.7.1.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.6.1.8.</span> <span class="toc-text">字符串常量池的位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.6.1.9.</span> <span class="toc-text">串常量垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">1.3.6.1.10.</span> <span class="toc-text">串常量池性能调优</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK6"><span class="toc-number">1.3.6.1.11.</span> <span class="toc-text">JDK6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK7"><span class="toc-number">1.3.6.1.12.</span> <span class="toc-text">JDK7</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">new String() 究竟创建几个对象?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%86%E6%9E%90"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1. 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">3.6_直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-%E7%B1%BB%E6%93%8D%E4%BD%9C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="toc-number">2.0.2.</span> <span class="toc-text">Unsafe 类操作堆外内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E7%B1%BB%E6%93%8D%E4%BD%9C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="toc-number">2.0.3.</span> <span class="toc-text">NIO 类操作堆外内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">二：堆外内存垃圾回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">三：为什么用堆外内存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">四：如何用堆外内存？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.1.</span> <span class="toc-text">4_垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">四种引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="toc-number">2.1.2.0.1.</span> <span class="toc-text">1 标记 + 清除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="toc-number">2.1.2.0.2.</span> <span class="toc-text">2 标记 + 整理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.2.0.3.</span> <span class="toc-text">3 复制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.3.</span> <span class="toc-text">分代垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9A"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">GC 的时机：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">分配担保机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9A"><span class="toc-number">2.1.3.1.2.</span> <span class="toc-text">大对象直接进入老年代：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8Serial-GC"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">3.1 串行垃圾收集器Serial GC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-%E8%AE%BE%E7%BD%AE%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%BA%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.1.4.1.1.</span> <span class="toc-text">3.1.2 设置垃圾回收为串行收集器</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">为了测试 GC，将堆的初始和最大内存都设置为 16M</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">3.2 并行垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-ParNew%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-%E5%B9%B4%E8%BD%BB%E4%BB%A3-PS-%E5%B9%B4%E8%BD%BB%E4%BB%A3"><span class="toc-number">3.0.0.1.1.</span> <span class="toc-text">3.2.1 ParNew垃圾收集器 (年轻代)+PS(年轻代)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-PS-PO%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.0.0.1.2.</span> <span class="toc-text">3.2.2 PS+PO垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-%E8%80%81%E5%B9%B4%E4%BB%A3-PN-%E5%B9%B4%E8%BD%BB%E4%BB%A3-Serial-Old"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">3.3 CMS垃圾收集器 (老年代)+PN(年轻代)+Serial Old</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%87%E8%AE%B0"><span class="toc-number">3.0.0.2.1.</span> <span class="toc-text">①初始化标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.0.0.2.2.</span> <span class="toc-text">根对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">3.0.0.2.3.</span> <span class="toc-text">②并发标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0"><span class="toc-number">3.0.0.2.4.</span> <span class="toc-text">③重新标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4"><span class="toc-number">3.0.0.2.5.</span> <span class="toc-text">④并发清除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS-%E7%BC%BA%E7%82%B9"><span class="toc-number">3.0.0.2.6.</span> <span class="toc-text">CMS 缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-cms-%E6%B5%8B%E8%AF%95"><span class="toc-number">3.0.0.2.7.</span> <span class="toc-text">3.3.1 cms 测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">3.4 G1垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">3.4.1 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-Young-GC"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">3.4.2 Young GC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-1-Remembered-Set%EF%BC%88%E5%B7%B2%E8%AE%B0%E5%BF%86%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">3.1.0.2.1.</span> <span class="toc-text">3.4.2.1 Remembered Set（已记忆集合）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-Young-GC-ConMark"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">3.4.3 Young GC+ConMark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-Mixed-GC"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">3.4.3 Mixed GC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Full-GC%EF%BC%9A"><span class="toc-number">3.1.0.4.1.</span> <span class="toc-text">Full GC：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-G1-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.0.5.</span> <span class="toc-text">3.4.4 G1 收集器相关参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.0.6.</span> <span class="toc-text">3.4.5 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-%E5%AF%B9%E4%BA%8E-G1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.1.0.7.</span> <span class="toc-text">3.4.6 对于 G1 垃圾收集器的优化建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">G1 新功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">垃圾回收调优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">4 可视化 GC 日志分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-GC-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 GC 日志输出参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-GC-Easy-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 GC Easy 可视化工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E7%BB%8F%E5%85%B8%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">内存泄露的经典原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">5_字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">方法的执行过程：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-%E5%8E%9F%E5%A7%8B-java-%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.1.0.0.1.</span> <span class="toc-text">测试代码 (原始 java 代码)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#javap-v-%E6%9F%A5%E7%9C%8B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.3.1.0.0.2.</span> <span class="toc-text">javap -v 查看 (二进制字节码)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.3.2.</span> <span class="toc-text">字节码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%88%86%E6%9E%90"><span class="toc-number">4.3.2.0.1.</span> <span class="toc-text">常量池分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">字节码结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AD%94%E6%95%B0"><span class="toc-number">4.3.2.1.1.</span> <span class="toc-text">魔数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">4.3.2.1.2.</span> <span class="toc-text">版本号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0-v2"><span class="toc-number">4.3.2.1.3.</span> <span class="toc-text">常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%93%E6%9E%84%E8%A1%A8"><span class="toc-number">4.3.2.1.3.1.</span> <span class="toc-text">常量池结构表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.3.2.1.3.2.</span> <span class="toc-text">类型表示</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-Access-Falgs%EF%BC%9A"><span class="toc-number">4.3.2.1.4.</span> <span class="toc-text">访问权限 Access Falgs：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%90%8D"><span class="toc-number">4.3.2.1.5.</span> <span class="toc-text">类名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E5%90%8D"><span class="toc-number">4.3.2.1.6.</span> <span class="toc-text">父类名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.2.1.7.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8-Fields"><span class="toc-number">4.3.2.1.8.</span> <span class="toc-text">字段表 Fields</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.1.9.</span> <span class="toc-text">方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">JVM 调优</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">张龙类的加载过程代码：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Thread-getContextClassLoader"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">上下文类加载器 Thread.getContextClassLoader()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">张龙内存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="momo"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM笔记(黑马+尚硅谷+张龙整合笔记)</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">2020-03-14</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-07-11 16:54:54" itemprop="dateModified" datetime="2021-07-11T16:54:54+08:00">2021-07-11</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">谷粒商城</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a><a class="tag-item" href="/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">谷粒商城</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1>JVM笔记(黑马+尚硅谷+张龙整合笔记)</h1>
<blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/105210258">blog.csdn.net</a></p>
</blockquote>
<h3 id="前要"><a class="header-anchor" href="#前要">¶</a>前要</h3>
<p>本身整合了如下视频的笔记，并进行了整理：尚硅谷周阳、张龙、黑马程序员</p>
<ul>
<li>黑马 ppt 非常好：<a target="_blank" rel="noopener" href="https://download.csdn.net/download/hancoder/12834607">https://download.csdn.net/download/hancoder/12834607</a></li>
<li>本文及 JVM 系列笔记地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/category_10345348.html">https://blog.csdn.net/hancoder/category_10345348.html</a></li>
<li>多线程并发、JMM 等笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/105740321">https://blog.csdn.net/hancoder/article/details/105740321</a></li>
</ul>
<p>内容算是笔记充分了，张龙的代码附在文尾，文字部分整合到了正文中</p>
<h3 id="文章目录"><a class="header-anchor" href="#文章目录">¶</a>文章目录</h3>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#_3">前要</a></li>
</ul>
</li>
<li><a href="#1__15">1_介绍</a></li>
<li><a href="#2__65">2_类装载子系统</a></li>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1_77">1、加载：</a></li>
<li><a href="#2_81">2、== 连接 ==：</a></li>
<li><a href="#_94">== 常量池 ==</a></li>
<li><a href="#3_177">3、初始化：</a></li>
<li><a href="#_183">== 代码执行顺序 ==</a></li>
<li><a href="#_231">== 实例执行顺序 ==</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#21__283">2.1_类加载</a></li>
<li>
<ul>
<li><a href="#211__299">2.1.1_类装载器的分类：</a></li>
<li><a href="#212__360">2.1.2_自定义加载器</a></li>
<li>
<ul>
<li>
<ul>
<li><a href="#_381">类加载器深入剖析：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#213__417">2.1.3_双亲委托 (/ 派) 机制</a></li>
<li><a href="#214__442">2.1.4_命名空间</a></li>
</ul>
</li>
<li><a href="#22__450">2.2_链接</a></li>
<li><a href="#23__471">2.3_类的初始化</a></li>
<li><a href="#_527">执行顺序</a></li>
</ul>
</li>
<li><a href="#3__546">3_内存结构</a></li>
<li>
<ul>
<li><a href="#30_javapJVM_559">3.0 预备知识：javap 工具与 JVM 参数设置</a></li>
<li>
<ul>
<li><a href="#_563">助记符</a></li>
<li><a href="#JVM_594">==JVM 参数设置 ==</a></li>
</ul>
</li>
<li><a href="#31__621">3.1_程序计数器</a></li>
<li><a href="#32_JVM_631">3.2_JVM 栈</a></li>
<li>
<ul>
<li><a href="#321__825">3.2.1 == 局部变量表 ==</a></li>
<li>
<ul>
<li><a href="#slot_865">变量槽 slot 的理解与演示</a></li>
<li><a href="#slot_905">slot 的重复利用</a></li>
<li><a href="#_936">静态变量与局部变量的对比及小结</a></li>
</ul>
</li>
<li><a href="#322_Operand_Stack_956">3.2.2 == 操作数栈 ==（Operand Stack）</a></li>
<li>
<ul>
<li><a href="#_972">操作数栈特点</a></li>
<li><a href="#_985">== 操作数栈代码追踪 ==</a></li>
<li><a href="#ToSTopofStack_Cashing_1061">栈顶缓存技术 ToS（Top-of-Stack Cashing）</a></li>
</ul>
</li>
<li><a href="#323_Dynamic_Linking_1066">3.2.3 == 动态链接 ==（Dynamic Linking）</a></li>
<li>
<ul>
<li><a href="#3231__1112">3.2.3.1 方法的调用</a></li>
<li><a href="#3232__1130">3.2.3.2 虚方法和非虚方法</a></li>
<li>
<ul>
<li><a href="#_1174">== 虚方法表 ==</a></li>
</ul>
</li>
<li><a href="#_1198">== 多态原理 ==</a></li>
<li>
<ul>
<li><a href="#_1237">继承的多态</a></li>
<li><a href="#_1294">接口的多态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#324__1390">3.2.4 方法返回地址（主要针对于正常退出的情况）</a></li>
</ul>
</li>
<li><a href="#33__1429">3.3_本地方法栈</a></li>
<li><a href="#34__1491">3.4_堆</a></li>
<li>
<ul>
<li><a href="#_1568">堆内存诊断</a></li>
</ul>
</li>
<li><a href="#35__1785">3.5_方法区</a></li>
<li>
<ul>
<li><a href="#_1827">运行时常量池</a></li>
<li>
<ul>
<li><a href="#_1899">字段信息</a></li>
<li><a href="#_1908">方法信息</a></li>
<li><a href="#static_1919">类变量 (即 static 变量）</a></li>
<li><a href="#_1930">对类加载器的引用</a></li>
<li><a href="#Class_1934">对 Class 类的引用</a></li>
<li><a href="#_1938">方法表</a></li>
<li><a href="#intern_1942"><code> 字符串对象. intern()</code></a></li>
<li>
<ul>
<li><a href="#_1964">字符串常量池</a></li>
</ul>
</li>
<li><a href="#_2074">字符串常量池的位置</a></li>
<li><a href="#_2096">串常量垃圾回收</a></li>
<li><a href="#_2164">串常量池性能调优</a></li>
<li><a href="#JDK6_2207">JDK6</a></li>
<li><a href="#JDK7_2217">JDK7</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#new_String_2286">new String() 究竟创建几个对象?</a></li>
<li>
<ul>
<li><a href="#1__2288">1. 由来</a></li>
<li><a href="#2__2296">2. 解答</a></li>
<li>
<ul>
<li><a href="#21__2298">2.1. 分析</a></li>
<li>
<ul>
<li><a href="#36__2401">3.6_直接内存</a></li>
</ul>
</li>
<li><a href="#Unsafe_2465">Unsafe 类操作堆外内存</a></li>
<li><a href="#NIO_2504">NIO 类操作堆外内存</a></li>
<li>
<ul>
<li><a href="#_2529">二：堆外内存垃圾回收</a></li>
<li><a href="#_2582">三：为什么用堆外内存？</a></li>
<li><a href="#_2600">四：如何用堆外内存？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4__2912">4_垃圾回收</a></li>
<li>
<ul>
<li><a href="#_2933">四种引用</a></li>
<li><a href="#_3118">垃圾回收算法</a></li>
<li>
<ul>
<li>
<ul>
<li><a href="#1__3125">1 标记 + 清除</a></li>
<li><a href="#2__3135">2 标记 + 整理</a></li>
<li><a href="#3__3142">3 复制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_3149">分代垃圾回收机制</a></li>
<li>
<ul>
<li><a href="#GC_3170">GC 的时机：</a></li>
<li>
<ul>
<li><a href="#_3242">** 分配担保机制 **</a></li>
<li><a href="#_3260">大对象直接进入老年代：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_3292">== 垃圾收集器 ==</a></li>
<li>
<ul>
<li><a href="#31__Serial_GC_3342">3.1 串行垃圾收集器 <code>Serial GC</code></a></li>
<li>
<ul>
<li><a href="#312__3395">3.1.2 设置垃圾回收为串行收集器</a></li>
</ul>
</li>
<li><a href="#32__3438">3.2 并行垃圾收集器</a></li>
<li>
<ul>
<li><a href="#321_ParNewPS_3448">3.2.1 <code>ParNew</code> 垃圾收集器 (年轻代)+<code>PS</code>(年轻代)</a></li>
<li><a href="#322_PSPO_3490">3.2.2 <code>PS+PO</code> 垃圾收集器</a></li>
</ul>
</li>
<li><a href="#33_CMSPNSerial_Old_3563">3.3 <code>CMS</code> 垃圾收集器 (老年代)+<code>PN</code>(年轻代)+<code>Serial Old</code></a></li>
<li>
<ul>
<li><a href="#_3597">**①初始化标记 **</a></li>
<li><a href="#_3608">根对象</a></li>
<li><a href="#_3617">②并发标记</a></li>
<li><a href="#_3648">③重新标记</a></li>
<li><a href="#_3691">④并发清除</a></li>
<li><a href="#CMS_3701">CMS 缺点</a></li>
<li><a href="#331_cms_3750">3.3.1 cms 测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#34_G1_3791">3.4 <code>G1</code> 垃圾收集器</a></li>
<li>
<ul>
<li>
<ul>
<li><a href="#341__3826">3.4.1 原理</a></li>
<li><a href="#342_Young_GC_3908">3.4.2 <code>Young GC</code></a></li>
<li>
<ul>
<li><a href="#3421_Remembered_Set_3932">3.4.2.1 <strong>Remembered Set（已记忆集合）</strong></a></li>
</ul>
</li>
<li><a href="#343_Young_GCConMark_3970">3.4.3 <code>Young GC+ConMark</code></a></li>
<li><a href="#343_Mixed_GC_3978">3.4.3 <code>Mixed GC</code></a></li>
<li>
<ul>
<li><a href="#Full_GC_4029">Full GC：</a></li>
</ul>
</li>
<li><a href="#344_G1_4054">3.4.4 G1 收集器相关参数</a></li>
<li><a href="#345__4082">3.4.5 测试</a></li>
<li><a href="#346_G1_4126">3.4.6 对于 G1 垃圾收集器的优化建议</a></li>
</ul>
</li>
<li><a href="#G1_4136">G1 新功能</a></li>
<li><a href="#_4182">垃圾回收调优</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4_GC_4257">4 可视化 GC 日志分析工具</a></li>
<li>
<ul>
<li><a href="#41_GC_4259">4.1 GC 日志输出参数</a></li>
<li><a href="#42_GC_Easy_4285">4.2 GC Easy 可视化工具</a></li>
<li>
<ul>
<li>
<ul>
<li><a href="#_4339">内存泄露的经典原因</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5__4401">5_字节码</a></li>
<li>
<ul>
<li><a href="#_4410">方法的执行过程：</a></li>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#java_4421">测试代码 (原始 java 代码)</a></li>
<li><a href="#javap_v_4479">javap -v 查看 (二进制字节码)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_4572">字节码分析</a></li>
<li>
<ul>
<li>
<ul>
<li><a href="#_4574">常量池分析</a></li>
</ul>
</li>
<li><a href="#_4617">字节码结构</a></li>
<li>
<ul>
<li><a href="#_4623">魔数</a></li>
<li><a href="#_4627">版本号</a></li>
<li><a href="#_4631">常量池</a></li>
<li>
<ul>
<li><a href="#_4637">常量池结构表</a></li>
<li><a href="#_4660">类型表示</a></li>
</ul>
</li>
<li><a href="#Access_Falgs_4682">访问权限 Access Falgs：</a></li>
<li><a href="#_4693">类名</a></li>
<li><a href="#_4697">父类名</a></li>
<li><a href="#_4701">接口</a></li>
<li><a href="#Fields_4705">字段表 Fields</a></li>
<li><a href="#_4728">方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#JVM_5046">JVM 调优</a></li>
<li><a href="#_5050">张龙类的加载过程代码：</a></li>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#_ThreadgetContextClassLoader_5847">上下文类加载器 Thread.getContextClassLoader()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_6163">张龙内存机制</a></li>
<li>
<ul>
<li><a href="#_6185">参考</a></li>
</ul>
</li>
</ul>
<h2 id="1-介绍"><a class="header-anchor" href="#1-介绍">¶</a>1_介绍</h2>
<p>1.1_什么是 JVM</p>
<p><strong>定义</strong>：java virtual meachine -java 运行时环境（java 二进制字节码的运行环境）。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<br>
<strong>好处：</strong></p>
<ol>
<li>一次编写到处运行</li>
<li>自动内存管理，垃圾回收</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ol>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a1.png" class="" loading="lazy">
<blockquote>
<p>我们需要格外注意的是 .class-&gt; 机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的 (也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
</blockquote>
<p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<p>1.3_常见的 JVM</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a2.png" class="" loading="lazy">
<p>Oracle JDK 和 OpenJDK 的对比：</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。</p>
<p>关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a target="_blank" rel="noopener" href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业 / 商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<p>字节码文件 class 以 CA FE BACE 开头</p>
<p>查看二进制码的软件是 Binary Viewer</p>
<h2 id="2-类装载子系统"><a class="header-anchor" href="#2-类装载子系统">¶</a>2_类装载子系统</h2>
<p>2.0_概述</p>
<p>类的使用流程：</p>
<ul>
<li>是否加载了该类
<ul>
<li>没有加载：使用类加载器加载该类</li>
<li>加载了：链接–初始化—调用 main 方法</li>
</ul>
</li>
</ul>
<p>类加载归纳为有三个阶段：</p>
<h5 id="1、加载："><a class="header-anchor" href="#1、加载：">¶</a>1、加载：</h5>
<p>从文件系统或者网络中查找并加载类的二进制数据 class 到 java 虚拟机中</p>
<h5 id="2、连接："><a class="header-anchor" href="#2、连接：">¶</a>2、连接：</h5>
<p>2.1、验证 : 确保被加载的类的正确性</p>
<p>2.2、准备：为类的 <strong>static 静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong>，但是到达初始化之前类变量都没有初始化为真正的初始值。（这里不包含 final 修饰的 static，因为 final 在编译时候就会分配了，准备阶段会显示初始化。）（这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到 java 堆中）这些内存都将在方法区中进行分配。</p>
<ul>
<li>类变量在方法区</li>
<li>实例在堆区</li>
<li>实例属性在堆区</li>
<li>局部变量在 JVM 栈中的局部变量表中</li>
</ul>
<p>2.3、解析：<strong>把类中的符号引用转换为直接引用</strong>，就是在类的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程。符号引用就是一组符号来描述所引用的目标，符号引用的字面量明确规定在 &lt;&lt;JAVA 规范&gt;&gt; 的 class 文件格式中。直接引用就是直接指向目标的指针、相对偏移或一个间接定位到目标的句柄。（符号引用是字符串常量池的阶段，直接引用指向指针）</p>
<h5 id="常量池"><a class="header-anchor" href="#常量池">¶</a>常量池</h5>
<p>常量池中保存的是一个 Java 类引用的一些常量信息，包含一些字符串常量及对于类的符号引用信息等。Java 代码编译生成的类文件中的常量池是静态常量池，当类被载入到虚拟机内部的时候，在内存中产生类的常量池叫运行时常量池。</p>
<p>常量池在逻辑上可以分成多个表，每个表包含一类的常量信息</p>
<ul>
<li><code>CONSTANT_Utf8_info</code><br>
字符串常量表，该表包含该类所使用的所有字符串常量，比如代码中的字符串引用、引用的类名、方法的名字、其他引用的类与方法的字符串描述等等。其余常量池表中所涉及到的任何常量字符串都被索引至该表。</li>
<li><code>CONSTANT_Class_info</code><br>
类信息表，包含任何被引用的类或接口的符号引用，每一个条目主要包含一个索引，指向 CONSTANT_Utf8_info 表，表示该类或接口的全限定名。</li>
<li><code>CONSTANT_NameAndType_info</code><br>
名字类型表，包含引用的任意方法或字段的名称和描述符信息在字符串常量表中的索引。</li>
<li><code>CONSTANT_InterfaceMethodref_info</code><br>
接口方法引用表，包含引用的任何接口方法的描述信息，主要包括类信息索引和名字类型索引。</li>
<li><code>CONSTANT_Methodref_info</code><br>
类方法引用表，包含引用的任何类型方法的描述信息，主要包括类信息索引和名字类型索引</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a3.jpg" class="" loading="lazy">
<blockquote>
<p>2.3.1、解析阶段是虚拟机将量池内的符号引用替换为值接引用的过程, 符号引用在 Class 文件中它以 CONSTANT_Class_info, CONSTANT_Fieldref_info、 CONSTANT_Methodref_info 等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢?</p>
<ul>
<li>符号引用 (Symbolic References)：符号引用以一组符号来描述所引用的目标, 符号引用可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关, 用的目标并不一定已经加载到内存中。</li>
<li>直接引用 (Direct Referenc)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用, 那引用的目标必定已经在内存中存在。</li>
</ul>
<p>虚拟机规范之中并未规定解析阶段发生的具体时间, 只要求了在执行 anewarray、checkcast, getfield, getstatic, instanceof, invokeinterface, invokespecial, invokestatic、invokevirtual, multianewarray、new、 putfield 和 putstatIc 这 13 个用于操作符号引用的字节码指令之前, <strong>先对它们所使用的符号引用进行解析</strong>。所以虚拟机实现会根据需要来判断, 到底是在类被加载器加载时就对常量池中的符号引用进行解析, 还是等到一个符号引用将要被使用前才去解析它。</p>
<p>对同一个符号引用进行多次解析请求是很常见的事情, 虚拟机实现可能会对第一次解析的结果进行<strong>缓存</strong> (在运行时常量池中记录直接引用, 并把常量标识为已解析状态) 从而避免解析动作重复进行。无论是否真正执行了多次解析动作, 虚拟机需要保证的都是在同一个实体中, 如果一个符号引用之前已经被成功解析过, 那么后续的引用解析请求就应当一直成功; 同样地, 如果第一次解析失败了, 其他指令对这个符号的解析请求也应该收到相同的异常。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行, 分别对应于常量池的 <code>CONSTANT_Class_info、</code> <code>CONSTANT_Fieldref_info</code>、 <code>CONSTANT_Methodref_info</code>及 <code>CONSTANT_InterfaceMethodref_info</code>四种常量类型。下面将讲解这四种引用的解析过程。</p>
<ul>
<li>
<ol>
<li>类或接口的解析：</li>
</ol>
</li>
</ul>
<p>假设当前代码所处的类为 D, 如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用, 那虚拟机完成整个解析的过程需要包括以下 3 个步骤：</p>
<ol>
<li>如果 C 不是一个数组类型, 那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中, 由于无数据验证、字节码验证的需要, 又将可能触发其他相关类的加载动作, 例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常, 解析过程就将宣告失败</li>
</ol>
<p>2)如果 C 是一个数组类型, 并且数组的元素类型为对象, 也就是 N 的描述符会是类似 “[Ljava. ang Integer” 的形式, 那将会按照第 1 点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式, 需要加载的元素类型就是“ java. lang Integer”, 接着由虚拟机生成一个代表此数组维度和元素的数组对象</p>
<ol start="3">
<li>如果上面的步骤没有出现任何异常, 那么 C 在虚拟机中实际上已经成为一个有效的类或接口了, 但在解析完成之前还要进行符号引用验证, 确认 C 是否具备对 D 的访问权限。如果发现不具备访问权限, 将抛出 java.lang.IllegalAccessError 异常</li>
</ol>
<ul>
<li>
<ol start="2">
<li>字段解析：</li>
</ol>
</li>
</ul>
<p>要解析一个未被解析过的字段符号引用, 首先将会对字段表内 class index 项中索引的 CONSTANT_Class_info 符号引用进行解解析, 也就是字段所属的类成接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常, 都会导致字段符号引用解析的失败。如果解析成功完成, 那将这个字段所属的类或接口用 C 表示, 虚拟机规范要求按照如下步骤对 C 进行后续字段的搜索</p>
<ol>
<li>如果 C 本身就包含了简单名称和字段描述符都与目标相匹配的字段, 则返这个字段的直接引用, 查找结束</li>
<li>否则, 如果在 C 中实现了接口, 将会按照继承关系从上往下递归搜索各个接口和它的父接口, 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束</li>
<li>否则, 如果 C 不是 java.lang.Object 的话, 将会按照继承关系从上往下递归搜索其父类) 如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束</li>
<li>否则, 查找失败, 抛出 java.lang.NoSuchFieldError 异常</li>
</ol>
<p>如果查找过程成功返回了引用, 将会对这个字段进行权限验证, 如果发现不具备对字段的访问权限, 将抛出 java.lang.IllegalAccess Error 异常</p>
<p>在实际应用中, 虚拟机的编译器实现可能会比上述规范要求得更加严格一些, 如果有一个同名字段同时出现在 C 的接口和父类中, 或者同时在自己或父类的多个接口中出现, 那编译器将可能拒绝编译。在代码清单 7-4 中, 如果注释了 Sub 类中的 “public static int A=4;”, 接口与父类同时存在字段 A, 那编译器将提示 “ The field Sub.A is ambiguous&quot; ，并且会拒绝编译这段代码</p>
<ul>
<li>
<ol start="3">
<li>类方法解析</li>
</ol>
</li>
</ul>
<p>类方法解析的第一个步骤与字段解析一样，也是需要先解析出类方法表的 class index 项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用 C 表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：</p>
<p>1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index 中索引的 C 是个接口，那就直接抛出 java.lang.IncompatibleClassChangeError 异常。</p>
<p>2）如果通过了第（1）步，在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>3）否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>4）否则，在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类 C 是一个抽象类，这时候查找结束，抛出 java.lang.AbstractMethodError 异常</p>
<p>5）否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError</p>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证；如果发现不具备对此方法的访问权限，将抛出 java.lang.IllegalAccessError 异常</p>
<ul>
<li>
<ol start="4">
<li>接口方法解析</li>
</ol>
</li>
</ul>
<p>接口方法也是需要先解析出接口方法表的 class index 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用 C 表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<p>1）与类方法解析相反，如果在接口方法表中发现 class index 中的索引 C 是个类而不是接口，那就直接抛出 java.lang.IncompatibleClassChangeError 异常。</p>
<p>2）否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>3）否则，在接口 C 的父接口中递归查找，直到 java.lang.Object 类（查找范围会包括 Object 类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>4）否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError 异常</p>
<p>由于接口中的所有方法都默认是 public 的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出 java.lang.IllegalAccess Error 异常。</p>
</blockquote>
<h5 id="3、初始化："><a class="header-anchor" href="#3、初始化：">¶</a>3、初始化：</h5>
<p>这个初始化是类的初始化，不是实例的初始化。</p>
<p>为类的静态变量赋予正确的初始值。为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值。初始化阶段就是指向类构造器方法<code>&lt;clinit&gt;()</code>【意思是 class init】的过程，此方法不需定义，是 javac 编译器自动收集类中的所有<strong>类变量的赋值动作和静态代码块中的语句</strong>合并而来。<code>&lt;clinit&gt;()</code>不同于类的构造器，若该类具有父类，JVM 会保证子类的<code>&lt;clinit&gt;</code>执行前，父类的<code>&lt;clinit&gt;</code>已经执行完毕。JVM 必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</p>
<h5 id="代码执行顺序"><a class="header-anchor" href="#代码执行顺序">¶</a>代码执行顺序</h5>
<p>3.1、<code>&lt;clinit&gt;()</code>是由编译器自动收集类中的所有类变量的赋值动作 (static 变量) 和静态语句块（static 代码块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</p>
<p>3.2、 <code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是 java.lang.Object</p>
<p>3.3、由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语块要优先于子类的变量赋值操作，如代码清单 7-5 中，字段 B 的值将会是 2 而不是 1</p>
<pre class="line-numbers language-none"><code class="language-none">static class Parent&#123;
    public static int A&#x3D;1;
    static&#123;
        A&#x3D;2;
    &#125;
&#125;
public class Sub extends Parent&#123;
    public static int B&#x3D;A;
&#125;
public static void main(String[] args)&#123;
    Sub.B.sout;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4、 <code>&lt;clinit&gt;()</code>方法对于类和接口来说并不是必须的，如果一个类中没有静态代码块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法方法</p>
<p>3.5、 接口中不能使用静态代码块，带仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，<strong>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有父接口定义的变量被使用时，父接口才回被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法</strong></p>
<p>3.6、 虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果一个类的<code>&lt;clinit&gt;()</code>方法有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
<blockquote>
<p>（1）使用到静态加载时，静态又分为： 静态变量， 静态代码块，其中加载顺序是按照类中书写的先后顺序加载的<br>
（2）非静态加载顺序： 按照非静态书写顺序加载 /（）执行<br>
（3）<strong>静态方法，实例方法只有在调用的时候才会去执行</strong><br>
（4）当静态加载中遇到需要加载非静态的情况： <strong>先加载非静态再加载静态</strong>（因为非静态可以访问静态，而静态不能访问非静态）</p>
<pre class="line-numbers language-none"><code class="language-none">public static Text t1 &#x3D; new Text(&quot;t1&quot;);  
&#x2F;&#x2F; 当加载静态变量是需要先加载构造器， 那就转为先加载所有非静态属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>静态变量声明 一定 放在使用前面</p>
<pre class="line-numbers language-none"><code class="language-none">public static int count;
static &#123;count++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</blockquote>
<h5 id="实例执行顺序"><a class="header-anchor" href="#实例执行顺序">¶</a>实例执行顺序</h5>
<blockquote>
<p>实例的构造器<code>&lt;init&gt;</code>：</p>
<p>时机：在非静态成员全部赋值完成，才会继续执行自己构造内，剩余代码。</p>
<p>非静态成员的赋值，是在自己的构造调用之后，并且是在自己的构造调用完父类的构造 super 之后。实例初始化是在实例的构造函数中，而他相应的父类是调用 super() 完成的，如果没有显示写<code>super()</code>，那么将加在第一句。当父类没有无参构造函数时，在子类构造方法中必须显示指定，如<code>super(&quot;hello&quot;)</code></p>
<p>有父类有无参构造时，super 可以省略，此时子类可以使用 this 调用构造方法，<strong>this 在构造方法的作用是调用子类的其他构造方法</strong>；父类没有无参构造时，子类不能使用 this 调用构造方法。</p>
<p>普通代码块在每次创建对象时都会调用一次。</p>
<p>顺序是写的顺序，并且优先于构造函数执行。</p>
<p>总结：</p>
<p>1、父类的静态变量和静态块赋值（按照声明顺序）<br>
2、自身的静态变量和静态块赋值（按照声明顺序）<br>
3、main 方法<br>
4、父类的成员变量和块赋值（按照声明顺序）<br>
5、父类构造器赋值<br>
6、自身成员变量和块赋值（按照声明顺序）<br>
7、自身构造器赋值<br>
8、静态方法，实例方法只有在调用的时候才会去执行</p>
</blockquote>
<p>以 final 关键字为例先体会一下类加载流程</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 常量都是用final来修饰的，所以只要在包含它类实例化对象完成之前初始化就行了，什么都不影响。但是如果前面加个static表明类装载时这个常量必须是有个状态的（被赋予了值，初始化了），所以如果用static就必须类加载时初始化。

&#x2F;&#x2F; 只被final关键字修饰的常量，实例化的构造方法完成之前有值就可
&#x2F;&#x2F;可以在其类加载时就初始化，也可以到类的构造方法里面再对它进行初始化：例如
class A&#123;
    final int i;&#x2F;&#x2F;或者final int i&#x3D;10; &#x2F;&#x2F; 有没有值无所谓，实例化的构造方法完成之前有值就可
    public A()&#123;
        i&#x3D;10;
    &#125;
&#125;

&#x2F;&#x2F;用static和final关键字同时修饰的常量就必须得在定义时初始化，例如：
class A&#123;
    static final int i&#x3D;10;&#x2F;&#x2F;编译时候就赋值了
&#125;

&#x2F;&#x2F; 基本类型，是值不能被改变  &#x2F;&#x2F;引用类型，是地址值不能被改变,对象中的属性可以改变
public static void method(final int x) &#123; &#x2F;&#x2F;此处的final修饰的 x随着方法使用完毕后回收,当再次调用时，重新分配空间
	System.out.println(x);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-1-类加载"><a class="header-anchor" href="#2-1-类加载">¶</a>2.1_类加载</h3>
<p>类加载定义：将类的. class 文件中的二进制数据（字节流）读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个 java.lang.Class 对象（规范并未说明 Class 对象位于哪里，HotSpot 虚拟机将其放在<strong>方法区</strong>中）用来封装内在方法区内的数据结构。</p>
<p>注：</p>
<ul>
<li>
<p>class 文件在文件开头有特定的文件标示</p>
</li>
<li>
<p>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定</p>
</li>
<li>
<p>加载. class 文件的方式<br>
（1）从本地系统中直接加载<br>
（2）通过网络下载. class 文件<br>
（3）从 zip，jar 等归档文件中加载. class 文件<br>
（4）从专用数据库中提取. class 文件<br>
（5）将 java 源文件动态编译为. class 文件</p>
</li>
</ul>
<h4 id="2-1-1-类装载器的分类："><a class="header-anchor" href="#2-1-1-类装载器的分类：">¶</a>2.1.1_类装载器的分类：</h4>
<ul>
<li>① 启动类加载器 / 根加载器 / 引导类加载器（Bootstrap）：
<ul>
<li>C++ 编写。默认加载路径<code>$JAVAHOME/$jre/lib/rt.jar</code>。里面有如 rt.jar/sun/misc /Launcher.class，Object.class 等。该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性 sun.boot.class.path 所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成 java.lang.ClassLoader 类。出于安全考虑，根加载器只加载包名为 java，javax，sun 等开头的类。</li>
</ul>
</li>
<li>② 扩展类加载器（Extension）：
<ul>
<li>Java 编写 ，由 sun.misc.Launcher$ExtClassLoader 实现。</li>
<li>默认加载路径<code>JDK安装目录/jre/lib/ext/*.jar</code>（可通过<code>Djava.ext.dirs</code>系统属性重新指定）<strong>如果用户创建的 JAR 放在此目录下，也会由拓展类加载器自动加载</strong>。</li>
<li>扩展类加载器是 java.lang.ClassLoader 的子类。</li>
</ul>
</li>
<li>③ 应用程序类加载器（AppClassLoader，也叫系统类加载器）：
<ul>
<li>Java 编写，它的父加载器为扩展类加载器，他是用户自定义的类加载器的默认父加载器。</li>
<li>加载当前应用的 classpath 的所有类。默认加载路径为：<code>环境变量$classpath</code>(可以通过<code>Djava.class.path</code>重新指定)。</li>
<li>可以通过<code>ClassLoader.getSystemClassLoader()</code>获取到应用类加载器。</li>
</ul>
</li>
<li>④用户自定义加载器：Java.lang.ClassLoader 的子类，用户可以定制类的加载方式。默认加载路径<code>\$CLASSPATH</code>；
<ul>
<li>为什么要使用自定义类加载器：隔离加载类、修改类加载的方式、拓展加载源、防止源码泄漏</li>
<li>实现步骤：继承抽象类 Java.lang.ClassLoader，重写 findClass() 方法</li>
</ul>
</li>
</ul>
<p>层次为：根类加载器–&gt; 扩展类加载器–&gt; 系统应用类加载器–&gt; 自定义类加载器</p>
<p>获取类加载器方法：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过java对象.object.getClass().getClassLoader();获取该类的载器
Object object&#x3D;new Object();
object.getClass().getClassLoader();&#x2F;&#x2F;null。Bootstrap根加载器是c++写的，java查不出来
object.getClass().getClassLoader().getParent();&#x2F;&#x2F;报错，根加载器是最初级的了

&#x2F;&#x2F;-----------------------------------------
Object object2&#x3D;new MyTest();&#x2F;&#x2F;自己写的类
System.out.println(object2.getClass().getClassLoader(););
&#x2F;&#x2F;自定义类默认的加载器是应用加载器AppClassloader&#x2F;&#x2F;sun.misc.launcher$AppClassLoader$18b4aac2。位于rt.jar包中

ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();&#x2F;&#x2F;获取系统加载器
System.out.println(systemClassLoader);&#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2
System.out.println(systemClassLoader.getParent());&#x2F;&#x2F;sun.misc.Launcher$ExtClassLoader@1b6d3586
System.out.println(systemClassLoader.getParent().getParent());&#x2F;&#x2F;null


&#x2F;&#x2F;获取根加载器所能加载的路径
URL[] urLs &#x3D; Launcher.getBootstrapClassPath().getURLs();
for ( URL element :urLs) &#123;
    System.out.println(element.toExternalForm());
&#125;
&#x2F;*
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;resources.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;rt.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;jsse.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;jce.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;charsets.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;lib&#x2F;jfr.jar
file:&#x2F;E:&#x2F;Java&#x2F;jdk1.8.0_231&#x2F;jre&#x2F;classes
*&#x2F;

System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));&#x2F;&#x2F;获取根加载器路径
System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));&#x2F;&#x2F;获取扩展类加载器路径
&#x2F;&#x2F; E:\Java\jdk1.8.0_231\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext
System.out.println(System.getProperty(&quot;java.class.path&quot;));&#x2F;&#x2F;获取应用类加载器路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类加载器的加载时机：类加载器并不需要等到某个类被 “首次主动使用” 时再加载它：JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了. class 文件缺失或存在错误，类加载器必须在<strong>程序首次主动</strong>使用该类才报告错误（LinkageError 错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。</p>
<h4 id="2-1-2-自定义加载器"><a class="header-anchor" href="#2-1-2-自定义加载器">¶</a>2.1.2_自定义加载器</h4>
<p>为什么需要自定义类加载器：</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
<p>使用方法：</p>
<ul>
<li>继承抽象了 java.lang.ClassLoader</li>
<li>在 JDK1.2 之前，需要重写 loadClass()；JDK1.2 之后，不需要重写 loadClass() 了，建议重写<code>findClass()</code></li>
<li>如果没有太多复杂的需求，可以直接继承 URLCloassLoader 类，就可以避免自己编写 findClass() 及其获取字节码流的方式，使自定义类加载器编写更加简洁。可以看 test16</li>
</ul>
<p>JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的 ClassLoader(指 CLassLoader 实例对象) 必须相同<br>
换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</li>
</ul>
<h6 id="类加载器深入剖析："><a class="header-anchor" href="#类加载器深入剖析：">¶</a>类加载器深入剖析：</h6>
<ul>
<li>Java 虚拟机与程序的生命周期</li>
<li>在如下几种情况下，java 虚拟机将结束生命周期<br>
（1）执行了 System.exit() 方法<br>
（2）程序正常执行结束<br>
（3）程序在执行过程中遇到了异常或错误而异常终止<br>
（4）由于操作系统出现错误而导致虚拟机进程终止</li>
</ul>
<p>获取类加载器的途径：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取当前类的加载器
（1）clazz.getClassLoader(); 

&#x2F;&#x2F; 获取当前线程上下文的加载器
（2）Thread.currentThread().getContextClassLoader(); 

&#x2F;&#x2F; 获取系统的加载器
（3）ClassLoader.getSystemClassLoader(); 

&#x2F;&#x2F; 获取调用者的加载器
（4）DriverManager.getCallerClassLoader();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p>
<pre class="line-numbers language-none"><code class="language-none">getParent();
loadClass(String);
findClass();
findLoadedClass();
defineClass();
resolveClass();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-1-3-双亲委托-派-机制"><a class="header-anchor" href="#2-1-3-双亲委托-派-机制">¶</a>2.1.3_双亲委托 (/ 派) 机制</h4>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823165459877.png" class="" loading="lazy">
<p>类加载器用来把类加载到 java 虚拟机中。从 JDK1.2 版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证 Java 平台的安全。在此委托机制中，除了 java 虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当 java 程序请求加载器 loader1 加载 Sample 类时，loader1 首先委托自己的父加载器去加载 Sample 类，<strong>若父加载器能加载，则由父加载器完成加载任务，否则才由加载器 loader1 本身加载 Sample 类。</strong></p>
<p><strong>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成</strong>，每一个层次类加载器都是如此，<strong>因此所有的加载请求都应该传送到启动类加载其中</strong>，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。</p>
<blockquote>
<p>若有一个类能够成功加载 Test 类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回 Class 对象引用的类加载器（包括定义类加载器）称为<strong>初始类加载器</strong>。</p>
<p>比如一个自定义类，可以由自定义类加载器和系统加载器加载，但是类路径下没有 class 文件，所以系统加载器加载不到，只有自定义加载器能加载到。此时，系统加载器和自定义加载器都是定义类加载器；而自定义加载器才是初试类加载器。详情可以看 Test16</p>
</blockquote>
<p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p>
<p>类加载器双亲委托模型的好处：<br>
（1）可以确保 Java 和核心库的安全：所有的 Java 应用都会引用 java.lang 中的类，也就是说在运行期 java.lang 中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在 JVM 中存在多个版本的 java.lang 中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java 核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了 Java 应用所使用的的都是同一个版本的 Java 核心类库，他们之间是相互兼容的；<br>
（2）确保 Java 核心类库中的类不会被自定义的类所替代；<br>
（3）不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器去加载即可。相当于在 Java 虚拟机内部建立了一个又一个相互隔离的 Java 类空间。</p>
<blockquote>
<p>如果自定义了一个 String 类，会因为先加载到系统的，而无法使用 main 方法</p>
<p>先找到先使用，后面的不看</p>
</blockquote>
<p>沙箱安全机制：自定义 String 类，但是在加载自定义 String 类的时候回率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java/lang/String.class），报错信息说没有 main 方法就是因为加载的是 rt.jar 包中的 String 类，这样可以保证对 java 核心源代码的保护，这就是沙箱安全。</p>
<h4 id="2-1-4-命名空间"><a class="header-anchor" href="#2-1-4-命名空间">¶</a>2.1.4_命名空间</h4>
<ul>
<li>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有父加载器所加载的类构成</strong>；</li>
<li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</li>
<li>同一命名空间内的类是互相可见的，<strong>非同一命名空间内的类是不可见的</strong>；</li>
<li>子加载器可以见到父加载器加载的类，<strong>父加载器也不能见到子加载器加载的类</strong>。</li>
</ul>
<h3 id="2-2-链接"><a class="header-anchor" href="#2-2-链接">¶</a>2.2_链接</h3>
<p>类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p>
<ul>
<li>类的连接 - 验证<br>
1）类文件的结构检查<br>
2）语义检查<br>
3）字节码验证<br>
4）二进制兼容性的验证</li>
<li>类的连接 - 准备<br>
在准备阶段，java 虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下 Sample 类，在准备阶段，将为 int 类型的静态变量 a 分配 4 个字节的内存空间，并且赋予默认值 0，为 long 类型的静态变量 b 分配 8 个字节的内存空间，并且赋予默认值 0；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class Sample&#123;
    private static int a&#x3D;1;
    public  static long b;
    public  static long c;
    static &#123; b&#x3D;2; &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-3-类的初始化"><a class="header-anchor" href="#2-3-类的初始化">¶</a>2.3_类的初始化</h3>
<p>首先明确是类的初始化而不是类实例的初始化。</p>
<blockquote>
<p>tips：idea 安装 jclasslib 插件可以看到<code>&lt;clinit&gt;</code></p>
</blockquote>
<p>初始化阶段就是执行构造器方法<code>&lt;clinit&gt;</code>，他不是我们普通的构造器。而<strong>是类的初始化而且他是自动生成的</strong>，编译器收集类中所以类静态变量的赋值动作和静态代码块中的语句合并而来。<strong>没有静态变量和静态代码块就不生成 clinit 方法了</strong>。</p>
<p>构造器方法中指令按语句在源文件中出现的顺序执行。</p>
<p>JVM 会确保子类的 clinit 方法在父类 clinit 已经执行结束。</p>
<p>虚拟机必须保证一个类的 clinit 方法在多线程下被同步加锁。</p>
<p>在链接阶段已经定义好了，在这个阶段只是覆盖。但是不能在定义前调用它，这是编译器决定的。</p>
<p>而 init 是我们真正的构造器。</p>
<p>在初始化阶段，Java 虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：</p>
<ul>
<li>（1）在静态变量的声明处进行初始化；</li>
<li>（2）在静态代码块中进行初始化。</li>
</ul>
<p>类的初始化步骤：</p>
<ul>
<li>（1）假如这个类还没有被加载和连接，那就先进行加载和连接</li>
<li>（2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
<ul>
<li>当 java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，<strong>但是这条规则不适用于接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化</strong>。<strong>只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化</strong>。</li>
</ul>
</li>
<li>（3）假如类中存在初始化语句，那就依次执行这些初始化语句</li>
</ul>
<p>Java 程序对类的使用方式可分为两种</p>
<ul>
<li>（1）主动使用</li>
<li>（2）被动使用</li>
</ul>
<p>所有的 Java 虚拟机实现必须在每个类或接口被 Java 程序 “首次主动使用” 时才能初始化他们</p>
<ul>
<li>主动使用（七种）
<ul>
<li>（1）new 创建类的实例</li>
<li>（2）访问某个类或接口的静态变量 (getstatic（助记符）)，或者对该静态变量赋值 putstatic</li>
<li>（3）调用类的静态方法 invokestatic</li>
<li>（4）反射（Class.forName(“com.test.Test”)）</li>
<li>（5）初始化一个类的子类</li>
<li>（6）Java 虚拟机启动时被标明启动类的类</li>
<li>（7）JDK1.7 开始提供的动态语言支持（了解）</li>
</ul>
</li>
<li>被动使用<br>
除了上面七种情况外，其他使用 java 类的方式都被看做是对类的被动使用，都不会导致类的初始化。如
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数字定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
<li>调用 ClassLoader 类的 loadClass 方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li>
</ul>
</li>
</ul>
<h3 id="执行顺序"><a class="header-anchor" href="#执行顺序">¶</a>执行顺序</h3>
<ul>
<li>静态代码块： <strong>静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。<strong>如果一个类中有多个静态代码块，会按照书写</strong>顺序依次执行</strong>。
<ul>
<li>一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。</li>
<li>在类加载的时候，静态方法也已经加载了，但是我们必须要通过类名或者对象名才能访问，也就是说相比于静态代码块，<strong>静态代码块是主动运行的，而静态方法是被动运行的。</strong></li>
<li>静态变量要放在静态代码块前</li>
</ul>
</li>
<li>先初始化父类再初始化子类。先调用父类的构造函数再调用子类的构造函数</li>
<li>构造代码块：在 java 类中使用 {} 声明的代码块（和静态代码块的区别是少了 static 关键字）。** 构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。** 构造代码块依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的</li>
</ul>
<p>1、父类的静态变量和静态块赋值（按照声明顺序）<br>
　　2、自身的静态变量和静态块赋值（按照声明顺序）<br>
　　3、main 方法<br>
　　3、父类的成员变量和块赋值（按照声明顺序）<br>
　　4、父类构造器赋值<br>
　　5、自身成员变量和块赋值（按照声明顺序）<br>
　　6、自身构造器赋值<br>
　　7、静态方法，实例方法只有在调用的时候才会去执行</p>
<h2 id="3-内存结构"><a class="header-anchor" href="#3-内存结构">¶</a>3_内存结构</h2>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200328142826.png" class="" loading="lazy"> ![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png)
<h3 id="3-0-预备知识：javap-工具与-JVM-参数设置"><a class="header-anchor" href="#3-0-预备知识：javap-工具与-JVM-参数设置">¶</a>3.0 预备知识：javap 工具与 JVM 参数设置</h3>
<p>反编译工作 javap：解析 class 文件</p>
<h4 id="助记符"><a class="header-anchor" href="#助记符">¶</a>助记符</h4>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shi1122/article/details/8053605">https://blog.csdn.net/shi1122/article/details/8053605</a></p>
<p>JVM 虚拟机栈里有：操作数栈、局部变量表、方法返回地址、动态链接</p>
<p>局部变量表放到操作数栈中操作完后再放回局部变量表。</p>
<p>对于 i++，++i 原理是：</p>
<ul>
<li>i++ 是先把原来的数放到操作数栈，再把局部变量表里的 + 1；</li>
<li>++i 是把操作数栈里的数直接加 1，然后再把 + 1 后的值放到局部变量表里</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 
&#x2F;&#x2F; 下面的栈顶指的是操作数栈顶
助记符 ldc：表示将int、float或者String类型的常量值从常量池中推送至操作数栈顶
助记符 bipush：表示将单字节（-128-127）的常量值推送到栈顶
助记符 sipush：表示将一个短整型值（-32768-32369）推送至栈顶
助记符 iconst_1：表示将int型的1推送至栈顶（iconst_m1到iconst_5）
当int取值-1~5采用iconst指令，
取值-128~127采用bipush指令，
取值-32768~32767采用sipush指令，
取值-2147483648~2147483647采用 ldc 指令。

将一个局部变量加载到操纵栈的指令包括：iload、iload_、lload…
将一个数值从操作数栈存储到局部变量表的指令包括：istore、istore_、lstore…

偏移地址   操作指令  java源代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="JVM-参数设置"><a class="header-anchor" href="#JVM-参数设置">¶</a>JVM 参数设置</h4>
<table><thead><tr><th>说明</th><th>参数</th></tr></thead><tbody><tr><td>栈</td><td><code>-Xss</code></td></tr><tr><td>堆初始大小</td><td><code>-Xms</code></td></tr><tr><td>堆最大大小（新生代 + 老年大）</td><td><code>-Xmx</code> 或 -XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td><code>-Xmn</code> 或 (-XX:NewSize=size + -XX:MaxNewSize=size)</td></tr><tr><td>幸存区比例（动态调整）</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>GC 详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>FullGC 前先 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr><tr><td></td><td><code>-XX:+PrintGCDetails</code></td></tr></tbody></table>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/index.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/index.html</a></p>
<p>虚拟机设置官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/">https://docs.oracle.com/javase/8/</a></p>
<h3 id="3-1-程序计数器"><a class="header-anchor" href="#3-1-程序计数器">¶</a>3.1_程序计数器</h3>
<ul>
<li><strong>定义：</strong> Program Counter Register 程序计数器（PC 寄存器），就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，也即将要执行的指令代码，这样线程切换后就可以知道从哪里开始执行了），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。他是线程私有的，这样 cpu 又回来执行的时候才知道从哪执行。</li>
<li><strong>作用：</strong> 记住下一条 jvm 指令的执行地址，用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。。</li>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>线程私有</li>
<li>程序计数器是内存中唯一一个不会出现内存溢出 (OutOfMemory=OOM) 的区域</li>
<li>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li>
<li>场景：现实中程序往往是多线程协作完成任务的。JVM 的多线程是通过 CPU 时间片轮转来实现的，某个线程在执行的过程中可能会因为时间片耗尽而挂起。当它再次获取时间片时，需要从挂起的地方继续执行。</li>
</ul>
<h3 id="3-2-JVM-栈"><a class="header-anchor" href="#3-2-JVM-栈">¶</a>3.2_JVM 栈</h3>
<p><strong>定义：</strong> Java Virtual Machine Stacks(java 虚拟机栈) 栈也叫栈内存，主管 Java 程序的运行。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a4.png" class="" loading="lazy">
<ol>
<li>
<p>每个线程都有自己的栈，栈中的数据都是以 ** 栈帧 (Stack Frame)** 的格式存在</p>
</li>
<li>
<p>在这个线程上正在执行的每个方法都对应各自的一个栈帧</p>
</li>
<li>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p>
</li>
</ol>
<p>4.JVM 直接对 java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出 / 后进先出的和原则。</p>
<ol start="5">
<li>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧 (Current Frame)</strong>, 与当前栈帧对应的方法就是<strong>当前方法（Current Frame）</strong></p>
</li>
<li>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p>
</li>
<li>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。</p>
</li>
<li>
<p>不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧</p>
</li>
<li>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
</li>
</ol>
<p>10.Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
<ul>
<li>
<p>线程私有：在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，</p>
</li>
<li>
<p><strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就 Over。</p>
</li>
<li>
<p><strong>-Xss 设置栈内存大小，一般<code>-Xss=1M</code></strong>。</p>
</li>
<li>
<p>JVM 栈是由栈帧组成的，：</p>
</li>
<li>
<p>栈帧：<strong>栈中的数据都是以栈帧（Stack Frame）的格式存在</strong>，栈帧是一个内存区块，是一个数据集，是一个有关方法 (Method) 和运行期数据的数据集。<strong>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。每个线程都只有一个<strong>活动栈帧</strong>，对应着线程当前执行的<strong>方法</strong>。活动栈帧即栈顶的帧。(在 IDEA 的 Frames 窗口中可以查看调用的帧)</p>
<ul>
<li>每个栈帧中存储着:</li>
</ul>
</li>
<li>
<p><strong>1. 局部变量表</strong>（Local Variables）：输入参数和输出参数以及方法内的变量；8 种基本类型的变量 + 对象的引用变量。栈里存放的是对象的引用 ref，而对象实际上是存在堆里面的，对象引用 ref 指向堆里对象。实际上引用还指向了 class 文件，所以 ref 有两种指向情况：</p>
<ul>
<li>①ref 先执行了两个指针，两个指针又分别指向对象数据 + 对象所属的类型（元数据 class 信息，元数据一个类只有一份，在方法区中）。
<ul>
<li>②ref 第一部分指向数据本身，第二部分是元数据的指针</li>
</ul>
</li>
<li><strong>2. 操作数栈</strong>（Operand Stack）(或表达式栈)：记录出栈、入栈的操作；</li>
<li><strong>3. 动态链接</strong>（Dynamic Linking）(或执行 “运行时常量池” 的方法引用)---- 深入理解 Java 多态特性必读！！</li>
<li>
<ol start="4">
<li>方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）</li>
</ol>
</li>
<li>
<ol start="5">
<li>一些附加信息</li>
</ol>
</li>
</ul>
</li>
<li>
<p>栈内存溢出：栈帧过多，栈被撑破了（递归）、栈帧过大（交叉引用）。栈没有 GC</p>
</li>
</ul>
<p><strong>栈运行原理：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，
A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，
B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，
……
执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>遵循 “先进后出”/“后进先出” 原则。</p>
<p>栈的大小和具体 JVM 的实现有关，通常在 256K~756K 之间, 与等于 1Mb 左右。</p>
<blockquote>
<p>线程的局部变量是否线程安全？<br>
<strong>答：</strong> 不一定。方法内的局部变量且没有逃离方法的作用访问时，是线程安全的。如果局部变量引用了对象，由于对象存在于堆中，一般其他线程可以访问修改，需要考虑线程安全。线程私有的，就不用考虑线程安全。是 static 的，就得考虑线程安全。</p>
</blockquote>
<p>java 虚拟机规范允许 <strong>Java 栈的大小是动态的或者是固定不变的</strong></p>
<p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 java 虚拟机栈容量可以在线程创建的时候独立选定。如果<strong>线程请求分配的栈容量超过 java 虚拟机栈允许的最大容量</strong>，java 虚拟机将会抛出一个 <strong>StackOverFlowError</strong> 异常</p>
<pre class="line-numbers language-none"><code class="language-none">public class StackErrorTest &#123;
    public static void main(String[] args) &#123;
        main(args);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 java 虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 java 虚拟机将会抛出一个 <strong>OutOfMemoryError 异常</strong></p>
<pre class="line-numbers language-none"><code class="language-none">关于Error我们再多说一点，上面的讨论不涉及Exception
首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。

Exception和Error体现了JAVA这门语言对于异常处理的两种方式。
Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。

Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。

其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 编译一段程序看看二进制文件及反编译的结果
public class Main11 &#123;
    int a &#x3D; 0;

    public Main11() &#123;
    &#125;

    public int add(int a) &#123;
        System.out.println(111);
        return 1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">G:\test\target\classes&gt;javap -v Main11.class &#x2F;&#x2F;反编译class文件
Classfile &#x2F;G:&#x2F;test&#x2F;target&#x2F;classes&#x2F;Main11.class
  Last modified 2020-8-27; size 485 bytes
  MD5 checksum 1a7c4c8ffff290383477e59505da70e8
  Compiled from &quot;Main11.java&quot;
public class Main11
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 &#x3D; Methodref          #6.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
   #2 &#x3D; Fieldref           #5.#21         &#x2F;&#x2F; Main11.a:I
   #3 &#x3D; Fieldref           #22.#23        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;
   #4 &#x3D; Methodref          #24.#25        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V
   #5 &#x3D; Class              #26            &#x2F;&#x2F; Main11
   #6 &#x3D; Class              #27            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object
   #7 &#x3D; Utf8               a
   #8 &#x3D; Utf8               I
   #9 &#x3D; Utf8               &lt;init&gt;
  #10 &#x3D; Utf8               ()V
  #11 &#x3D; Utf8               Code
  #12 &#x3D; Utf8               LineNumberTable
  #13 &#x3D; Utf8               LocalVariableTable
  #14 &#x3D; Utf8               this
  #15 &#x3D; Utf8               LMain11;
  #16 &#x3D; Utf8               add
  #17 &#x3D; Utf8               (I)I
  #18 &#x3D; Utf8               SourceFile
  #19 &#x3D; Utf8               Main11.java
  #20 &#x3D; NameAndType        #9:#10         &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V
  #21 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; a:I
  #22 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;lang&#x2F;System
  #23 &#x3D; NameAndType        #29:#30        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;
  #24 &#x3D; Class              #31            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream
  #25 &#x3D; NameAndType        #32:#33        &#x2F;&#x2F; println:(I)V
  #26 &#x3D; Utf8               Main11
  #27 &#x3D; Utf8               java&#x2F;lang&#x2F;Object
  #28 &#x3D; Utf8               java&#x2F;lang&#x2F;System
  #29 &#x3D; Utf8               out
  #30 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;
  #31 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream
  #32 &#x3D; Utf8               println
  #33 &#x3D; Utf8               (I)V
&#123;
  int a;
    descriptor: I
    flags:

  public Main11();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
         4: aload_0
         5: iconst_0
         6: putfield      #2                  &#x2F;&#x2F; Field a:I
         9: return
      LineNumberTable:
        line 1: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   LMain11;

  public int add(int);
    descriptor: (I)I
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;2
         0: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;
         3: bipush        111
         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V
         8: iconst_1
         9: ireturn
      LineNumberTable:
        line 7: 0
        line 8: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   LMain11;
            0      10     1     a   I
&#125;
SourceFile: &quot;Main11.java&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-2-1-局部变量表"><a class="header-anchor" href="#3-2-1-局部变量表">¶</a>3.2.1 局部变量表</h4>
<ol>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
</ol>
<p><strong>2. 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddresslndexing</p>
<ol start="3">
<li>由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li>
</ol>
<p><strong>4. 局部变量表所需的容量大小是在编译期确定下来的</strong>, 并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
<p><strong>5. 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</strong> 对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间。</p>
<p><strong>6. 局部变量表中的变量只在当前方法调用中有效。</strong> 在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></p>
<p>利用<code>javap</code>命令对字节码文件进行解析查看 main() 方法对应栈帧的【局部变量表】，如图：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a5.png" class="" loading="lazy">
<p>也可以在 IDEA 上安装<code>jclasslib byte viewcoder</code>插件查看方法内部字节码信息剖析，以 main() 方法为例</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a6.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a7.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a8.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a9.png" class="" loading="lazy">
<h5 id="变量槽-slot-的理解与演示"><a class="header-anchor" href="#变量槽-slot-的理解与演示">¶</a>变量槽 slot 的理解与演示</h5>
<ol>
<li>
<p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 - 1 的索引结束</p>
</li>
<li>
<p>局部变量表，<strong>最基本的存储单元是 Slot(变量槽)</strong></p>
</li>
<li>
<p>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。</p>
</li>
<li>
<p>在局部变量表里，<strong>32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。</strong></p>
</li>
</ol>
<p>byte、short、char、float 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true；</p>
<p>long 和 double 则占据两个 slot。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200401213601820-1712399995.png" class="" loading="lazy">
<p>5.JVM 会为局部变量表中的每一个 slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<ol start="6">
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照声明顺序被复制到局部变量表中的每一个 slot 上</li>
</ol>
<p><strong>7. 如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问 long 或者 double 类型变量）</p>
<ol start="8">
<li>
<p>如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么 == <strong>该对象引用 this 将会存放在 index 为 0 的 slot 处</strong> ==, 其余的参数按照参数表顺序排列。</p>
</li>
<li>
<p>静态方法中不能引用 this，是因为静态方法所对应的栈帧当中的局部变量表中不存在 this</p>
</li>
</ol>
<p>示例代码：</p>
<pre class="line-numbers language-none"><code class="language-none">public class LocalVariablesTest &#123;

    private int count &#x3D; 1;
    &#x2F;&#x2F;静态方法不能使用this
    public static void testStatic()&#123;
        &#x2F;&#x2F;编译错误，因为this变量不存在与当前方法的局部变量表中！！！
        System.out.println(this.count);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="slot-的重复利用"><a class="header-anchor" href="#slot-的重复利用">¶</a>slot 的重复利用</h5>
<p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<pre class="line-numbers language-none"><code class="language-none">private void test2() &#123;&#x2F;&#x2F; slot的重复利用
    int a &#x3D; 0;
    &#123;
        int b &#x3D; 0;
        b &#x3D; a+1;
    &#125;
    &#x2F;&#x2F;变量c使用之前以及经销毁的变量b占据的slot位置
    int c &#x3D; a+1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码对应的栈帧中局部变量表中一共有多少个 slot，或者说局部变量表的长度是几？</p>
<p>答案是 3：this、a、c</p>
<p>变量 b 的作用域是</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
    int b &#x3D; 0;
    b &#x3D; a+1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>this 占 0 号、a 单独占 1 个槽号、c 重复使用了 b 的槽号</p>
<h5 id="静态变量与局部变量的对比及小结"><a class="header-anchor" href="#静态变量与局部变量的对比及小结">¶</a>静态变量与局部变量的对比及小结</h5>
<p>变量的分类：</p>
<ul>
<li>按照数据类型分：
<ul>
<li>①基本数据类型;</li>
<li>②引用数据类型；</li>
</ul>
</li>
<li>按照在类中声明的位置分：
<ul>
<li>①成员变量：在使用前，都经历过默认初始化赋值
<ul>
<li>static 修饰：类变量：类加载<strong>链接</strong>的准备 preparation 阶段给类变量默认<strong>赋 0 值</strong>——&gt; <strong>初始化</strong>阶段 initialization 给类变量<strong>显式赋值</strong>即静态代码块赋值；</li>
<li>不被 static 修饰：实例变量：随着对象的创建，会在<strong>堆空间</strong>分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</li>
</ul>
</li>
</ul>
<p><strong>补充说明</strong></p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h4 id="3-2-2-操作数栈（Operand-Stack）"><a class="header-anchor" href="#3-2-2-操作数栈（Operand-Stack）">¶</a>3.2.2 操作数栈（Operand Stack）</h4>
<ol>
<li>
<p>栈 ：可以使用数组或者链表来实现</p>
</li>
<li>
<p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈</p>
</li>
</ol>
<p><strong>3. 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</strong></p>
<p><strong>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈</strong>。（如字节码指令 bipush 操作）</p>
<p>比如：执行复制、交换、求和等操作</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402095033111-1956475857.png" class="" loading="lazy">
<h5 id="操作数栈特点"><a class="header-anchor" href="#操作数栈特点">¶</a>操作数栈特点</h5>
<ul>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li>
<li>操作数栈就是 jvm 执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的 code 属性中，为 max_stack 的值。</li>
<li>栈中的任何一个元素都是可以任意的 java 数据类型
<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈深度单位</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈 push 和出栈 pop 操作来完成一次数据访问</li>
<li>** 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，** 并更新 PC 寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</li>
<li>另外，我们说 Java 虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>, 其中的栈指的就是操作数栈。</li>
</ul>
<h5 id="操作数栈代码追踪"><a class="header-anchor" href="#操作数栈代码追踪">¶</a>操作数栈代码追踪</h5>
<blockquote>
<p>// JVM虚拟机栈里有：操作数栈、局部变量表、方法返回地址、动态链接<br>
// 下面的栈顶指的是操作数栈顶<br>
// push是放到操作数栈的栈顶   load是从局部变量表加载到操作数栈  store是从操作数栈放到局部变量表<br>
助记符 ldc：表示将int、float或者String类型的常量值从常量池中推送至操作数栈顶<br>
助记符 bipush：表示将单字节（-128-127）的常量值推送到栈顶<br>
助记符 sipush：表示将一个短整型值（-32768-32369）推送至栈顶<br>
助记符 iconst_1：表示将int型的1推送至栈顶（iconst_m1到iconst_5）<br>
当int取值-1~5采用iconst指令，<br>
取值-128~127采用bipush指令，<br>
取值-32768~32767采用sipush指令，<br>
取值-2147483648~2147483647采用 ldc 指令。</p>
<p>将一个局部变量加载到操纵栈的指令包括：iload、iload_、lload…<br>
将一个数值从操作数栈存储到局部变量表的指令包括：istore、istore_、lstore…</p>
<p>偏移地址   操作指令  java源代码</p>
</blockquote>
<p>结合上图结合下面的图来看一下一个方法（栈帧）的执行过程</p>
<p>①15 入栈；②存储 15，15 进入局部变量表</p>
<p>注意：局部变量表的 0 号位被构造器占用，这里的 15 从局部变量表 1 号开始</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100253935-1789842330.png" class="" loading="lazy">
<p>③压入 8；④8 出栈，存储 8 进入局部变量表；</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100334236-1637713126.png" class="" loading="lazy">
<p>⑤从局部变量表中把索引为 1 和 2 的是数据取出来，放到操作数栈；⑥iadd 相加操作</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100351272-751766212.png" class="" loading="lazy">
<p>⑦iadd 操作结果 23 出栈⑧将 23 存储在局部变量表索引为 3 的位置上 istore_3</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402100449299-194786867.png" class="" loading="lazy">
<p>bipush sipush</p>
<p>如果有返回值是什么样的？</p>
<ul>
<li><strong>返回的那个变量把值压入栈然后当前栈帧结束</strong></li>
<li><strong>下一个栈帧一上来就把就把值压入当前栈</strong></li>
</ul>
<p>i++ 和 ++i 有什么区别</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;
int i1&#x3D;10;
i1++;
int i2&#x3D;10;
++i2;

&#x2F;&#x2F;
int i3&#x3D;10;
int i4&#x3D;i3++;
int i5&#x3D;10;
int i6&#x3D;++i5;

&#x2F;&#x2F;
int i7&#x3D;10;
i7&#x3D;i7++;
int i8&#x3D;10;
i8&#x3D;++i8;

&#x2F;&#x2F;
int i9&#x3D;10;
i10&#x3D;i9++ + ++i9;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="栈顶缓存技术-ToS（Top-of-Stack-Cashing）"><a class="header-anchor" href="#栈顶缓存技术-ToS（Top-of-Stack-Cashing）">¶</a>栈顶缓存技术 ToS（Top-of-Stack Cashing）</h5>
<ul>
<li>基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读 / 写次数</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读 / 写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读 / 写次数，提升执行引擎的执行效率</strong></li>
</ul>
<h4 id="3-2-3-动态链接（Dynamic-Linking）"><a class="header-anchor" href="#3-2-3-动态链接（Dynamic-Linking）">¶</a>3.2.3 动态链接（Dynamic Linking）</h4>
<blockquote>
<p>这部分可以结合类加载链接阶段的解析阶段看</p>
</blockquote>
<ol>
<li><strong>运行时常量池</strong>在 JDK7 之前位于方法区， JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 <strong>Java 堆</strong>中开辟了一块区域存放运行时常量池。（每个类都有自己的常量池）</li>
</ol>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a10.png" class="" loading="lazy">
<p>字节码中的常量池结构如下：</p>
<blockquote>
<p>如下所示，栈帧包含 4 个部分：返回值、局部变量表、操作数栈、动态链接</p>
<p>这个动态链接引用指向的是当前类的运行时常量池</p>
<p>还可以注意到运行时常量池在方法区中</p>
</blockquote>
<p><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a11.png" alt="" loading="lazy"><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/1846149-20200402110625116-1337433158.png" alt="" loading="lazy"></p>
<p>为什么需要常量池呢？<br>
常量池的作用，就是为了提供一些符号和常量，便于指令的识别。下面提供一张测试类的运行时字节码文件格式</p>
<p>通过<code>javap -v Test.class</code>反编译出来的内容如下</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a12.png" class="" loading="lazy">
<p>上面的内容也可以用 IDEA 的 jclasslib 插件查看</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a13.png" class="" loading="lazy">
<blockquote>
<p>上图在 jclasslib 插件的 code 中可以查看，下图不是该类的代码，但可以通过他看看规则</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a14.png" class="" loading="lazy">
</blockquote>
<p>invokeVirtual 代表调用方法，是 #5 所代表的字母的方法</p>
<ul>
<li>getstatic：获取静态变量，如<code>System.out</code>，其中 out 就是 System 类的静态变量</li>
<li>invokevirtual 调用方法</li>
</ul>
<ol start="2">
<li>
<p>每一个栈帧内部都包含一个指向<code>运行时常量池Constant pool</code>或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如 <strong>invokedynamic</strong> 指令</p>
</li>
<li>
<p>在 Java 源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在 class 字节码文件（javap 反编译查看）的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用（#）最终转换为调用方法的直接引用。</strong></p>
</li>
</ol>
<h5 id="3-2-3-1-方法的调用"><a class="header-anchor" href="#3-2-3-1-方法的调用">¶</a>3.2.3.1 方法的调用</h5>
<p>多态：在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><strong>静态链接</strong><br>
当一个 字节码文件被装载进 JVM 内部时，如果<strong>被调用的目标方法在编译期可知，且运行期保持不变</strong>时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
<ul>
<li>绑定是一个字段、方法或者类<strong>将符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</li>
<li><strong>早期绑定</strong><br>
早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li><strong>动态链接</strong><br>
如果被调用的方法<strong>在编译期无法被确定</strong>下来，也就是说，<strong>只能够在程序运行期将调用方法的符号引用转换为直接引用</strong>，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。
<ul>
<li><strong>晚期绑定</strong><br>
如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a15.png" class="" loading="lazy">
<blockquote>
<p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++ 语言中的虚函数（C++ 中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p>
</blockquote>
<h5 id="3-2-3-2-虚方法和非虚方法"><a class="header-anchor" href="#3-2-3-2-虚方法和非虚方法">¶</a>3.2.3.2 虚方法和非虚方法</h5>
<pre class="line-numbers language-none"><code class="language-none">子类对象的多态性使用前提：实际开发编写代码中用的接口，实际执行是导入的的三方jar包已经实现的功能
①类的继承关系（父类的声明）②方法的重写（子类的实现）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>非虚方法：如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</p>
<p>虚方法：所有体现多态特性的方法称为虚方法</p>
<ul>
<li>非虚方法：</li>
<li>1.invokestatic：调用静态方法，解析阶段<strong>确定</strong>唯一方法版本；（非虚方法）</li>
<li>2.invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段<strong>确定</strong>唯一方法版本；（非虚方法）</li>
<li>虚方法：</li>
<li>3.invokevirtual：调用所有虚方法；（虚方法）
<ul>
<li>final 修饰的除外，JVM 会把 final 方法调用也归为 invokevirtual 指令，但要注意 final 方法调用不是虚方法</li>
</ul>
</li>
<li>4.invokeinterface：调用接口方法；（虚方法）</li>
<li>动态调用指令（Java7 新增）：<br>
5.invokedynamic：动态解析出需要调用的方法，然后执行 .<br>
前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。
<ul>
<li>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是 Java 为了实现「动态类型语言」支持而做的一种改进。</li>
<li>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到 Java8 的 Lambda 表达式的出现，invokedynamic 指 令的生成，在 Java 中才有了直接的生成方式。</li>
<li>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</li>
</ul>
</li>
</ul>
<blockquote>
<p>动态类型语言和静态类型语言。</p>
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<p>方法的调用：方法重写的本质<br>
Java 语言中方法重写的本质:</p>
<ol>
<li>
<p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</p>
</li>
<li>
<p>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束; 如果不通过，则返回 java.lang.IllegalAccessError 异常。</p>
</li>
<li>
<p>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</p>
</li>
<li>
<p>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。</p>
</li>
</ol>
<p>IllegalAccessError 介绍:<br>
程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
</blockquote>
<h6 id="虚方法表"><a class="header-anchor" href="#虚方法表">¶</a>虚方法表</h6>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在<strong>类的方法区</strong>建立一个虚方法表 (virtual method table) (非虚方法不会出现在表中) 来实现。使用索引表来代替查找。
<ul>
<li>virtual dispatch 机制会首先从 receiver（被调用方法的对象）的类的实现中查找对应的方法，如果没找到，则去父类查找，直到找到函数并实现调用，而不是依赖于引用的类型。</li>
</ul>
</li>
<li>每个类中都有一一个虚方法表，表中存放着各个方法的实际入口。</li>
<li>那么虚方法表什么时候被创建?<br>
创建时机：虚方法表会在类加载的<strong>链接阶段</strong>被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29310729/article/details/106167943">https://blog.csdn.net/qq_29310729/article/details/106167943</a></p>
<p>方法调用：虚方法表</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a16.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a17.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a18.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a19.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a20.png" class="" loading="lazy">
<h5 id="多态原理"><a class="header-anchor" href="#多态原理">¶</a>多态原理</h5>
<p>多态的两种实现方式：</p>
<ul>
<li>1、子类继承父类（extends）</li>
<li>2、类实现接口（implements）</li>
<li>无论是哪种方法，其核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">class Person &#123;
    public String toString() &#123; return &quot;I&#39;m a person.&quot;;&#125;
    public void eat() &#123;&#125;
    public void speak() &#123;&#125;
&#125;
 
class Boy extends Person &#123;
    public String toString() &#123;  return &quot;I&#39;m a boy&quot;; &#125;
    public void speak() &#123;&#125;
    public void fight() &#123;&#125;
&#125;
 
class Girl extends Person &#123;
    public String toString() &#123; return &quot;I&#39;m a girl&quot;;&#125;
    public void speak() &#123;&#125;
    public void sing() &#123;&#125;
&#125;
&#x2F;&#x2F; 当这三个类被载入到 Java 虚拟机之后，方法区中就包含了各自的类的信息。Girl 和 Boy 在方法区中的方法表可表示如下：
class Party &#123;
    void happyHour() &#123;
        Person girl &#x3D; new Girl();&#x2F;&#x2F; 注意用的是父类接收 &#x2F;&#x2F;Girl实现了Person类
        girl.speak();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160812143114843" class="" loading="lazy">
<p>注意方法表条目指向的具体的方法地址，如 Girl 的继承自 Object 的方法中，只有 toString() 指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。</p>
<h6 id="继承的多态"><a class="header-anchor" href="#继承的多态">¶</a>继承的多态</h6>
<p>重要的几句话：</p>
<ul>
<li>
<p>Person 或 Object 的任意一个方法，在它们 (作为父类) 的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。</p>
<ul>
<li>刚开始我有点绕，我还合计要是有两个父类，一个父类的第 3 个索引是 a() 方法，第二个父类的第三个索引是 b() 方法，那么子类的第三个索引是哪个方法呢？原来这就是 java 为什么单继承的一部分原因，不会有两个父类，只有有 1 个父类，所以索引对应的方法是统一的。还值得注意的是这里说的是继承，没有说实现，也就是接口的多态原理并不是这个，一会我们再介绍</li>
</ul>
</li>
<li>
<p>如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。</p>
</li>
<li>
<p>因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。</p>
</li>
<li>
<p>Person 或 Object 中的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可</p>
</li>
</ul>
<p>当编译 Party 类的时候，生成 <code>girl.speak()</code>的方法调用假设为：</p>
<p>并且是个方法引用类型</p>
<pre class="line-numbers language-none"><code class="language-none">#12 &#x3D; Methodref          #21.#22        &#x2F;&#x2F; com&#x2F;example&#x2F;demo&#x2F;Person.speak:()V

#8 &#x3D; Utf8               ()V
#21 &#x3D; Class              #25            &#x2F;&#x2F; com&#x2F;example&#x2F;demo&#x2F;Person
#22 &#x3D; NameAndType        #26:#8         &#x2F;&#x2F; speak:()V
#26 &#x3D; Utf8               speak

JVM 首先查看 Party 的常量池索引为 12 的条目（应为 CONSTANT_Methodref_info 类型，可视为方法调用的符号引用），进一步查看常量池（CONSTANT_Class_info，CONSTANT_NameAndType_info ，CONSTANT_Utf8_info）可得出要调用的方法是 Person 的 speak 方法（注意引用 girl 是其基类 Person 类型），查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15（offset），这就是该方法调用的直接引用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Invokevirtual #12</code>，即调用方法，哪个方法呢？运行时常量池中的第 12 个字符串，而第 12 个字符串表示的是 Person 类的 speak()</p>
<p>查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15（offset），这就是该方法调用的直接引用。</p>
<p>JVM 执行真正的方法调用：根据实例方法调用的参数 <strong>this 得到具体的对象</strong>（即 girl 所指向的位于堆中的对象），据此<strong>得到该对象对应的方法表 (Girl 的方法表</strong> )，进而调用方法表中的某个偏移量所指向的方法（Girl 的 speak() 方法的实现）</p>
<ul>
<li>如果 this 所指向的第 15 个索引对应的方法不是 speak 方法，那么就说明 Girl 没有实现 speak 方法，去父类中的第 15 个索引位置找这个方法即可。这里我们实现了，所以找到了，无需再找父类的第 15 个索引对应的方法</li>
</ul>
<p>具体过程：</p>
<p>假设类 B 是类 A 的子类，以 A a = new B() 为例</p>
<p>① A a 作为一个引用类型数据，存储在 JVM 栈的本地变量表中。<br>
② new B() 作为实例对象数据存储在堆中<br>
　　 Ｂ的对象实例数据（接口、方法、field、对象类型等）的地址也存储在堆中<br>
　　 Ｂ的对象的类型数据（对象实例数据的地址所执行的数据）存储在方法区中，方法区对象类型数据中有一个指向该类方法的方法表。</p>
<p>③Java 虚拟机规范中并未对引用类型访问具体对象的方式做规定，目前主流的实现方式主要有两种：</p>
<p>１. 通过句柄访问</p>
<p>在这种方式中，JVM 堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。</p>
<p>２. 通过直接指针访问</p>
<p>通过直接指针访问的方式中，reference 中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在 HotSpot 虚拟机中用的就是这种方式。</p>
<p>④实现过程</p>
<p>首先虚拟机通过 reference 类型（A 的引用）查询 java 栈中的本地变量表，得到堆中的对象类型数据的地址，从而找到方法区中的对象类型数据（B 的对象类型数据） ，然后查询方法表定位到实际类（B 类）的方法运行。</p>
<h6 id="接口的多态"><a class="header-anchor" href="#接口的多态">¶</a>接口的多态</h6>
<p>因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。原因我们刚才说了，java 是单继承，多实现。多实现的话我们就不能用刚才的逻辑处理接口多态了，因为我们无法决定第 15 个方法应该去哪个接口类中找，万一多个接口类中都有这个方法，使用哪个呢？所以接口不能用刚才继承的逻辑了</p>
<p>这也就是为什么编译指令的时候要把虚方法的 invokevirtual 和 invokeinterface 分开写，而不是合并到一起的原因。</p>
<ul>
<li>invokevirtual 指令用于调用声明为类的方法；</li>
<li>invokeinterface 指令用于调用声明为接口的方法；</li>
</ul>
<p>Java 对于接口方法的调用是采用<strong>搜索方法表</strong>的方式，对如下的方法调用：</p>
<ol>
<li>invokeinterface #13</li>
<li>JVM 首先查看常量池，获取方法调用的符号引用（名称、返回值等等），然后利用 this 指向的实例，得到该实例的方法表，进而搜索方法表来找到合适的方法地址。</li>
<li>因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的</li>
</ol>
<blockquote>
<p>注：实际上似乎并不是永远都是 invokeinterface，我写了接口的实现后反编译出现的是 invokevirtual，我个人的猜测是，jdk 对此进行了优化，因为接口多态遍历费时，那在某些情况下用 Invokevirtual 直接定位到就省时了</p>
</blockquote>
<p>下面程序是用来复习 invoke 的</p>
<pre class="line-numbers language-none"><code class="language-none">interface MethodInterface&#123;
    void methodA();
&#125;

class Father&#123;
    public Father()&#123;
        System.out.println(&quot;father的构造器&quot;);
    &#125;
    public static void showStatic(String str)&#123;
        System.out.println(&quot;father &quot;+ str);
    &#125;
    public final void showFinal()&#123;
        System.out.println(&quot;father show final&quot;);
    &#125;
    public void showCommon()&#123;
        System.out.println(&quot;father 普通方法&quot;);
    &#125;

&#125;
public class Son extends Father&#123;
    public Son()&#123;
        &#x2F;&#x2F;invokespecial
        super();
    &#125;
    public Son(int age)&#123;
        &#x2F;&#x2F;invokespecial
        this();
    &#125;
    &#x2F;&#x2F;不是重写的父类的静态方法，因为静态方法不能被重写
    public static void showStatic(String str)&#123;
        System.out.println(&quot;son &quot;+ str);
    &#125;
    public void showPrivate(String str)&#123;
        System.out.println(&quot;son private &quot;+str);
    &#125;
    public void show()&#123;
        &#x2F;&#x2F;invokestatic
        showStatic(&quot;p3wj.top&quot;);
        &#x2F;&#x2F;invokestatic
        Father.showStatic(&quot;good!&quot;);
        &#x2F;&#x2F;invokespecial
        showPrivate(&quot;hello!&quot;);
        &#x2F;&#x2F;invokespecial
        super.showCommon();
        
        &#x2F;&#x2F;虚方法：编译期间无法确定下来的
        &#x2F;&#x2F;invokevirtual,虽然是这个但是被final修饰他不是一个虚方法
        showFinal();
        &#x2F;&#x2F;invokespecial，加上super,显示地表示是一个父类地方法
        super.showFinal();
        
        &#x2F;&#x2F;invokevirtural,因为有可能该子类会重写这方法，如果加上super就是invokespecial
        showCommon();
        info();

        MethodInterface in &#x3D; null;
        &#x2F;&#x2F;invokeinterface
        in.methodA();

    &#125;
    public void info()&#123;

    &#125;
    public void display(Father f)&#123;
        f.showCommon();
    &#125;

    public static void main(String[] args) &#123;
        Son so &#x3D; new Son();
        so.show();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-2-4-方法返回地址（主要针对于正常退出的情况）"><a class="header-anchor" href="#3-2-4-方法返回地址（主要针对于正常退出的情况）">¶</a>3.2.4 方法返回地址（主要针对于正常退出的情况）</h4>
<p>●存放调用该方法的 pc 寄存器的值。<br>
●一个方法的结束，有两种方式:</p>
<p>➢正常执行完成<br>
➢出现未处理的异常，非正常退出</p>
<p>●无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，** 调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。** 而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>交给执行引擎，去执行后续的操作</p>
<p>区别：</p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于: 通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法:<br>
1、执行引擎遇到任意 - 一个方法返回的字节码指令 (return)，会有返回值传递给上层的方法调用者，简称正常完成出口;<br>
➢一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。<br>
➢在字节码指令中，返回指令包含 ireturn (当返回值是 boolean、byte、char、short 和 int 类型时使用)、<code>lreturn、 freturn、 dreturn以及areturn</code>，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</p>
<p>2、在方法执行的过程中遇到了异常 (Exception) ，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<p>以上数字为字节码指令地址</p>
<p>如果在 4-16 行出现异常，则用 19 行处理，针对任何类型</p>
<table><thead><tr><th>Exception</th><th></th><th>Table:</th><th></th></tr></thead><tbody><tr><td>from</td><td>to</td><td>target</td><td>type</td></tr><tr><td>4</td><td>16</td><td>19</td><td>any</td></tr><tr><td>19</td><td>21</td><td>19</td><td>any</td></tr></tbody></table>
<h3 id="3-3-本地方法栈"><a class="header-anchor" href="#3-3-本地方法栈">¶</a>3.3_本地方法栈</h3>
<p>简单地讲，一个 Native Method 就 是一个 Java 调用非 Java 代码的接口。 一个 Native Method 是这样 一个 Java 方法: 该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++ 中，你可以用 extern “C” 告 知 C++ 编译器去调用 - 一个 C 的函数。</p>
<p>“A native method is a Java method whose implementation isprovided by non-java code.”</p>
<p>在定义一个 native method 时，并不提供实现体 (有些像定义一个 Javainterface)，因为其实现体是由非 java 语言在外面实现的。</p>
<blockquote>
<ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
</blockquote>
<p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序。</p>
<pre class="line-numbers language-none"><code class="language-none">public class IHaveNatives &#123;
    public native void Native1(int x);

    native static public long Native2();

    native synchronized private float Native3(Object o);

    native void Native4(int[] art) throws Exception;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本地方法栈<br>
●Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。<br>
●本地方法栈，也是线程私有的。<br>
允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同的)</p>
<p>➢如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。<br>
➢如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</p>
<p>●本地方法是使用 C 语言实现的。<br>
●它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p>
<p>●当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟<br>
机限制的世界。它和虚拟机拥有同样的权限。</p>
<p>➢本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。<br>
➢它甚至可以直接使用本地处理器中的寄存器<br>
➢直接从本地内存的堆中分配任意数量的内存。</p>
<p>●并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求 9<br>
** 本地方法栈的使用语言、具体实现方式、数据结构等。** 如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。<br>
●在 Hotspot JVM 中， 直接将本地方法栈和虚拟机栈合二为一。</p>
<p>本地方法栈：JAVA 虚拟机调用本地方法时，给本地方法分配的内存空间。</p>
<p>本地方法 native method：不是由 java 编写的代码，如 C 写的与操作系统底层打交道的方法。如 Object 类中的<code>protected native Object clone();</code></p>
<p>本地方法栈类似于虚拟机栈，也是线程私有。</p>
<p>不同点：本地方法栈服务的对象是 jvm 运行的 native 方法，而虚拟机栈服务的是 jvm 执行的 java 方法。</p>
<blockquote>
<p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序，Java 诞生的时候是 C/C++ 横行的时候，要想立足，必须有调用 C/C++ 程序，于是就在内存中专门开辟了一块区域处理标记为 native 的代码，它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载 native libraies。</p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p>
</blockquote>
<h3 id="3-4-堆"><a class="header-anchor" href="#3-4-堆">¶</a>3.4_堆</h3>
<p><strong>定义：</strong> Heap，通过 new 关键字创建的对象，都存放在堆内存中。</p>
<p><strong>特点</strong></p>
<ul>
<li>线程共享，堆中的对象都存在线程安全的问题。</li>
<li>垃圾回收，垃圾回收机制重点区域。</li>
</ul>
<p>根据垃圾回收的划分，逻辑上将堆划分为：</p>
<ul>
<li>新生代 Young Generation
<ul>
<li>Eden 伊甸园</li>
<li>幸存区 Survivor From</li>
<li>幸存区 Survivor To</li>
</ul>
</li>
<li>老年代 Tenure generation</li>
<li>JDK7 之前为 Permanent 永久区，JDK8 之后为元空间</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;演示堆内存溢出  &#x2F;&#x2F;-Xms  -Xmx
public class Demo&#123;
    public static void main(String[] args)&#123;
        int i&#x3D;0;
        try&#123;
            List&lt;String&gt; list&#x3D;new ArrayList&lt;&gt;();
            String a&#x3D;&quot;hello&quot;;
            while(true)&#123;
                list.add(a);&#x2F;&#x2F;list对象始终被关联，无法被回收，死循环不断将list规模变大，最终大于堆内存大小，内存溢出。
                a&#x3D;a+a;
                i++;
            &#125;
        &#125;catch(Throwable e)&#123;
            e.printStackTrace();
            System.out.println(i);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;对象什么时候释放：
public void method()&#123;
    Object obj&#x3D; new Object();
&#125;
生成了2部分的内存区域：1：obj这个引用变量，因为是方法内的变量，放到JVM栈里面（引用占4个字节）。2：真正Objectclass的实例对象放到Heap里面。（空对象栈8个字节）
方法结束后，对应栈中的变量马上回收，但是对重的对象要等到GC来回收<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个进程对应一个 JVM 实例，对应一个 runtime data area 运行时数据区</p>
<p>一个进程对应一个 jvm 实例，一个运行时数据区。一个进程中的多个线程共享同一个方法区、堆空间，各自拥有程序计数器、本地方法栈、虚拟机栈</p>
<p>●一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管 理的核心区域。<br>
●Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。<br>
➢堆内存的大小是可以调节的。<br>
●《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。（涉及到物理内存和虚拟内存）<br>
●所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区 (ThreadLocal Allocation Buffer， TLAB)</p>
<p>堆空间大小的设置和查看：</p>
<ul>
<li>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过下面选项设置
<ul>
<li>“<code>-Xms</code>” 用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li>
<li>“<code>-Xmx</code>” 则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li>
</ul>
</li>
<li>●一旦堆区中的内存大小超过 “-Xmx&quot; 所指定的最大内存时，将会抛出 OutOfMemoryError 异常。<br>
通常会将 - Xms 和 - Xmx 两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。<br>
●默认情况下，初始内存大小: 物理电脑内存大小 / 64<br>
最大内存大小: 物理电脑内存大小 / 4</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">Runtime.getRuntime().totalMemory();
Runtime.getRuntime().maxMemory();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="堆内存诊断"><a class="header-anchor" href="#堆内存诊断">¶</a>堆内存诊断</h4>
<ul>
<li>jps 工具
<ul>
<li>查看系统有哪些进程。<code>jps</code></li>
</ul>
</li>
<li>jmap 工具
<ul>
<li>查看堆内存使用情况 <code>jmap -heap 【进程号】</code></li>
</ul>
</li>
<li>jconsole 工具
<ul>
<li>图形界面，多功能检测工具，连续监测。</li>
</ul>
</li>
<li>jvisualVM</li>
</ul>
<p>有下面程序：</p>
<pre class="line-numbers language-none"><code class="language-none">public class Demo1 &#123;
    public static  void main(String[] args) throws InterruptedException &#123;
        System.out.println(&quot;1....&quot;);
        Thread.sleep(30000);
        byte[] array &#x3D;  new byte[1024 * 1024 * 10];&#x2F;&#x2F;10M
        System.out.println(&quot;2....&quot;);
        Thread.sleep(30000);
        array &#x3D; null;&#x2F;&#x2F;array没有引用，可以被回收了
        System.gc();
        System.out.println(&quot;3...&quot;);
        Thread.sleep(1000000L);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行上面代码，首先在终端输入 jps 得到 Demo 进程 PID，根据 PID 再通过<code>jmap -heap PID</code>每次查看进程占用内存情况：</p>
<pre class="line-numbers language-none"><code class="language-none">D:\openSourceProject\jvm1&gt;jps
8916 Launcher
9876 RemoteMavenServer36
13976 Demo1 &#x2F;&#x2F;这个就是我们的进程号
13756 Jps
    
&#x2F;&#x2F;----------------------------------------
&#x2F;&#x2F;按进程号查看堆情况
D:\openSourceProject\jvm1&gt;jmap -heap 13976
Attaching to process ID 13976, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.221-b11

using thread-local object allocation.
Parallel GC with 8 thread(s)

Heap Configuration:
   MinHeapFreeRatio         &#x3D; 0
   MaxHeapFreeRatio         &#x3D; 100
   MaxHeapSize              &#x3D; 4276092928 (4078.0MB)
   NewSize                  &#x3D; 89128960 (85.0MB)
   MaxNewSize               &#x3D; 1425014784 (1359.0MB)
   OldSize                  &#x3D; 179306496 (171.0MB)
   NewRatio                 &#x3D; 2
   SurvivorRatio            &#x3D; 8
   MetaspaceSize            &#x3D; 21807104 (20.796875MB)
   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)
   MaxMetaspaceSize         &#x3D; 17592186044415 MB
   G1HeapRegionSize         &#x3D; 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity &#x3D; 67108864 (64.0MB)
   used     &#x3D; 6711104 (6.40020751953125MB)&#x2F;&#x2F;6M
   free     &#x3D; 60397760 (57.59979248046875MB)
   10.000324249267578% used
From Space:
   capacity &#x3D; 11010048 (10.5MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 11010048 (10.5MB)
   0.0% used
To Space:
   capacity &#x3D; 11010048 (10.5MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 11010048 (10.5MB)
   0.0% used
PS Old Generation
   capacity &#x3D; 179306496 (171.0MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 179306496 (171.0MB)
   0.0% used
3175 interned Strings occupying 260400 bytes.
       
&#x2F;&#x2F;----------------------------------------
&#x2F;&#x2F;再次输入
D:\openSourceProject\jvm1&gt;jmap -heap 13976&#x2F;&#x2F;每次都得重新输入
Attaching to process ID 13976, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.221-b11

using thread-local object allocation.
Parallel GC with 8 thread(s)

Heap Configuration:
   MinHeapFreeRatio         &#x3D; 0
   MaxHeapFreeRatio         &#x3D; 100
   MaxHeapSize              &#x3D; 4276092928 (4078.0MB)
   NewSize                  &#x3D; 89128960 (85.0MB)
   MaxNewSize               &#x3D; 1425014784 (1359.0MB)
   OldSize                  &#x3D; 179306496 (171.0MB)
   NewRatio                 &#x3D; 2
   SurvivorRatio            &#x3D; 8
   MetaspaceSize            &#x3D; 21807104 (20.796875MB)
   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)
   MaxMetaspaceSize         &#x3D; 17592186044415 MB
   G1HeapRegionSize         &#x3D; 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity &#x3D; 67108864 (64.0MB)
   used     &#x3D; 17196880 (16.400222778320312MB)&#x2F;&#x2F;16M&#x3D;6+10
   free     &#x3D; 49911984 (47.59977722167969MB)
   25.62534809112549% used
From Space:
   capacity &#x3D; 11010048 (10.5MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 11010048 (10.5MB)
   0.0% used
To Space:
   capacity &#x3D; 11010048 (10.5MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 11010048 (10.5MB)
   0.0% used
PS Old Generation
   capacity &#x3D; 179306496 (171.0MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 179306496 (171.0MB)
   0.0% used

3176 interned Strings occupying 260456 bytes.
&#x2F;&#x2F;----------------------------------------
D:\openSourceProject\jvm1&gt;jmap -heap 13976
Attaching to process ID 13976, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.221-b11

using thread-local object allocation.
Parallel GC with 8 thread(s)

Heap Configuration:
   MinHeapFreeRatio         &#x3D; 0
   MaxHeapFreeRatio         &#x3D; 100
   MaxHeapSize              &#x3D; 4276092928 (4078.0MB)
   NewSize                  &#x3D; 89128960 (85.0MB)
   MaxNewSize               &#x3D; 1425014784 (1359.0MB)
   OldSize                  &#x3D; 179306496 (171.0MB)
   NewRatio                 &#x3D; 2
   SurvivorRatio            &#x3D; 8
   MetaspaceSize            &#x3D; 21807104 (20.796875MB)
   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)
   MaxMetaspaceSize         &#x3D; 17592186044415 MB
   G1HeapRegionSize         &#x3D; 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity &#x3D; 67108864 (64.0MB)
   used     &#x3D; 1342200 (1.2800216674804688MB)&#x2F;&#x2F;1M
   free     &#x3D; 65766664 (62.71997833251953MB)
   2.0000338554382324% used
From Space:
   capacity &#x3D; 11010048 (10.5MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 11010048 (10.5MB)
   0.0% used
To Space:
   capacity &#x3D; 11010048 (10.5MB)
   used     &#x3D; 0 (0.0MB)
   free     &#x3D; 11010048 (10.5MB)
   0.0% used
PS Old Generation
   capacity &#x3D; 179306496 (171.0MB)
   used     &#x3D; 1106008 (1.0547714233398438MB)
   free     &#x3D; 178200488 (169.94522857666016MB)
   0.6168253937659905% used

3162 interned Strings occupying 259464 bytes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>jconsole 使用</strong> 控制台输入 jconsole。图中竖条是代表控制台有输出？</p>
<p><a target="_blank" rel="noopener" href="http://47.98.150.21/upload/2020/3/image-50bd0d32512e4654a6e0e307178e54fd.png"><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a21.png" alt="" loading="lazy"></a></p>
<p>可明显看出内存变化。</p>
<p><strong>一个简单的案例</strong></p>
<ul>
<li>执行多次垃圾回收后，内存占用依然很高
<ul>
<li>
<ol>
<li>控制台输入 jvisitualvm，在左边选择对应进程，右面点 “堆 dump”。</li>
</ol>
</li>
<li>
<ol start="2">
<li>点击 “查找”，点击第一条占用内存最大的记录。</li>
</ol>
</li>
<li>
<ol start="3">
<li>找到问题所在，list 中有过多大对象 student，无法被清除。</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class Demo2 &#123;
    public static  void main(String[] args) throws InterruptedException &#123;
        List&lt;student&gt; list &#x3D; new ArrayList&lt;&gt;();
        for (int i &#x3D; 0; i &lt; 200;i++)&#123;
            list.add(new student());
        &#125;
        Thread.sleep(10000000000L);
    &#125;
&#125;

class student&#123;
    private byte[] big &#x3D; new byte[1024 * 1024];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-5-方法区"><a class="header-anchor" href="#3-5-方法区">¶</a>3.5_方法区</h3>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，<strong>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>(类信息和运行时常量池)</p>
<p>方法区 Mthod Area：所有线程共享的一块区域，存储了每个类 class 结构的信息，包括：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/8189e84069fb7da05aaebfa345c6c18a4d095945.png" class="" loading="lazy"> <img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20180704121146905" class="" loading="lazy">
<blockquote>
<p>这里的运行时常量池在 JDK7 之后放在了堆区</p>
</blockquote>
<p>方法区是 GC 的非主要工作区域，java 虚拟机规范表示可以不要求虚拟机在这区实现 GC，这区 GC 的性价比一般比较低；在堆中，尤其是新生代，常规应用进行一次 GC 一般可以回收 70%~95% 的空间，而方法区的 GC 效率远小于此。当前的商业 JVM 都有实现方法区的 GC，主要回收两部分：废弃常量和无用类。</p>
<p>类回收需要满足如下 3 个条件：</p>
<ul>
<li>该类所有的实例都已经被 GC，也就是 JVM 中不存在该 Class 的任何实例</li>
<li>加载该类的 ClassLoader 已经被 GC</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，如：不能再任何地方通过反射访问该类的方法</li>
</ul>
<p>在大量使用反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要 JVM 具备类下载的支持以保证方法区不会溢出。</p>
<p>从 JDK1.8 开始就没有永久代了，变为了元空间</p>
<pre class="line-numbers language-none"><code class="language-none">实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。
	
	对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。
	
永久区(java7之前有)
	永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。
	永久代 Permanent Generation，从JDK1.8彻底废弃，使用元空间 meta space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下图演示了栈帧里的局部变量指向了堆与方法区</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a22.png" class="" loading="lazy">
<h4 id="运行时常量池"><a class="header-anchor" href="#运行时常量池">¶</a>运行时常量池</h4>
<p>栈帧里的动态链接连接到了运行时常量池</p>
<ul>
<li>Class 文件的常量池与方法区的运行时常量池：我们写的每一个 Java 类被编译后，就会形成一份 class 文件；每一个 Class 文件中，都维护着一个常量池（这个保存在类文件里面，不要与方法区的运行时常量池搞混）。这个常量池的内容，在类加载的时候，被复制到方法区的运行时常量池 ；</li>
<li>class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是<code>常量池(constant pool )</code>，用于存放编译期生成的各种字面量 (Literal) 和符号引用(Symbolic References)
<ul>
<li><code>字面量</code>包括：1. 文本字符串 2. 八种基本类型的值 3. 被声明为 final 的常量等;</li>
<li><code>符号引用</code>包括：1. 类的全限定名，2. 字段名和属性，3. 方法名和属性。</li>
</ul>
</li>
<li>运行时常量池在哪：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cosmos-wong/p/12925299.html">https://www.cnblogs.com/cosmos-wong/p/12925299.html</a> 。总结：JDK6 时在方法区永久代中，JDK7 时在堆中</li>
</ul>
<blockquote>
<p>jvm 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，【jvm 就会将 class 常量池中的内容存放到运行时常量池中，运行时常量池存在于内存中，也就是 class 常量池被加载到内存之后的版本】，不同之处是：它的字面量可以动态的添加 (String#intern())，符号引用可以被解析为直接引用（里面的符号地址变为真实地址）。</p>
<p>运行时常量池是在类加载完成之后，将每个 class 常量池中的符号引用值转存到运行时常量池中，也就是说，【每个 class 都有一个运行时常量池】，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。解析的过程会去查询全局字符串池，也就是我们下面所说的 StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>
<p>运行时常量池相对于 CLass 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入运行时常量池中，这种特性被开发人员利用比较多的就是 String 类的 intern() 方法。</p>
</blockquote>
<ul>
<li>运行时常量池：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**1.8 以前会导致永久代内存溢出
 * 演示永久代内存溢出  java.lang.OutOfMemoryError: PermGen space
 * -XX:MaxPermSize&#x3D;8m
 *&#x2F;
public class Demo1_8 extends ClassLoader &#123;&#x2F;&#x2F;可以用来加载类的二进制字节码
    public static void main(String[] args) &#123;
        int j &#x3D; 0;
        try &#123;
            Demo1_8 test &#x3D; new Demo1_8();
            for (int i &#x3D; 0; i &lt; 20000; i++, j++) &#123;
                ClassWriter cw &#x3D; new ClassWriter(0);&#x2F;&#x2F;ClassWriter作用是生成类的二进制字节码
                cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java&#x2F;lang&#x2F;Object&quot;, null);&#x2F;&#x2F;参数：类版本号、类的访问修饰符、类的名字、包名类的父类、类要实现的接口
                byte[] code &#x3D; cw.toByteArray();&#x2F;&#x2F;返回byte数组
                test.defineClass(&quot;Class&quot; + i, code, 0, code.length);&#x2F;&#x2F;触发类的加载&#x2F;&#x2F;即生成了Class对象
            &#125;
        &#125; finally &#123;
            System.out.println(j);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**1.8之后会导致元空间内存溢出
 * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace 元空间
 * -XX:MaxMetaspaceSize&#x3D;8m
 *&#x2F;
public class Demo1_8 extends ClassLoader &#123; &#x2F;&#x2F; 可以用来加载类的二进制字节码
    public static void main(String[] args) &#123;
        int j &#x3D; 0;
        try &#123;
            Demo1_8 test &#x3D; new Demo1_8();
            for (int i &#x3D; 0; i &lt; 10000; i++, j++) &#123;
                &#x2F;&#x2F; ClassWriter 作用是生成类的二进制字节码
                ClassWriter cw &#x3D; new ClassWriter(0);
                &#x2F;&#x2F; 版本号， public， 类名, 包名, 父类， 接口
                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java&#x2F;lang&#x2F;Object&quot;, null);
                &#x2F;&#x2F; 返回 byte[]
                byte[] code &#x3D; cw.toByteArray();
                &#x2F;&#x2F; 执行了类的加载
                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); &#x2F;&#x2F; Class 对象
            &#125;
        &#125; finally &#123;
            System.out.println(j);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="字段信息"><a class="header-anchor" href="#字段信息">¶</a>字段信息</h5>
<ul>
<li>声明的顺序</li>
<li>修饰符</li>
<li>类型</li>
<li>名字</li>
</ul>
<h5 id="方法信息"><a class="header-anchor" href="#方法信息">¶</a>方法信息</h5>
<ul>
<li>声明的顺序</li>
<li>修饰符</li>
<li>返回值类型</li>
<li>名字</li>
<li>参数列表（有序保存）</li>
<li>异常表（方法抛出的异常）</li>
<li>方法字节码（native、abstract 方法除外，）</li>
<li>操作数栈和局部变量表大小</li>
</ul>
<h5 id="类变量-即-static-变量）"><a class="header-anchor" href="#类变量-即-static-变量）">¶</a>类变量 (即 static 变量）</h5>
<p>非 final 类变量</p>
<p>在 java 虚拟机使用一个类之前，它必须在方法区中为每个非 final 类变量分配空间。非 final 类变量存储在定义它的类中；</p>
<p>final 类变量（不存储在这里）</p>
<p>由于 final 的不可改变性，因此，final 类变量的值在编译期间，就被确定了，因此被保存在类的常量池里面，然后在加载类的时候，复制进方法区的运行时常量池里面 ；final 类变量存储在运行时常量池里面，每一个使用它的类保存着一个对其的引用；</p>
<h5 id="对类加载器的引用"><a class="header-anchor" href="#对类加载器的引用">¶</a>对类加载器的引用</h5>
<p>jvm 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 jvm 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</p>
<h5 id="对-Class-类的引用"><a class="header-anchor" href="#对-Class-类的引用">¶</a>对 Class 类的引用</h5>
<p>jvm 为每个加载的类都创建一个 java.lang.Class 的实例（<strong>存储在堆上</strong>）。而 jvm 必须以某种方式把 Class 的这个实例和存储在方法区中的类型数据（<strong>类的元数据</strong>）联系起来， 因此，类的元数据里面保存了一个 Class 对象的引用；</p>
<h5 id="方法表"><a class="header-anchor" href="#方法表">¶</a>方法表</h5>
<p>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，jvm 的实现者还可以添加一些其他的数据结构，如方法表。jvm 对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用 (包括从父类继承的方法。jvm 可以通过方法表快速激活实例方法。(译者：这里的方法表与 C++ 中的虚拟函数表一样，但 java 方法全都 是 virtual 的，自然也不用虚拟二字了。正像 java 宣称没有 指针了，其实 java 里全是指针。更安全只是加了更完备的检查机制，但这都是以牺牲效率为代价的, 个人认为 java 的设计者 始终是把安全放在效率之上的，所有 java 才更适合于网络开发)</p>
<h5 id="字符串对象-intern"><a class="header-anchor" href="#字符串对象-intern">¶</a><code>字符串对象.intern()</code></h5>
<ul>
<li>作用：将指定字符串尝试放入<code>StringTable</code></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">此外String对象调用intern()方法时，会先在StringTable中查找是否存在于该对象相同的字符串，若存在直接返回String table中字符串的引用，若不存在则在StringTable中创建一个与该对象相同的字符串。


String s1 &#x3D; &quot;ma&quot;;
String s2 &#x3D; &quot;in&quot;;
String s3 &#x3D; s1 +s2;&#x2F;&#x2F;实际上指向的是堆
s3.intern();&#x2F;&#x2F;main String，java等属于关键词，在一开始就在StringTable中存在了，所以s3.intern没能插入进去。
String s4 &#x3D; &quot;ma&quot; + &quot;in&quot;;
System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>javap -v hello.class</p>
<ul>
<li>v 显示反编译后的详细信息</li>
</ul>
<p>常量池中的字符串仅是符号，第一次用到时才变为对象。利用串池的机制，来避免重复创建字符串对象</p>
<h6 id="字符串常量池"><a class="header-anchor" href="#字符串常量池">¶</a>字符串常量池</h6>
<p>字符串常量池在方法区中，1.8 中使用原空间代替永久代来实现方法区，但方法区并没有改变。改变的是方法去中内容的物理存放位置。类信息被移动到元空间中，但运行时常量池和字符串常量池被移动到了堆中。但是不论他们物理上如何存放，逻辑上还是属于方法区的。</p>
<blockquote>
<p>调用 str1.intern()</p>
<ul>
<li>如果常量池中已经有了该字符串 str1，那直接返回常量池中 str1 的引用。（注意返回的跟去时候的可能没有关系）</li>
<li>如果常量池中没有该字符串 str1，
<ul>
<li>JDK6 会把字符串复制到常量池中，相当于常量池中是一个副本 str2，并且<strong>返回的是该副本的引用 str2</strong>，而该字符串 str1 还是指向堆中；</li>
<li>JDK7 会把堆中字符串 str1 的<strong>引用写到常量池中 str1</strong>，而不是复制，当新的变量被赋值该字符串 str1 时，直接指向的是该引用 str1。如果原来就有同样的内容了，就返回原来内容我引用</li>
</ul>
</li>
</ul>
</blockquote>
<p>一、<code>new String</code>都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable 维护），并返回指向该常量的引用。<br>
<img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203247146" alt="" loading="lazy"><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203303115" alt="" loading="lazy"></p>
<pre class="line-numbers language-none"><code class="language-none">String s &#x3D; new String(&quot;abc&quot;);&#x2F;&#x2F;字符串常量池中有abc,堆中也有
String s1 &#x3D; &quot;abc&quot;;
String s2 &#x3D; new String(&quot;abc&quot;);
System.out.println(s &#x3D;&#x3D; s1.intern());&#x2F;&#x2F;false
System.out.println(s &#x3D;&#x3D; s2.intern());&#x2F;&#x2F;false
System.out.println(s1 &#x3D;&#x3D; s.intern());&#x2F;&#x2F;true &#x2F;&#x2F;intern返回的是并不是s了，而是常量池中的s1了
System.out.println(s1 &#x3D;&#x3D; s2.intern());&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>二、<strong>通过字面量赋值创建字符串</strong>（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203323021" class="" loading="lazy">
<p>三、常量字符串的 “+” 操作，编译阶段直接会合成为一个字符串。如 string str=“JA”+“VA”，在编译阶段会直接合并成语句 String str=“JAVA”，于是会去常量池中查找是否存在”JAVA”, 从而进行创建或引用。</p>
<p>四、对于 final 字段，编译期直接进行了常量替换（而对于非 final 字段则是在运行期进行赋值处理的）。</p>
<pre class="line-numbers language-none"><code class="language-none">String s1 &#x3D; &quot;bc&quot;;
final String s2 &#x3D; &quot;b&quot;;&#x2F;&#x2F;注意是final，即是常量
final String s3 &#x3D; &quot;c&quot;;
String s4 &#x3D; s2 + s3;&#x2F;&#x2F; 在编译时，直接替换成了String s4&#x3D;&quot;b&quot;+&quot;c&quot;，根据第三条规则，再次替换成String s4&#x3D;&quot;bc&quot;
&#x2F;&#x2F; 常量的时候编译后就是符号，可以理解为不是变量
System.out.println(s1 &#x3D;&#x3D; s4);&#x2F;&#x2F;true,因为final变量在编译后会直接替换成对应的值，所以实际上等于s4&#x3D;&quot;b&quot;+&quot;c&quot;，而这种情况下，编译器会直接合并为s4&#x3D;&quot;bc&quot;，所以最终s1&#x3D;&#x3D;s4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>五、常量字符串和变量拼接时（如：<code>String str3=baseStr + &quot;01&quot;;</code>）会调用 ==<code>stringBuilder.append()</code>在堆上创建新的对象 ==。</p>
<p>六、JDK 1.7 后，intern 方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，</p>
<p>区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7 后则是将在堆上的地址引用复制到常量池。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20170412203343662" class="" loading="lazy">
<p>举例说明：</p>
<pre class="line-numbers language-none"><code class="language-none">String str2 &#x3D; new String(&quot;str&quot;)+new String(&quot;01&quot;);
str2.intern();&#x2F;&#x2F;JDK6：复制一份，返回该副本引用，但str2还是指向堆中的。JDK7：在常量池中生成一个引用指向堆中。

String str1 &#x3D; &quot;str01&quot;;&#x2F;&#x2F;JDK6：常量池中的副本。JDK7：这个引用从字符串常量池中指向堆中
System.out.println(str2&#x3D;&#x3D;str1);&#x2F;&#x2F;JDK6：false。JDK7：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 JDK 1.7 下，当执行 str2.intern(); 时，因为常量池中没有 “str01” 这个字符串，所以会在常量池中生成一个对堆中的 “str01” 的<strong>引用</strong> (注意这里是引用 ，就是这个区别于 JDK 1.6 的地方。在 JDK1.6 下是生成原字符串的拷贝)，而在进行 String str1 = “str01”; 字面量赋值的时候，常量池中已经存在一个引用，所以直接返回了该引用，因此 str1 和 str2 都指向堆中的同一个字符串，返回 true。</p>
<pre class="line-numbers language-none"><code class="language-none">String str2 &#x3D; new String(&quot;str&quot;)+new String(&quot;01&quot;);&#x2F;&#x2F;JDK6：堆&#x2F;&#x2F;JDK7:堆
String str1 &#x3D; &quot;str01&quot;;&#x2F;&#x2F;JDK6: 常量池&#x2F;&#x2F;JDK7：常量池

str2.intern();&#x2F;&#x2F;JDK6：尝试复制，常量池已经有了，没有复制，返回了常量池中的引用，但str2还是指向堆中的&#x2F;&#x2F;JDK7：尝试提供堆中的引用给常量池，常量池已经有自己的了，无需引用堆中你的了
System.out.println(str2&#x3D;&#x3D;str1);&#x2F;&#x2F;JDK6：false&#x2F;&#x2F;JDK7：false&#x2F;&#x2F;都是堆中一份，常量池中一份<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将中间两行调换位置以后，因为在进行字面量赋值（String str1 = “str01″）的时候，常量池中不存在，所以 str1 指向的常量池中的位置，而 str2 指向的是堆中的对象，再进行 intern 方法时，对 str1 和 str2 已经没有影响了，所以返回 false。</p>
<pre class="line-numbers language-none"><code class="language-none">String s &#x3D; new String(&quot;1&quot;);&#x2F;&#x2F;堆中，同时常量池中也有1了
s.intern();&#x2F;&#x2F; JDK6，复制，复制失败 &#x2F;&#x2F;JDK7：常量池中已经有了，无需复制
String s2 &#x3D; &quot;1&quot;;
System.out.println(s &#x3D;&#x3D; s2);&#x2F;&#x2F; JDK6和7都是false

String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);&#x2F;&#x2F;堆中有11，常量池中没有11
s3.intern();&#x2F;&#x2F;JDK6复制成功&#x2F;&#x2F;JDK7引用成功
String s4 &#x3D; &quot;11&quot;;

System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;JDK6：false  JDK7：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再分别调整上面代码 2.3 行、7.8 行的顺序：</p>
<pre class="line-numbers language-none"><code class="language-none">String s &#x3D; new String(&quot;1&quot;);&#x2F;&#x2F;堆中，同时常量池中也有1了
String s2 &#x3D; &quot;1&quot;;&#x2F;&#x2F;指向上一句在常量池中创建好的常量，但不是堆中的常量
s.intern();

System.out.println(s &#x3D;&#x3D; s2);&#x2F;&#x2F;JDK6:false  JDK7:false

 
String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);&#x2F;&#x2F;堆中有11，常量池中没有11
String s4 &#x3D; &quot;11&quot;;&#x2F;&#x2F;常量池中也自己的有11了
s3.intern();&#x2F;&#x2F;JDK6复制失败&#x2F;&#x2F;JDK7引用失败

System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;JDK6:false  JDK7:false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="字符串常量池的位置"><a class="header-anchor" href="#字符串常量池的位置">¶</a>字符串常量池的位置</h5>
<ul>
<li>JDK6：StringTable 在方法区。</li>
<li>JDK8：StringTable 在堆区</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;运行如下代码探究常量池的位置  
public static void main(String[] args) throws Throwable &#123;  
    List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();  
    int i&#x3D;0;  
    while(true)&#123;  
        list.add(String.valueOf(i++).intern());  
    &#125;  
&#125;  
&#x2F;*
用jdk1.6运行后会报错，永久代这个区域内存溢出会报：
Exception in thread “main” java.lang.OutOfMemoryError:PermGen space的内存溢出异常，表示永久代内存溢出。
jdk1.7 和1.8Exception in thread “main” java.lang.OutOfMemoryError: Java heap space说明1.6在永久带，1.7以后移动到了heap中
98%的垃圾回收，但只有2%的堆被重置
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="串常量垃圾回收"><a class="header-anchor" href="#串常量垃圾回收">¶</a>串常量垃圾回收</h5>
<pre class="line-numbers language-none"><code class="language-none">package JVMtest;
&#x2F;*
* 演示stringTable垃圾回收
* -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc
* 打印字符串表的统计信息
* 打印垃圾回收的详细信息
* *&#x2F;
public class StringTable &#123;
    public static void main(String[] args) &#123;
        int i&#x3D;0;
        try &#123;
            for(int j&#x3D;0;j&lt;100;j++)&#123;&#x2F;&#x2F;ctrl+alt+t快捷键try catch
                String.valueOf(j).intern();&#x2F;&#x2F;这句话注释与打开
                i++;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;输出信息如下：

Heap&#x2F;&#x2F;堆
 PSYoungGen      total 2560K, used 1644K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 2048K, 80% used [0x00000000ffd00000,0x00000000ffe9b3f0,0x00000000fff00000)
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
 ParOldGen       total 7168K, used 0K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffd00000)
 Metaspace       used 3144K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 343K, capacity 388K, committed 512K, reserved 1048576K
SymbolTable statistics:&#x2F;&#x2F;符号表
Number of buckets       :     20011 &#x3D;    160088 bytes, avg   8.000
Number of entries       :     13114 &#x3D;    314736 bytes, avg  24.000
Number of literals      :     13114 &#x3D;    562744 bytes, avg  42.912
Total footprint         :           &#x3D;   1037568 bytes
Average bucket size     :     0.655
Variance of bucket size :     0.655
Std. dev. of bucket size:     0.810
Maximum bucket size     :         6
StringTable statistics:&#x2F;&#x2F;串常量分析
Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000&#x2F;&#x2F;桶个数60013
Number of entries       :      1839 &#x3D;     44136 bytes, avg  24.000&#x2F;&#x2F;键值对个数1839
Number of literals      :      1839 &#x3D;    161288 bytes, avg  87.704&#x2F;&#x2F;字符串常量个数&#x2F;&#x2F;什么都没做就有1000+了&#x2F;&#x2F;注释了for之后显示1739
Total footprint         :           &#x3D;    685528 bytes
Average bucket size     :     0.031
Variance of bucket size :     0.031
Std. dev. of bucket size:     0.175
Maximum bucket size     :         3

Process finished with exit code 0

&#x2F;&#x2F;for改为10000后，&#x2F;&#x2F;字符串常量并没有变为10000多个，而是满了之后就垃圾回收了。证明了StringTable也会发生垃圾回收
[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;636K(9728K), 0.0012292 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] 
StringTable statistics:
Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000
Number of entries       :      3174 &#x3D;     76176 bytes, avg  24.000
Number of literals      :      3174 &#x3D;    225688 bytes, avg  71.105
Total footprint         :           &#x3D;    781968 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="串常量池性能调优"><a class="header-anchor" href="#串常量池性能调优">¶</a>串常量池性能调优</h5>
<ul>
<li>调整：<code>XX:+StringTableSize=桶个数</code>。将 StringTable 中的桶个数设为 2000。 hash 表桶的数量越多（数组部分长度越长），数据越分散，hashcode 撞车的概率越小，速度越快。 默认值是 6 万多</li>
<li>考虑将字符串对象是否入池</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">-Xms500m 设置堆内存为500mb
    -Xmx500m -XX:+PrintStringTableStatistics -XX:+StringTableSize&#x3D;20000
    限制了桶大小为2W。
    变慢了
    往StringTable里放一个字符串，就要去哈希表里查找有没有。有就不能放进去。
 public static void main(String[] args) &#123;
        try &#123;
            BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(new File(&quot;f:\\test.txt&quot;))));
            String line &#x3D; null;
            long start &#x3D; System.nanoTime();
            while (true) &#123;
                line &#x3D; reader.readLine();
                if (line &#x3D;&#x3D; null) &#123;
                    break;
                &#125;
                line.intern();
            &#125;
            System.out.println(&quot;cost:&quot; + (System.nanoTime() - start) &#x2F; 1000000);
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#x2F;&#x2F;通过读取文件将文件中的每一行逐行加入到StringTable中,修改桶的大小来测试所需要的时间（文件为8145行）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<table><thead><tr><th><code>StringTableSize</code></th><th>Time</th></tr></thead><tbody><tr><td>128</td><td>172 ms</td></tr><tr><td>1024</td><td>116 ms</td></tr><tr><td>4096</td><td>87 ms</td></tr></tbody></table>
<h5 id="JDK6"><a class="header-anchor" href="#JDK6">¶</a>JDK6</h5>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160823154637228" class="" loading="lazy">
<p>在 JDK1.6 中所有的输出结果都是 false，因为 JDK1.6 以及以前版本中，常量池是放在 Perm 区（属于方法区）中的，熟悉 JVM 的话应该知道这是和堆区完全分开的。</p>
<p>使用引号声明的字符串都是会直接在字符串常量池中生成的，而 new 出来的 String 对象是放在堆空间中的。所以两者的内存地址肯定是不相同的，即使调用了 intern() 方法也是不影响的。</p>
<p>intern() 方法在 JDK1.6 中的作用是：比如 String s = new String(“SEU_Calvin”)，再调用 s.intern()，此时返回值还是字符串 “SEU_Calvin”，表面上看起来好像这个方法没什么用处。但实际上，在 JDK1.6 中它做了个小动作：检查字符串池里是否存在 “SEU_Calvin” 这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会把 “SEU_Calvin” 添加到字符串池中，然后再返回它的引用。然而在 JDK1.7 中却不是这样的，后面会讨论。</p>
<h5 id="JDK7"><a class="header-anchor" href="#JDK7">¶</a>JDK7</h5>
<p>针对 JDK1.7 以及以上的版本，我们将上面两段代码分开讨论。先看第一段代码的情况：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160823155446893" class="" loading="lazy">**
<pre class="line-numbers language-none"><code class="language-none">String s &#x3D; new String(&quot;1&quot;);&#x2F;&#x2F;生成了常量池中的“1” 和堆空间中的字符串对象
s.intern();&#x2F;&#x2F; s对象去常量池中寻找后发现&quot;1&quot;已经存在于常量池中了。
String s2 &#x3D; &quot;1&quot;;&#x2F;&#x2F;生成一个s2的引用指向常量池中的“1”对象。
System.out.println(s &#x3D;&#x3D; s2);&#x2F;&#x2F; JDK6和7都是false

String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);&#x2F;&#x2F;在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为&quot;11&quot;）。注意此时常量池中是没有 “11”对象的。
s3.intern();&#x2F;&#x2F;将 s3中的“11”字符串放入 String 常量池中，此时常量池中不存在“11”字符串，JDK1.6的做法是直接在常量池中生成一个 &quot;11&quot; 的对象。
&#x2F;&#x2F;但是在JDK1.7中，常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用直接指向 s3 引用的对象，也就是说s3.intern() &#x3D;&#x3D;s3会返回true。
String s4 &#x3D; &quot;11&quot;;&#x2F;&#x2F;直接去常量池中创建，但是发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。因此s3 &#x3D;&#x3D; s4返回了true。

System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;JDK6：false  JDK7：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面继续分析第二段代码：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20160823161625964" class="" loading="lazy">
<p>再把第二段代码贴一下便于查看：</p>
<pre class="line-numbers language-none"><code class="language-none">String s &#x3D; new String(&quot;1&quot;);&#x2F;&#x2F;生成了常量池中的“1” 和堆空间中的字符串对象。
String s2 &#x3D; &quot;1&quot;;&#x2F;&#x2F;这行代码是生成一个s2的引用指向常量池中的“1”对象，但是发现已经存在了，那么就直接指向了它。
s.intern();&#x2F;&#x2F;这一行在这里就没什么实际作用了。因为&quot;1&quot;已经存在了。

System.out.println(s &#x3D;&#x3D; s2);&#x2F;&#x2F; 引用地址不同&#x2F;&#x2F;JDK6:false  JDK7:false

 
String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);&#x2F;&#x2F;在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为&quot;11&quot;）。注意此时常量池中是没有 “11”对象的。
String s4 &#x3D; &quot;11&quot;;&#x2F;&#x2F;直接去生成常量池中的&quot;11&quot;。
s3.intern();&#x2F;&#x2F;这一行在这里就没什么实际作用了。因为&quot;11&quot;已经存在了。

System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;引用地址不同&#x2F;&#x2F;JDK6:false  JDK7:false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">String str1 &#x3D; new String(&quot;SEU&quot;) + new String(&quot;Calvin&quot;);

System.out.println(str1.intern() &#x3D;&#x3D; str1);&#x2F;&#x2F;JDK6:false&#x2F;&#x2F;JDK7：true

System.out.println(str1 &#x3D;&#x3D; &quot;SEUCalvin&quot;);&#x2F;&#x2F;JDK6：false&#x2F;&#x2F;JDK7：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">String str2 &#x3D; &quot;SEUCalvin&quot;;&#x2F;&#x2F;新加的一行代码，其余不变

String str1 &#x3D; new String(&quot;SEU&quot;)+ new String(&quot;Calvin&quot;);

System.out.println(str1.intern() &#x3D;&#x3D; str1);&#x2F;&#x2F;JDK6:false&#x2F;&#x2F;JDK7:false

System.out.println(str1 &#x3D;&#x3D; &quot;SEUCalvin&quot;);&#x2F;&#x2F;JDK6：false&#x2F;&#x2F;JDK7:false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也很简单啦，str2 先在常量池中创建了 “SEUCalvin”，那么 str1.intern() 当然就直接指向了 str2，你可以去验证它们两个是返回的 true。后面的 “SEUCalvin” 也一样指向 str2。所以谁都不搭理在堆空间中的 str1 了，所以都返回了 false。</p>
<h1>new String() 究竟创建几个对象?</h1>
<ol>
<li>由来</li>
</ol>
<hr>
<p>遇到一个 Java 面试题，是关于<code>String</code>的，自己对<code>String</code>还有点研究？下面是题目的描述：</p>
<blockquote>
<p>在 Java 中，<code>new String(&quot;hello&quot;)</code>这样的创建方式，到底创建了几个<code>String</code>对象？</p>
</blockquote>
<p>题目下答案，各说纷纭，有说 1 个的，有说 2 个的。我觉得都对，但也都不对，因为要加上一定的条件，下面来分析下！</p>
<ol start="2">
<li>解答</li>
</ol>
<hr>
<h3 id="2-1-分析"><a class="header-anchor" href="#2-1-分析">¶</a>2.1. 分析</h3>
<p>题目中的<code>String</code>创建方式，是调用<code>String</code>的有参构造函数，而这个有参构造函数的源码则是这样的<code>public String(String original)</code>，这就是说，我们可以把代码转换为下面这种：</p>
<pre class="line-numbers language-none"><code class="language-none">String temp &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; 在常量池中
String str &#x3D; new String(temp); &#x2F;&#x2F; 在堆上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这段代码就创建了 2 个<code>String</code>对象，<code>temp</code>指向在常量池中的，<code>str</code>指向堆上的，而<code>str</code>内部的<code>char value[]</code>则指向常量池中的<code>char value[]</code>，所以这里的答案是 2 个对象。(这里不再详述内部过程，之前的文章有写，参考<a target="_blank" rel="noopener" href="https://kevinsss.github.io/blog/2016/11/10/shen-ru-qian-chu-java-string-shang/">深入浅出 Java String</a>)</p>
<p>那之前我为什么说答案是 1 个的也对呢，假如就只有这一句<code>String str = new String(&quot;hello&quot;)</code>代码，并且此时的常量池的没有<code>&quot;hello&quot;</code>这个 String，那么答案是两个; 如果此时常量池中，已经存在了<code>&quot;hello&quot;</code>，那么此时就只创建堆上<code>str</code>，而不会创建常量池中<code>temp</code>,(注意这里都是引用)，所以此时答案就是 1 个。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w605283073/article/details/72753494">https://blog.csdn.net/w605283073/article/details/72753494</a></p>
<p>《深入理解 java 虚拟机》第二版 57 页</p>
<p>对 String.intern() 返回引用的测试代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">String str1 &#x3D; new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();
&#x2F;&#x2F; String str3&#x3D; new StringBuilder(&quot;计算机软件&quot;).toString();
System.out.println(str1.intern() &#x3D;&#x3D; str1);&#x2F;&#x2F;JDK6:false&#x2F;&#x2F;JDK7:true

String str2 &#x3D; new StringBuilder(&quot;Java(TM) SE &quot;).append(&quot;Runtime Environment&quot;).toString();
;&#x2F;&#x2F;堆中有，问题是常量池中在intern之前是否有拼接完的字符串
System.out.println(str2.intern() &#x3D;&#x3D; str2);&#x2F;&#x2F;JDK6:false&#x2F;&#x2F;JDK7:false
&#x2F;&#x2F;jdk6因为是复制，所以不可能相等，问题是jdk7可能是引用，按理说应该是true，为什么是false
&#x2F;&#x2F;这个因为jdk源码中已经有了这个拼接完的字符串，在标注版本的时候定义过了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可能很多人觉得这个结果很奇怪，在这里我们进行深入地探究。</p>
<p>因为 JDK1.6 中，intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串的实例的引用，而 StringBulder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false。</p>
<p>在 JDK1.7 中，intern() 的实现不会在复制实例，只是在常量池中记录首次出现的实例引用，因此返回的是引用和由 StringBuilder.toString() 创建的那个字符串实例是同一个。</p>
<p>str2 的比较返回 false 因为 “java” 这个字符串在执行 StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合 “首次出现” 的原则，而 “计算机软件” 这个字符串是首次出现，因此返回 true。</p>
<p>那么就有疑问了，这个 “java” 字符串在哪里出现过呢？显然并不是直接出现在这个类里面。</p>
<p>我们分别打开 String 、StringBuilder 和 System 类的源码看看有啥发现，</p>
<p>其中在 <strong>System 类里</strong>发现</p>
<p>有 java 版本的字符串</p>
<p>因此 sun.misc.Version 类会在 JDK 类库的初始化过程中被加载并初始化，而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化，此时被 sun.misc.Version.launcher 静态常量字段所引用的 “java” 字符串字面量就被 intern 到 HotSpot VM 的字符串常量池——StringTable 里了。</p>
<p>因此我们修改一下代码：</p>
<ol>
<li><code>String str2 = new StringBuilder(&quot;Java(TM) SE &quot;).append(&quot;Runtime Environment&quot;).toString();</code></li>
<li><code>System.out.println(str2.intern() == str2)</code></li>
</ol>
<p>发现结果还是 false</p>
<p>从而更加证实了我们的猜测。</p>
<p>再遇到类似问题的时候，希望大家可以多从源码角度去追本溯源，能够多分享出来。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clamp7724/p/11751278.html">https://www.cnblogs.com/clamp7724/p/11751278.html</a></p>
<p>字符串常量池：String table 又称为 String pool，</p>
<ul>
<li>字符串常量池在 Java 内存区域的哪个位置
<ul>
<li>在 JDK6.0 及之前版本，字符串常量池是放在【Perm Gen 区 (也就是方法区)】中；</li>
<li>在 JDK7.0 版本，字符串常量池被移到了【堆】中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。但是字符串常量池与堆对象还是不一样</li>
</ul>
</li>
<li>字符串常量池放的是什么：
<ul>
<li>在 JDK6.0 及之前版本中，String Pool 里放的都是字符串常量</li>
<li>在 JDK7.0 中，由于 String#intern() 发生了改变，因此 String Pool 中也可以存放放于堆内的字符串对象的引用</li>
</ul>
</li>
<li>StringTable 还存在一个 hash 表的特性∶里面不存在相同的两个字符串。</li>
<li>main String，java 等属于关键词，在一开始就在 StringTable 中存在了，所以 str.intern 没能插入进去。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">String s1 &#x3D; &quot;ha&quot;;
String s2 &#x3D; &quot;ha&quot;;
String s3 &#x3D; s1 +s2;&#x2F;&#x2F;s3本质调用了 new StringBuilder.append(&quot;a&quot;).append(&quot;b&quot;).toString(); 声明了新的引用变量，开辟了新的空间，所以指向的是堆中的对象地址而不是StringTable中的字符串了。
String s4 &#x3D; &quot;ha&quot; + &quot;ha&quot;;&#x2F;&#x2F;因为是两个常量拼接，在编译时就会直接变成&quot;haha&quot;进行处理，进入StringTable
String s5 &#x3D; &quot;haha&quot;;&#x2F;&#x2F;因为也是常量，会先在StringTable中查找，找到后s5指向了StringTable中的&quot;haha&quot;
String s6 &#x3D; new String(&quot;haha&quot;);
System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;false
System.out.println(s4 &#x3D;&#x3D; s5);&#x2F;&#x2F;true
System.out.println(s5 &#x3D;&#x3D; s6);&#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-6-直接内存"><a class="header-anchor" href="#3-6-直接内存">¶</a>3.6_直接内存</h4>
<p>在 JAVA 中，JVM 内存指的是堆内存。</p>
<p>机器内存中，不属于堆内存的部分即为堆外内存。</p>
<p>堆外内存也被称为直接内存。</p>
<p>内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。使用未公开的 Unsafe 和 NIO 包下 ByteBuffer 来创建堆外内存。</p>
<p>堆内内存是属于 jvm 的，由 jvm 进行分配和管理，属于 “用户态”，而堆外内存是由操作系统管理的，属于 “内核态”。</p>
<p>在 jdk1.4 中新加入了 NIO 类，他可以调用 native 函数库直接分配堆外内存，然后通过 java 堆中的 DirectByteBuffer 对象来指向这块内存，进行内存分配等工作。</p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output)类，引入了一种基于通道 (Channel) 与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>JAVA 通过调用 ByteBuffer.allocateDirect 及 MappedByteBuffer 来进行内存分配。不过 JVM 对 Direct Memory 可申请的大小也有限制，可用 - XX:MaxDirectMemorySize=1M 设置，这部分内存不受 JVM 垃圾回收管理。</p>
<ul>
<li>堆外内存：Direct Memory，也叫堆外内存。这部分内存不是由 jvm 管理和回收的。需要我们手动的回收。</li>
<li>常见于 NIO 操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受 JVM 内存回收管理</li>
</ul>
<p>为什么使用堆外内存：</p>
<ul>
<li>1、减少了垃圾回收：使用堆外内存的话，堆外内存是直接受操作系统管理 (而不是虚拟机)。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li>
<li>2、提升复制速度 (io 效率)：堆内内存由 JVM 管理，属于 “用户态”；而堆外内存由 OS 管理，属于 “内核态”。如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由 OS 写入磁盘，使用堆外内存避免了这个操作。（不需要经过对内）</li>
</ul>
<p>堆外内存申请：</p>
<ul>
<li>JDK 的<code>ByteBuffer</code>类提供了一个接口<code>allocateDirect(int capacity)</code>进行堆外内存的申请，底层通过<code>unsafe.allocateMemory(size)</code>实现。Netty、Mina 等框架提供的接口也是基于 ByteBuffer 封装的。</li>
</ul>
<p>堆外内存释放：</p>
<ul>
<li><code>unsafe.allocateMemory(size)</code>最底层是通过<code>malloc</code>方法申请的，但是这块内存需要进行手动释放，JVM 并不会进行回收，幸好<code>Unsafe</code>提供了另一个接口<code>freeMemory</code>可以对申请的堆外内存进行释放。</li>
</ul>
<p>当初始化一块堆外内存时，对象的引用关系如下：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a28.png" class="" loading="lazy">
<p>《JAVA 对象引用》叫告诉了我们有 ReferenceQueue 引用监视器。</p>
<p>当一个 DirectByteBuffer 初始化的时候，都会创建 cleaner 对象（ 继承 PhantomReference）并把 其注册进 ReferenceQueue 中。</p>
<p>当 DirectByteBuffer=null 的时候，如果引用在放入 PhantomReference 过程中，JVM 就会调用 cleaner.clean 并放弃通知 ReferenceQueue。</p>
<p>其中<code>first</code>是<code>Cleaner</code>类的静态变量，<code>Cleaner</code>对象在初始化时会被添加到<code>Clenear</code>链表中，和<code>first</code>形成引用关系，<code>ReferenceQueue</code>是用来保存需要回收的<code>Cleaner</code>对象。</p>
<p>如果该<code>DirectByteBuffer</code>对象在一次 GC 中被回收了</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a29.png" class="" loading="lazy">
<p>此时，只有<code>Cleaner</code>对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次 FGC 时，把该<code>Cleaner</code>对象放入到<code>ReferenceQueue</code>中，并触发<code>clean</code>方法。</p>
<p><code>Cleaner</code>对象的<code>clean</code>方法主要有两个作用：<br>
1、把自身从<code>Cleaner</code>链表删除，从而在下次 GC 时能够被回收<br>
2、释放堆外内存</p>
<p>如果 JVM 一直没有执行 FGC 的话，无效的<code>Cleaner</code>对象就无法放入到 ReferenceQueue 中，从而堆外内存也一直得不到释放，内存岂不是会爆？</p>
<p>其实在初始化<code>DirectByteBuffer</code>对象时，如果当前堆外内存的条件很苛刻时，会主动调用<code>System.gc()</code>强制执行 FGC。</p>
<h3 id="Unsafe-类操作堆外内存"><a class="header-anchor" href="#Unsafe-类操作堆外内存">¶</a>Unsafe 类操作堆外内存</h3>
<p>sun.misc.Unsafe 提供了一组方法来进行堆外内存的分配，重新分配，以及释放。</p>
<ol>
<li>public native long allocateMemory(long size); —— 分配一块内存空间。</li>
<li>public native long reallocateMemory(long address, long size); —— 重新分配一块内存，把数据从 address 指向的缓存中拷贝到新的内存块。</li>
<li>public native void freeMemory(long address); —— 释放内存。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=http%3A%2F%2Fwww.360doc.com%2Fcontent%2F15%2F0213%2F18%2F11962419_448404856.shtml">Unsafe 类操作 JAVA 内存</a></p>
<pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;
    Unsafe unsafe &#x3D; new Unsafe();
    unsafe.allocateMemory(1024);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而 Unsafe 类的构造器是私有的，报错。</p>
<p>而且，allocateMemory 方法也不是静态的，不能通过 Unsafe.allocateMemory 调用。</p>
<p>幸运的是可以通过 Unsafe.getUnsafe() 取得 Unsafe 的实例。</p>
<pre class="line-numbers language-none"><code class="language-none">public class UnsafeTest &#123;

    public static void main(String[] args) &#123;
        Unsafe unsafe &#x3D; Unsafe.getUnsafe();
        unsafe.allocateMemory(1024);
        unsafe.reallocateMemory(1024, 1024);
        unsafe.freeMemory(1024);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，也可以通过反射获取 unsafe 对象实例</p>
<p>参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=http%3A%2F%2Fwww.importnew.com%2F7844.html">危险代码：如何使用 Unsafe 操作内存中的 Java 类和对象</a></p>
<h3 id="NIO-类操作堆外内存"><a class="header-anchor" href="#NIO-类操作堆外内存">¶</a>NIO 类操作堆外内存</h3>
<p>用 NIO 包下的 ByteBuffer 分配直接内存则相对简单。</p>
<pre class="line-numbers language-none"><code class="language-none">public class TestDirectByteBuffer &#123;
    public static void main(String[] args) throws Exception &#123;
        ByteBuffer buffer &#x3D; ByteBuffer.allocateDirect(10 * 1024 * 1024);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而运行时报错了。</p>
<blockquote>
<p>java(51146,0x7000023ed000) malloc: *** error for object 0x400: pointer being realloc’d was not allocated<br>
*** set a breakpoint in malloc_error_break to debug</p>
</blockquote>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a23.png" class="" loading="lazy">
<p>错误信息</p>
<p>参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fmoonandstar08%2Fp%2F5107648.html">JAVA 堆外内存</a></p>
<p>然而在小伙伴的电脑上跑这段的代码是可以成功运行的。</p>
<h4 id="二：堆外内存垃圾回收"><a class="header-anchor" href="#二：堆外内存垃圾回收">¶</a>二：堆外内存垃圾回收</h4>
<p>对于内存，除了关注怎么分配，还需要关注如何释放。</p>
<p>从 JAVA 出发，习惯性思维是堆外内存是否有垃圾回收机制。</p>
<p>考虑堆外内存的垃圾回收机制，需要了解以下两个问题：</p>
<ol>
<li>堆外内存会溢出么？</li>
<li>什么时候会触发堆外内存回收？</li>
</ol>
<p>问题一</p>
<p>通过修改 JVM 参数：-XX:MaxDirectMemorySize=40M，将最大堆外内存设置为 40M。</p>
<p>既然堆外内存有限，则必然会发生内存溢出。</p>
<p>为模拟内存溢出，可以设置 JVM 参数：-XX:+DisableExplicitGC，禁止代码中显式调用 System.gc()。</p>
<p>可以看到出现 OOM。</p>
<p>得到的结论是，堆外内存会溢出，并且其垃圾回收依赖于代码显式调用 System.gc()。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fmoonandstar08%2Fp%2F5107648.html">JAVA 堆外内存</a></p>
<p>问题二</p>
<p>关于堆外内存垃圾回收的时机，首先考虑堆外内存的分配过程。</p>
<p>JVM 在堆内只保存堆外内存的引用，用 DirectByteBuffer 对象来表示。</p>
<p>每个 DirectByteBuffer 对象在初始化时，都会创建一个对应的 Cleaner 对象。</p>
<p>这个 Cleaner 对象会在合适的时候执行 unsafe.freeMemory(address)，从而回收这块堆外内存。</p>
<p>当 DirectByteBuffer 对象在某次 YGC 中被回收，只有 Cleaner 对象知道堆外内存的地址。</p>
<p>当下一次 FGC 执行时，Cleaner 对象会将自身 Cleaner 链表上删除，并触发 clean 方法清理堆外内存。</p>
<p>此时，堆外内存将被回收，Cleaner 对象也将在下次 YGC 时被回收。</p>
<p>如果 JVM 一直没有执行 FGC 的话，无法触发 Cleaner 对象执行 clean 方法，从而堆外内存也一直得不到释放。</p>
<p>其实，在 ByteBuffer.allocateDirect 方式中，会主动调用 System.gc() 强制执行 FGC。</p>
<p>JVM 觉得有需要时，就会真正执行 GC 操作。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a24.png" class="" loading="lazy">
<p>显式调用</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/35cf0f348275">堆外内存的回收机制分析—占小狼</a></p>
<h4 id="三：为什么用堆外内存？"><a class="header-anchor" href="#三：为什么用堆外内存？">¶</a>三：为什么用堆外内存？</h4>
<p>堆外内存的使用场景非常巧妙。</p>
<p>第三方堆外缓存管理包 ohc(<strong>o</strong>ff-<strong>h</strong>eap-<strong>c</strong>ache) 给出了详细的解释。</p>
<p>摘了其中一段。</p>
<blockquote>
<p>When using a very huge number of objects in a very large heap, Virtual machines will suffer from increased GC pressure since it basically has to inspect each and every object whether it can be collected and has to access all memory pages. A cache shall keep a hot set of objects accessible for fast access (e.g. omit disk or network roundtrips). The only solution is to use native memory - and there you will end up with the choice either to use some native code (C/C++) via JNI or use direct memory access.</p>
</blockquote>
<p>大概的意思如下：</p>
<p>考虑使用缓存时，本地缓存是最快速的，但会给虚拟机带来 GC 压力。</p>
<p>使用硬盘或者分布式缓存的响应时间会比较长，这时候「堆外缓存」会是一个比较好的选择。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsnazy%2Fohc">OHC - An off-heap-cache — Github</a></p>
<h4 id="四：如何用堆外内存？"><a class="header-anchor" href="#四：如何用堆外内存？">¶</a>四：如何用堆外内存？</h4>
<p>在第一章中介绍了两种分配堆外内存的方法，Unsafe 和 NIO。</p>
<p>对于两种方法只是停留在分配和回收的阶段，距离真正使用的目标还很遥远。</p>
<p>在第三章中提到堆外内存的使用场景之一是缓存。</p>
<p>那是否有一个包，支持分配堆外内存，又支持 KV 操作，还无需关心 GC。</p>
<p>答案当然是有的。</p>
<p>有一个很知名的包，<strong>Ehcache</strong>。</p>
<p>Ehcache 被广泛用于 Spring，Hibernate 缓存，并且支持堆内缓存，堆外缓存，磁盘缓存，分布式缓存。</p>
<p>此外，Ehcache 还支持多种缓存策略。</p>
<p>其仓库坐标如下：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;org.ehcache&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;ehcache&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.4.0&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就是写代码进行验证：</p>
<pre class="line-numbers language-none"><code class="language-none">public class HelloHeapServiceImpl implements HelloHeapService &#123;

    private static Map&lt;String, InHeapClass&gt; inHeapCache &#x3D; Maps.newHashMap();

    private static Cache&lt;String, OffHeapClass&gt; offHeapCache;

    static &#123;
        ResourcePools resourcePools &#x3D; ResourcePoolsBuilder.newResourcePoolsBuilder()
                .offheap(1, MemoryUnit.MB)
                .build();

        CacheConfiguration&lt;String, OffHeapClass&gt; configuration &#x3D; CacheConfigurationBuilder
                .newCacheConfigurationBuilder(String.class, OffHeapClass.class, resourcePools)
                .build();

        offHeapCache &#x3D; CacheManagerBuilder.newCacheManagerBuilder()
                .withCache(&quot;cacher&quot;, configuration)
                .build(true)
                .getCache(&quot;cacher&quot;, String.class, OffHeapClass.class);


        for (int i &#x3D; 1; i &lt; 10001; i++) &#123;
            inHeapCache.put(&quot;InHeapKey&quot; + i, new InHeapClass(&quot;InHeapKey&quot; + i, &quot;InHeapValue&quot; + i));
            offHeapCache.put(&quot;OffHeapKey&quot; + i, new OffHeapClass(&quot;OffHeapKey&quot; + i, &quot;OffHeapValue&quot; + i));
        &#125;
    &#125;

    @Data
    @AllArgsConstructor
    private static class InHeapClass implements Serializable &#123;
        private String key;
        private String value;
    &#125;

    @Data
    @AllArgsConstructor
    private static class OffHeapClass implements Serializable &#123;
        private String key;
        private String value;
    &#125;

    @Override
    public void helloHeap() &#123;
        System.out.println(JSON.toJSONString(inHeapCache.get(&quot;InHeapKey1&quot;)));
        System.out.println(JSON.toJSONString(offHeapCache.get(&quot;OffHeapKey1&quot;)));
        Iterator iterator &#x3D; offHeapCache.iterator();
        int sum &#x3D; 0;
        while (iterator.hasNext()) &#123;
            System.out.println(JSON.toJSONString(iterator.next()));
            sum++;
        &#125;
        System.out.println(sum);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>.offheap(1, MemoryUnit.MB)</code>表示分配的是堆外缓存。</p>
<p>Demo 很简单，主要做了以下几步操作：</p>
<ol>
<li>新建了一个 Map，作为堆内缓存。</li>
<li>用 Ehcache 新建了一个堆外缓存，缓存大小为 1MB。</li>
<li>在两种缓存中，都放入 10000 个对象。</li>
<li>helloHeap 方法做 get 测试，并统计堆外内存数量，验证先插入的对象是否被淘汰。</li>
</ol>
<p>使用 Java VisualVM 工具 Dump 一个内存镜像。</p>
<p>Java VisualVM 是 JDK 自带的工具。</p>
<p>工具位置如下：</p>
<p>/Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk/Contents/Home/bin/jvisualvm</p>
<p>也可以使用 JProfiler 工具。</p>
<p>打开镜像，堆里有 10000 个 InHeapClass，却没有 OffHeapClass，表示堆外缓存中的对象的确没有占用 JVM 内存。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a25.png" class="" loading="lazy">
<p>内存镜像</p>
<p>接着测试 helloHeap 方法。</p>
<p>输出：</p>
<blockquote>
<p>{“key”:“InHeapKey1”,“value”:“InHeapValue1”}<br>
null<br>
……(此处有大量输出)<br>
5887</p>
</blockquote>
<p>输出表示堆外内存启用了淘汰机制，插入 10000 个对象，最后只剩下 5887 个对象。</p>
<p>如果堆外缓存总量不超过最大限制，则可以顺利 get 到缓存内容。</p>
<p><strong>总体而言，使用堆外内存可以减少 GC 的压力，从而减少 GC 对业务的影响。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">import java.nio.ByteBuffer;

&#x2F;**
 * 直接内存 与  堆内存的比较
 *&#x2F;
public class ByteBufferCompare &#123;

    public static void main(String[] args) &#123;
        allocateCompare();   &#x2F;&#x2F;分配比较
        operateCompare();    &#x2F;&#x2F;读写比较
    &#125;

    &#x2F;**
     * 直接内存 和 堆内存的 分配空间比较
     * 结论： 在数据量提升时，直接内存相比非直接内的申请，有很严重的性能问题
     *&#x2F;
    public static void allocateCompare()&#123;
        int time &#x3D; 10000000;    &#x2F;&#x2F;操作次数                           


        long st &#x3D; System.currentTimeMillis();
        for (int i &#x3D; 0; i &lt; time; i++) &#123;
            &#x2F;&#x2F;ByteBuffer.allocate(int capacity)   分配一个新的字节缓冲区。
            ByteBuffer buffer &#x3D; ByteBuffer.allocate(2);  &#x2F;&#x2F;非直接内存分配申请     
        &#125;
        long et &#x3D; System.currentTimeMillis();

        System.out.println(&quot;在进行&quot;+time+&quot;次分配操作时，堆内存 分配耗时:&quot; + (et-st) +&quot;ms&quot; );

        long st_heap &#x3D; System.currentTimeMillis();
        for (int i &#x3D; 0; i &lt; time; i++) &#123;
            &#x2F;&#x2F;ByteBuffer.allocateDirect(int capacity) 分配新的直接字节缓冲区。
            ByteBuffer buffer &#x3D; ByteBuffer.allocateDirect(2); &#x2F;&#x2F;直接内存分配申请
        &#125;
        long et_direct &#x3D; System.currentTimeMillis();

        System.out.println(&quot;在进行&quot;+time+&quot;次分配操作时，直接内存 分配耗时:&quot; + (et_direct-st_heap) +&quot;ms&quot; );
    &#125;

    &#x2F;**
     * 直接内存 和 堆内存的 读写性能比较
     * 结论：直接内存在直接的IO 操作上，在频繁的读写时 会有显著的性能提升
     *&#x2F;
    public static void operateCompare()&#123;
        int time &#x3D; 1000000000;

        ByteBuffer buffer &#x3D; ByteBuffer.allocate(2*time);  
        long st &#x3D; System.currentTimeMillis();
        for (int i &#x3D; 0; i &lt; time; i++) &#123;

            &#x2F;&#x2F;  putChar(char value) 用来写入 char 值的相对 put 方法
            buffer.putChar(&#39;a&#39;);
        &#125;
        buffer.flip();
        for (int i &#x3D; 0; i &lt; time; i++) &#123;
            buffer.getChar();
        &#125;
        long et &#x3D; System.currentTimeMillis();

        System.out.println(&quot;在进行&quot;+time+&quot;次读写操作时，非直接内存读写耗时：&quot; + (et-st) +&quot;ms&quot;);

        ByteBuffer buffer_d &#x3D; ByteBuffer.allocateDirect(2*time);
        long st_direct &#x3D; System.currentTimeMillis();
        for (int i &#x3D; 0; i &lt; time; i++) &#123;

            &#x2F;&#x2F;  putChar(char value) 用来写入 char 值的相对 put 方法
            buffer_d.putChar(&#39;a&#39;);
        &#125;
        buffer_d.flip();
        for (int i &#x3D; 0; i &lt; time; i++) &#123;
            buffer_d.getChar();
        &#125;
        long et_direct &#x3D; System.currentTimeMillis();

        System.out.println(&quot;在进行&quot;+time+&quot;次读写操作时，直接内存读写耗时:&quot; + (et_direct - st_direct) +&quot;ms&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原来的方案：</p>
<ul>
<li>CPU：用户态 java→内核态 system→用户态 java</li>
<li>内存：磁盘文件放到系统内存中的系统缓冲区，然后再从系统缓存区转到 java 堆内存的 java 缓冲区 byte[]</li>
</ul>
<p>新方案：</p>
<p>增加了直接内存区域。</p>
<p>直接将磁盘文件放到直接内存中，不经过系统内存，而是新画出了一个直接内存区，java 代码可以直接访问，系统也可以访问它。可以通过代码<code>import java.nio.ByteBuffer; ByteBuffer.allocate(内存大小)</code>申请直接内存区</p>
<p>分配和回收原理</p>
<pre class="line-numbers language-none"><code class="language-none">package MM;

import java.nio.ByteBuffer;
&#x2F;&#x2F;可以这样申请堆外内存 
public class Buffer &#123;

    public static void main(String[] args) &#123;

        while(true) &#123;
            ByteBuffer.allocate(10*1024*1024);
        &#125;
    &#125;
&#125;&#x2F;&#x2F;运行结果:控制台无任何输出，也未结束。
&#x2F;&#x2F;可以看到我们一直在申请内存，却一直没有内存溢出。直接内存被释放了。到底堆外内存(直接内存)是怎么释放的呢？（直接内存也会导致内存溢出）
&#x2F;&#x2F;---------程序2------------
public class test &#123;

    public static void main(String[] args) &#123;

        ByteBuffer byteBuffer&#x3D;ByteBuffer.allocateDirect(_1Gb);
        System.out.println(&quot;分配完毕&quot;);
        System.in.read();
        System.out.println(&quot;开始释放&quot;);
        byteBuffer&#x3D;null;&#x2F;&#x2F;后台显示释放成功
        System.gc();
        System.in.read();
    &#125;
&#125;
&#x2F;&#x2F;-----------程序3---------
public class test &#123;

    Static int _1Gb&#x3D;1024*1024*1024;

    public static void main(String[] args) &#123;

        Unsafe unsafe&#x3D;getUnsafe();
        long base&#x3D;unsafe.allocateMemoy(_1Gb);
        unsafe.setMemory(base,_1Gb,(byte)0);
        System.in.read();
        unsafe.freeMemory(base);
        System.in.read();
    &#125;
    public static Unsafe getUnsafe()&#123;
        try &#123;
            Field f&#x3D;Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
            f.setAccessible(true);
            Unsafe unsafe&#x3D;(Unsafe) f.get(null);
            return unsafe
        &#125; catch (NoSuchFieldException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

&#x2F;*
NIO申请直接内存总结：

我们用NIO类申请的内存不受JVM的管理，但是其实是由jvm进行回收的，并不像unsave那样要我们自己对内存进行管理。这时候系统是不断回收直接内存的，由NIO申请的直接内存是需要System.gc()来进行内存回收的。系统会帮助我们回收直接内存的。

不过为了提高gc的利用率，我们可能会在代码中加入-XX:+DisableExplicit禁止代码中显示调用gc(System.gc)。采取并行gc，就是由jvm来自动管理内存回收，而jvm主要是管理堆内内存，也就是当对堆内对象回收的时候，才有可能回收直接内存，这种不对称性很有可能产生直接内存内存泄漏。

需要注意的是当我们没有指向堆外内存的引用的时候，也会把直接内存回收，这也是上面我们内存没有泄漏的原因。

采用直接内存的优点：

1：对于频繁的io操作，我们需要不断把内存中的对象复制到直接内存。然后由操作系统直接写入磁盘或者读出磁盘。

这时候用到直接内存就减少了堆的内外内存来回复制的操作。

2：我们在运行程序的过程中可能需要新建大量对象，对于一些声明周期比较短的对象，可以采用对象池的方式。但

是对于一些生命周期较长的对象来说，不需要频繁调用gc，为了节省gc的开销，直接内存是必备之选。

3：扩大程序运行的内存，由于jvm申请的内存有限，这时候可以通过堆外内存来扩大内存。

*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦<br>
ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</p>
<p>JDK=jre+ development kit</p>
<p>JRE=jvm+ core lib</p>
<h2 id="4-垃圾回收"><a class="header-anchor" href="#4-垃圾回收">¶</a>4_垃圾回收</h2>
<p>如何判断对象可以回收：</p>
<ul>
<li>1 引用计数法：对象没有一个引用计算器，就 + 1。<br>
缺陷：循环引用。如 AB 对象互相引用，但没有其他对象引用 AB 对象时，AB 对象本该回收却不能回收</li>
<li>2 可达性分析（根搜索）算法：从根对象的点作为起始进行向下搜索，当一个对象到根对象没有任何引用链相连，则证明此对象是不可用的 。
<ul>
<li>根对象 GC Root：肯定不能被垃圾回收的对象。然后扫描堆中所有对象，判断是否被根对象直接或间接引用，如果引用了就不能回收。如果没有被直接 / 间接引用，就可以当做垃圾回收。</li>
<li>GC roots 包括：
<ul>
<li>在 VM 栈（帧的本地变量）中的引用</li>
<li>方法区的静态引用</li>
<li>JNI（即一般说的 Native 方法）中的引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>哪些对象可以作为 GC Root ?</p>
<ul>
<li>Memory Analyzer (MAT) 堆分析工具：需要先使用 jmap 分析出堆内存，拿到快照，再由 MAT 进行分析。<code>jmap -dump:format=b,live,file=1.bin 【进程号】</code>。把 bin 文件导入 MAT 后，可以通过 java Basics–GC Roots 查看根对象。
<ul>
<li>dump：要把当前堆内存情况存储为一个文件</li>
<li>format=b：转出文件的格式，b 表示二进制</li>
<li>live：只关心存活的，不关心垃圾回收的。自动在进行快照前会进行一次垃圾回收。</li>
<li>file=1.bin：文件名</li>
</ul>
</li>
</ul>
<h3 id="四种引用"><a class="header-anchor" href="#四种引用">¶</a>四种引用</h3>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/825cca41d962">https://www.jianshu.com/p/825cca41d962</a></p>
<p><strong>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。 很多系统的缓存功能都符合这样的应用场景。</strong></p>
<p>我们把引用分为 4 种，用法如下</p>
<ul>
<li>Strong：默认通过 Object o=new Object(); 这种方式赋值的引用</li>
<li>Soft、Weak、Phantom：这三种则都是继承 Refrence。如<code>SoftReference&lt;byte[]&gt; cacheRef = new SoftReference&lt;&gt;(4*1024*1024);</code></li>
</ul>
<p>说明：</p>
<ul>
<li>强引用 Strong：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收。我们平时 new 的对象都是强引用。强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会靠随意回收具有强引用 对象来解决内存不足的问题。</li>
<li>软引用（SoftReference）：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象可以配合引用队列来释放软引用自身。软引用是用来描述一些还有用但并非必须的对象。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>
<li>弱引用（WeakReference）：仅有弱引用引用该对象时（没有任何强引用关联他），在垃圾回收时，无论内存是否充足，都会回收弱引用对象。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。可以配合引用队列来释放弱引用自身。</li>
<li>虚引用（PhantomReference）：必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存。<br>
“虚引用” 顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<br>
虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li>
<li>终结器引用（FinalReference）：无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</li>
</ul>
<p>在 Full GC 时会对 Reference 类型的引用进行特殊处理</p>
<ul>
<li>
<p>Soft：内存不够时一定被 GC，长期不用也会被 GC</p>
</li>
<li>
<p>Weak：一定被 GC，当做标记为 dead，会在 ReferenceQueue 中通知。</p>
</li>
<li>
<p>Phantom：本来就没引用，当从 jvm 堆中释放时会通知。</p>
</li>
</ul>
<p>软引用</p>
<pre class="line-numbers language-none"><code class="language-none">package JVMtest;

import java.lang.ref.SoftReference;
import java.util.ArrayList;
&#x2F;&#x2F; -Xmx20m -XX:+PrintGCDetails -verbose:gc
public class Ref &#123;
    private static final int _4MB&#x3D;4*1024*1024;

    public static void main(String[] args) &#123;
        ArrayList&lt;byte[]&gt; list &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;强引用
        for (int i&#x3D;0;i&lt;5;i++)&#123;
            list.add(new byte[_4MB]);
        &#125;
    &#125;

    public static void soft()&#123;

        ArrayList&lt;SoftReference&lt;Byte[]&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;软引用
        for (int i &#x3D; 0; i &lt; 5; i++) &#123;
            SoftReference&lt;Byte[]&gt; ref&#x3D;new SoftReference&lt;&gt;(new Byte[_4MB]);
            System.out.println(ref.get());&#x2F;&#x2F;正常显示
            list.add(ref);
            System.out.println(list.size());

        &#125;&#x2F;&#x2F;内存不够进行了垃圾回收，软引用垃圾回收后内容扔不足就会把软引用扔掉
        System.out.println(&quot;循环结束&quot;+list.size());
        for (SoftReference&lt;Byte[]&gt; ref:list) &#123;
            System.out.println(ref.get());&#x2F;&#x2F;前4个都变为null
        &#125;
    &#125;
&#125;
&#x2F;*
[Ljava.lang.Byte;@1b6d3586
[Ljava.lang.Byte;@4554617c
[Ljava.lang.Byte;@74a14482
[Ljava.lang.Byte;@1540e19d
[Ljava.lang.Byte;@677327b6
循环结束：5
null
null
null
null
[Ljava.lang.Byte;@677327b6
*&#x2F;

Ljava.lang.Byte;@1b6d3586
[Ljava.lang.Byte;@4554617c
[Ljava.lang.Byte;@74a14482
[GC (Allocation Failure) [PSYoungGen: 1819K-&gt;488K(6144K)] 14107K-&gt;12968K(19968K), 0.0020269 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] &#x2F;&#x2F;调用了一次新生代垃圾回收，从1.8M回收到了0.4M
[Ljava.lang.Byte;@1540e19d
[GC (Allocation Failure) --[PSYoungGen: 4696K-&gt;4696K(6144K)] 17176K-&gt;17216K(19968K), 0.0023349 secs] [Times: user&#x3D;0.08 sys&#x3D;0.00, real&#x3D;0.00 secs] &#x2F;&#x2F;一次新生代垃圾回收，没回收多少
[Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4536K(6144K)] [ParOldGen: 12520K-&gt;12472K(13824K)] 17216K-&gt;17008K(19968K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0069859 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] &#x2F;&#x2F;一次FULL垃圾回收，还是没回收多少
[GC (Allocation Failure) --[PSYoungGen: 4536K-&gt;4536K(6144K)] 17008K-&gt;17008K(19968K), 0.0045728 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] &#x2F;&#x2F;触发软连接垃圾回收
[Full GC (Allocation Failure) [PSYoungGen: 4536K-&gt;0K(6144K)] [ParOldGen: 12472K-&gt;606K(8704K)] 17008K-&gt;606K(14848K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0054783 secs] [Times: user&#x3D;0.08 sys&#x3D;0.00, real&#x3D;0.00 secs] &#x2F;&#x2F;再一次FULL垃圾回收，回收了4M
[Ljava.lang.Byte;@677327b6
循环结束：5
null
null
null
null
[Ljava.lang.Byte;@677327b6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引用队列</p>
<pre class="line-numbers language-none"><code class="language-none">总结：
 软引用的list中有的为null了，但还没从list中清除掉。
 可以配合引用队列清楚。
 ArrayList&lt;SoftReference&lt;Byte[]&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();
 
 ReferenceQueue&lt;byte[]&gt; queue&#x3D;new  ReferenceQueue&lt;&gt;();&#x2F;&#x2F;创建引用队列
 
 SoftReference&lt;Byte[]&gt; ref&#x3D;new SoftReference&lt;&gt;(new Byte[_4MB],queue);&#x2F;&#x2F;关联引用队列
 &#x2F;&#x2F;当软引用所关联的的byte[]回收时，软引用自身就会被加入到queue中去。遍历时，就先到queue中查找，
 Reference&lt;?extends byte[]&gt; poll&#x3D;queue.poll();&#x2F;&#x2F;每次取一个
while(poll!&#x3D;null)&#123;
    list.remove(poll);
    poll&#x3D;queue.poll()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>弱引用</p>
<pre class="line-numbers language-none"><code class="language-none">package JVMtest;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
&#x2F;&#x2F; 演示弱引用
&#x2F;&#x2F; -Xmx20m -XX:+PrintGCDetails -verbose:gc
public class Weak &#123;
    private static final int _4MB&#x3D;4*1024*1024;

    public static void main(String[] args) &#123;
        List&lt;WeakReference&lt;byte[]&gt;&gt; list&#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;弱引用
        for (int i &#x3D; 0; i &lt; 5; i++) &#123;
            WeakReference&lt;byte[]&gt; ref&#x3D;new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            System.out.println(&quot;第&quot;+(i+1)+&quot;次循环&quot;);
            for ( WeakReference&lt;byte[]&gt; w:list) &#123;
                System.out.println(w.get()+&quot;&quot;);
            &#125;
            System.out.println();
        &#125;
        System.out.println(&quot;循环结束：&quot;+list.size());
    &#125;
&#125;


第1次循环&#x2F;&#x2F;一个数组
[B@1b6d3586

第2次循环
[B@1b6d3586
[B@4554617c

第3次循环
[B@1b6d3586
[B@4554617c
[B@74a14482

[GC (Allocation Failure) [PSYoungGen: 1819K-&gt;488K(6144K)] 14107K-&gt;13016K(19968K), 0.0011633 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] &#x2F;&#x2F;触发了一次GC
第4次循环&#x2F;&#x2F;虽然GC了，但还存活
[B@1b6d3586
[B@4554617c
[B@74a14482
[B@1540e19d

[GC (Allocation Failure) [PSYoungGen: 4696K-&gt;488K(6144K)] 17224K-&gt;13016K(19968K), 0.0006622 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] &#x2F;&#x2F;又一次GC
第5次循环
[B@1b6d3586
[B@4554617c
[B@74a14482
null &#x2F;&#x2F;内存不够了，刚才GC清理了这个
[B@677327b6

循环结束：5
 &#x2F;&#x2F;FULL GC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法">¶</a>垃圾回收算法</h3>
<ul>
<li>1 标记、清除 Mark-Sweep</li>
<li>2 标记、整理 Mark-Compact</li>
<li>3 复制 Copying</li>
<li>分代 Generational</li>
</ul>
<h5 id="1-标记-清除"><a class="header-anchor" href="#1-标记-清除">¶</a>1 标记 + 清除</h5>
<p>标记：哪些对象可以当成垃圾（不被 GC Root 间接引用的）+ 清除（是否标记的那些空间）。没有需要就标记为不需要了。</p>
<p>缺点：效率不高，两个过程效率都不高。会造成内存碎片。空闲的区域都是小碎片，放不了大的对象。空间碎片太多可能会导致后续事宜中无法找到足够的连续内存而提前触发另一次垃圾搜集动作。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a26.png" class="" loading="lazy">
<p>红色的对象应该被回收</p>
<h5 id="2-标记-整理"><a class="header-anchor" href="#2-标记-整理">¶</a>2 标记 + 整理</h5>
<p>清除碎片的过程中会把后面的对象往前移到可用的内存</p>
<p>定义：Mark Compact 没有内存碎片<br>
缺点：速度慢</p>
<h5 id="3-复制"><a class="header-anchor" href="#3-复制">¶</a>3 复制</h5>
<p>将可用内存划分为两块（两块 Survivor 区 To 和 From），每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面，然后就把原来半块内存空间一次性清除掉，整理过程。清掉整块的速度非常快，但是浪费内存，一半不可用</p>
<p>即新生代和老年代。不会有内存碎片<br>
缺点：需要占用双倍内存空间，在对象存活率较高的时候，效率有所下降。如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<h3 id="分代垃圾回收机制"><a class="header-anchor" href="#分代垃圾回收机制">¶</a>分代垃圾回收机制</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hollis_chuang/article/details/91349868">https://blog.csdn.net/hollis_chuang/article/details/91349868</a></p>
<p>分为：新生代 + 老年代</p>
<ul>
<li>新生代：伊甸园 Eden + 幸存区 From + 幸存区 To。Oracle Hotspot 虚拟机默认比例是 8:1:1。每次只有 10% 的内存是浪费的。可以通过<code>-XX:SurvivorRatio=8</code>调整，但是有自适应比较，可以通过<code>-XX:-UseAdaptiveSizePolicy</code>关掉。<code>-Xmn</code>可以设置新生代空间大小，但一般不设置 Xmn</li>
<li>老年代：经历 N 次垃圾回收都存活的对象</li>
<li>新生代老年代默认比例：<code>-XX:NewRatio=</code>，(默认) 老年代: 新生代 = 2</li>
</ul>
<p>思想：需要长时间使用的对象放到老年区。永远就可以丢弃的对象放到新生区中。</p>
<ul>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间 (伊甸园) 不足时，触发 <code>minor gc</code>，伊甸园和 from 中存活的对象复制到 to 中，存活的对象年龄 + 1，交换 from 与 to 标识。当对象寿命超过 == 最大寿命是 15（4bit）== 阈值时，会晋升至老年代。当 To 区也满的时候也会放到老年代。
<ul>
<li><code>minor gc</code> 会引发 <code>stop the world</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
</li>
<li>当老年代空间不足，会先尝试触发 <code>minor gc</code>，如果之后空间仍不足，那么触发 <code>full gc</code>，对新生代和老年代全部区域做一次垃圾清理。<code>STW</code>(Stop the World) 的时间更长</li>
<li>老年区 Full GC 后还是不能保存对象，就触发内存不足 OOM 异常 “OutOfMemoryError”。</li>
<li>经历多次 GC 后，存活的对象会在 From 和 To 之间来回存放，而这里面的一个前提则是这两个空间有足够的大小来存放这些数据，在 GC 算法中，会计算每个对象年龄的大小，如果达到某个年龄后发现总大小已经大于了幸存区空间的 50%，那么这是就需要调整阈值，不能再继续等到默认的 15 次 GC 后才晋升。因为这样会导致幸存区空间不足，所以需要调整阈值，让这些存活对象尽快完成晋升。</li>
</ul>
<h4 id="GC-的时机："><a class="header-anchor" href="#GC-的时机：">¶</a>GC 的时机：</h4>
<ul>
<li>①Minor GC (YGC，Scavenge GC)
<ul>
<li>触发时机：新对象生成时，新生代中 Eden 空间满了</li>
<li>理论上 Eden 区大多数对象会在 Minor GC 回收，复制算法的执行效率会很高，Minor GC 时机比较短</li>
</ul>
</li>
<li>②Full GC（Major GC）
<ul>
<li>主要的触发时机：Old 满了、Perm 满了、system.gc()</li>
<li>对整个 JVM（新生代 + 老年代）进行整理，包括 Young、Old 和（Perm[JVM1.6 之前]）</li>
<li>效率很低，尽量减少 Full GC。Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>
</ul>
</li>
</ul>
<blockquote>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<ul>
<li>
<p>Partial GC：并不收集整个 GC 堆的模式</p>
</li>
<li>
<ul>
<li>Young GC：只收集 young gen 的 GC</li>
<li>Old GC：只收集 old gen 的 GC。只有 CMS 的 concurrent collection 是这个模式</li>
<li>Mixed GC：收集整个 young gen 以及部分 old gen 的 GC。只有 G1 有这个模式</li>
</ul>
</li>
<li>
<p>Full GC：收集整个堆，包括 young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p>
</li>
</ul>
<p>Major GC 通常是跟 full GC 是等价的，收集整个 GC 堆。但因为 HotSpot VM 发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说 “major GC” 的时候一定要问清楚他想要指的是上面的 full GC 还是 old GC。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">public class GC &#123;
    private static final int _7MB&#x3D;7*1024*1024;
    &#x2F;&#x2F; -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    &#x2F;&#x2F;堆初始大小  堆最大大小20m  新生代大小10m
    public static void main(String[] args) &#123;
        ArrayList&lt;byte[]&gt; list &#x3D; new ArrayList&lt;&gt;();
        list.add(new byte[_7MB]);
    &#125;
&#125;

&#x2F;&#x2F;下面的结果是main中什么都什么时的结果
Heap &#x2F;&#x2F;堆 8M伊甸园，1From+1To
&#x2F;&#x2F;新生代 9M,不计入幸存区
 def new generation   total 9216K, used 1814K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  22% used [0x00000000fec00000, 0x00000000fedc5868, 0x00000000ff400000)&#x2F;&#x2F;伊甸园初试时候就有一些必要的类
  from space 1024K,   0% use d [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 &#x2F;&#x2F;老年代
 tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)
 &#x2F;&#x2F;元空间
 Metaspace       used 3116K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 337K, capacity 388K, committed 512K, reserved 1048576K
&#x2F;&#x2F;-------第二次运行--------添加了7M------
 &#x2F;&#x2F;触发了一次minor GC 
&#x2F;&#x2F;数字代表：[DefNew:回收前K-&gt;(总K),耗时]堆回收前-&gt;堆回收后(堆总大小),堆耗时
[GC (Allocation Failure) [DefNew: 1649K-&gt;594K(9216K), 0.0043403 secs] 1649K-&gt;594K(19456K), 0.0055600 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] 
Heap
 def new generation   total 9216K, used 8336K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  94% used [0x00000000fec00000, 0x00000000ff38f7b8, 0x00000000ff400000)
&#x2F;&#x2F;放入To后，From和To交换了，所以这里的from是原来的To
  from space 1024K,  58% used [0x00000000ff500000, 0x00000000ff594980, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)
 Metaspace       used 3214K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大对象直接晋升到老年代：通过控制<code>_XX:+PretenureSizeThreshold=,-XX:UserSerialGC</code></p>
<p>MaxTenuringThreshold 的作用：在可以自动调节晋升到老年代的 GC 中，设置该阈值的最大值。该参数默认值位 15，CMS 中默认值为 6，G1 中默认值为 15。<code>-XX:MaxTenuringThreshold=,-XX:PrintTenuringDistribution</code></p>
<h5 id="分配担保机制"><a class="header-anchor" href="#分配担保机制">¶</a><strong>分配担保机制</strong></h5>
<p>简单解释一下为什么会出现这种情况： 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 ** 分配担保机制：** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p>
<pre class="line-numbers language-none"><code class="language-none">public class GCTest &#123;

    public static void main(String[] args) &#123;
        byte[] allocation1, allocation2,allocation3,allocation4,allocation5;
        allocation1 &#x3D; new byte[32000*1024];
        allocation2 &#x3D; new byte[1000*1024];
        allocation3 &#x3D; new byte[1000*1024];
        allocation4 &#x3D; new byte[1000*1024];
        allocation5 &#x3D; new byte[1000*1024];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="大对象直接进入老年代："><a class="header-anchor" href="#大对象直接进入老年代：">¶</a>大对象直接进入老年代：</h5>
<p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p>为什么要这样呢？</p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<p><strong>为对象分配内存：TLAB</strong><br>
为什么有 TLAB (Thread Local Allocation Buffer) ?<br>
●堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据<br>
●由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的<br>
●为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p>什么是 TLAB ?<br>
●从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。<br>
●多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。<br>
●据说所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a27.png" class="" loading="lazy">
<p>每个线程有一份，使用完了再用公共的。默认是开启的</p>
<p>TLAB 的再说明:<br>
●尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是 TLAB 作为内存分配的首选。</p>
<p>在程序中，开发人员可以通过选项 “-XX:UseTLAB” 设置是否开启 TLAB 空间。<br>
●默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，当然我们可以通过选项 “<code>-XX:TLABWasteTargetPercent</code>” 设置 TLAB 空间所占用 Eden 空间的百分比大小。<br>
●一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p>
<h3 id="垃圾收集器"><a class="header-anchor" href="#垃圾收集器">¶</a>垃圾收集器</h3>
<p>前面我们讲了垃圾回收的算法，还需要有具体的实现，在 jvm 中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1 垃圾收集器，接下来，我们一个个的了解学习。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819021246.png" class="" loading="lazy">>
<blockquote>
<ul>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、 ParNew+Serial Old 这两个组合声明为废弃（JEP 173） ，并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 SerialOld GC 组合（JEP366 ）</li>
<li>（青色虚线）JDK 14 中：删除 CMS 垃圾回收器 （JEP 363）</li>
</ul>
</blockquote>
<p>查看默认的垃圾收集器<br>
方法 1：-xx：+PrintCommandLineFlags： 查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>方法 2：使用命令行指令： <code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 *  -XX:+PrintCommandLineFlags
 *
 *  -XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC
 *
 *  -XX:+UseParNewGC：标明新生代使用ParNew GC
 *
 *  -XX:+UseParallelGC:表明新生代使用Parallel GC
 *  -XX:+UseParallelOldGC : 表明老年代使用 Parallel Old GC
 *  说明：二者可以相互激活
 *
 *  -XX:+UseConcMarkSweepGC：表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用
 *&#x2F;
public class GCUseTest &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;byte[]&gt; list &#x3D; new ArrayList&lt;&gt;();

        while(true)&#123;
            byte[] arr &#x3D; new byte[100];
            list.add(arr);
            try &#123;
                Thread.sleep(10);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;-XX:InitialHeapSize&#x3D;268435456 -XX:MaxHeapSize&#x3D;4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>JDK8 使用的是 PS PO。JDK9 是 G1</p>
<h4 id="3-1-串行垃圾收集器Serial-GC"><a class="header-anchor" href="#3-1-串行垃圾收集器Serial-GC">¶</a>3.1 串行垃圾收集器<code>Serial GC</code></h4>
<p>串行垃圾收集器，是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且 java 应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为 STW（Stop-The-World）。</p>
<p>对于交互性强的应用而言，这种垃圾收集器是不能接受的。</p>
<p>一般在 Javaweb 应用中是不会采用该收集器的。</p>
<p>年轻代里用是的 Serial，对应到年老代的较 Serial Old</p>
<p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。 Serial Old 收集器同样也采用了串行回收 和 “Stop the World” 机制。</p>
<ul>
<li>只不过内存回收算法使用的是标记一压缩算法。</li>
<li>➢Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器</li>
<li>➢Serial 0Od 在 Server 模式下主要有两个用途：①与新生代的 ParallelScavenge 配合使用; ②作为老年代 CMS 收集器的后备垃圾收集方案。</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a30.png" class="" loading="lazy">
<ul>
<li>简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Seria1 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
<ul>
<li>➢运行在 Client 模式下的虛拟机是个不错的选择。</li>
</ul>
</li>
<li>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB）， 可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms） ，只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>在 HotSpot 虛拟机中，使用 - XX： +UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。
<ul>
<li>等价于新生代用 Serial GC，且老年代用 Serial Old GC</li>
<li>控制台输出 <code>-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC</code></li>
</ul>
</li>
</ul>
<p>3.1.1 编写测试代码</p>
<pre class="line-numbers language-none"><code class="language-none">public class TestGC &#123;
    &#x2F;&#x2F;实现：不断产生新的数据（对象），随机的废弃对象（垃圾）
    public static void main(String[] args) throws Exception &#123;
        List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();
        while (true) &#123;
            int sleep &#x3D; new Random().nextInt(100);
            if (System.currentTimeMillis() % 2 &#x3D;&#x3D; 0) &#123;
                &#x2F;&#x2F;当前的时间戳为偶数
                list.clear();&#x2F;&#x2F;清空
            &#125; else &#123;
                &#x2F;&#x2F;向list中添加10000个对象
                for (int i &#x3D; 0; i&lt;10000; i++) &#123;
                    Properties properties &#x3D; new Properties();
                    properties.put(&quot;key_&quot; + i,&quot;value_&quot; + System.currentTimeMillis() + i);
                    list.add(properties);
                &#125;
            &#125;
            Thread.sleep(sleep);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="3-1-2-设置垃圾回收为串行收集器"><a class="header-anchor" href="#3-1-2-设置垃圾回收为串行收集器">¶</a>3.1.2 设置垃圾回收为串行收集器</h5>
<p>在程序运行参数中添加 2 个参数，如下：</p>
<ul>
<li>
<p><code>-XX:+UseSerialGC</code>：指定<code>年轻代和老年代都</code>使用串行垃圾收集器</p>
</li>
<li>
<p><code>-XX:+PrintGCDetails</code>：打印垃圾回收的详细信息</p>
</li>
</ul>
<blockquote>
<h1>为了测试 GC，将堆的初始和最大内存都设置为 16M</h1>
<p><code>‐XX:+UseSerialGC ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</code></p>
</blockquote>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/2019082910552275.png" class="" loading="lazy">
<p>启动程序，可以看到下面信息：括号内为垃圾回收原因</p>
<blockquote>
<p>[GC (Allocation Failure) [DefNew: 4416K-&gt;512K(4928K), 0.0034563 secs] 4416K-&gt;1841K(15872K), 0.0126067 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 因为分配内存失败而进行垃圾回收。DefNew 代表是串行垃圾回收器</p>
<p>[Full GC (Allocation Failure) [Tenured: 10943K-&gt;10943K(10944K), 0.0205414 secs] 15871K-&gt;13831K(15872K), [Metaspace: 3311K-&gt;3311K(1056768K)], 0.0205747 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</p>
</blockquote>
<p>GC 日志信息解读：</p>
<p>年轻代的内存 GC 前后的大小：</p>
<ul>
<li>DefNew</li>
</ul>
<p>表示使用的是串行垃圾收集器。</p>
<ul>
<li>4416K-&gt;512K(4928K)</li>
</ul>
<p>表示，年轻代 GC 前，占有 4416K 内存，GC 后，占有 512K 内存，总大小 4928K</p>
<ul>
<li>0.0034563 secs</li>
</ul>
<p>表示，GC 所用的时间，单位为毫秒。</p>
<ul>
<li>4416K-&gt;1841K(15872K)</li>
</ul>
<p>表示，GC 前，堆内存占有 4416K，GC 后，占有 1841K，总大小为 15872K</p>
<ul>
<li>Full GC</li>
</ul>
<p>表示，内存空间全部进行 GC</p>
<h4 id="3-2-并行垃圾收集器"><a class="header-anchor" href="#3-2-并行垃圾收集器">¶</a>3.2 并行垃圾收集器</h4>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a31.jpg" class="" loading="lazy">
<p>并行垃圾收集器在串行垃圾收集器的基础上做了改进，将单线程改为了<strong>多线程进行垃圾回收，这样可以缩短垃圾回收的时间</strong>。（这里是指，并行能力较强的机器）</p>
<p>当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾收集器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。</p>
<p>并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记 - 整理，在回收的同时还会对内存进行压缩。关注吞吐量主要指年轻代的 Parallel Scavenge 收集器，通过两个目标参数<code>-XX:MaxGCPauseMills</code>和<code>-XX:GCTimeRatio</code>，调整新生代空间大小，来降低 GC 触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p>
<h5 id="3-2-1-ParNew垃圾收集器-年轻代-PS-年轻代"><a class="header-anchor" href="#3-2-1-ParNew垃圾收集器-年轻代-PS-年轻代">¶</a>3.2.1 <code>ParNew</code>垃圾收集器 (年轻代)+<code>PS</code>(年轻代)</h5>
<p>ParNew 垃圾收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了并行。<strong>是<code>parallel Scavenge</code>的增强，为了匹配年老代的<code>CMS</code></strong></p>
<p>通过 - XX:+UseParNewGC 参数设置年轻代使用 ParNew 回收器，老年代使用的依然是串行收集器。</p>
<ul>
<li>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。
<ul>
<li>➢Par 是 Parallel 的缩写，New： 只能处理的是新生代</li>
</ul>
</li>
<li>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、“Stop-the-World” 机制。</li>
<li>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a32.png" class="" loading="lazy">
<ul>
<li>
<p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p>
<ul>
<li>➢ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、 多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>➢但是在单个 CPU 的环境下，ParNew 收 集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
</li>
<li>
<p>除 Serial Old 外，目前 ParNew GC 还可以与 CMS 收集器配合工作</p>
</li>
<li>
<p>在程序中，开发人员可以通过选项 “-XX： +UseParNewGC” 手动指定使用. ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li>
<p>-XX：ParallelGCThreads 限制线程数量，默认开启和 CPU 数据相同的线程数。.</p>
</li>
</ul>
<p>对于新生代，回收次数频繁，使用并行方式高效。</p>
<p>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行 需要切换线程，串行可以省去切换线程的资源）</p>
<p>测试：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a33.png" class="" loading="lazy">
<blockquote>
<p>#参数<br>
‐XX:+UseParNewGC ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<p>#打印出的信息</p>
<p>[GC (Allocation Failure) [ParNew: 4416K-&gt;512K(4928K), 0.0026548 secs] 4416K-&gt;1863K(15872K), 0.0026831 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>
</blockquote>
<p><code>-XX:ParallelGCThread</code>可以限制线程数量，默认开启和 CPU 数量相同的线程数</p>
<p>由以上信息可以看出，ParNew: 使用的是 ParNew 收集器。其他信息和串行收集器一致。</p>
<h5 id="3-2-2-PS-PO垃圾收集器"><a class="header-anchor" href="#3-2-2-PS-PO垃圾收集器">¶</a>3.2.2 <code>PS+PO</code>垃圾收集器</h5>
<p>ParallelGC 即 Parallel Scan+Parallel Old。JDK8 的默认回收器</p>
<p>PS 是吞吐量优先收集器</p>
<p>Parallel GC 收集器工作机制和 ParNew GC 收集器一样，只是在此基础上，新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。相当于原来是一个人打扫，现在是多个人打扫快速打扫完。</p>
<p>高吞吐量则可以高效率地利用 CPU 的时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，不要求低延迟。因此，常见在服务器环境中使用 内存回收性能很不错。例如，那么执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外， Parallel Scavenge 收集器同样也采用了复制算法、并行回收和 “Stop the World” 机制。那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>➢和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。
<ul>
<li>吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)</li>
</ul>
</li>
<li>➢<strong>自适应调节</strong>策略也是 Parallel Scavenge 与 ParNew 一个重要区别。自适应：根据情况调整内存分配情况。</li>
</ul>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>而其他 CMS 的停顿时间段是为了适合需要与用户交互的程序。</p>
<p><code>PO</code>：</p>
<ul>
<li>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
</li>
<li>
<p>Parallel Old 收集器采用了标记 - 压缩算法，但同样也是基于并行回收和”Stop-the-World&quot; 机制。</p>
</li>
<li>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。</p>
</li>
<li>
<p>在 Java8 中，默认是 PO 垃圾收集器</p>
</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a34.png" class="" loading="lazy">
<p>相关参数如下：</p>
<ul>
<li>
<p><code>-XX:+UseParallelGC</code>： 年轻代使用 PS 垃圾收集器，老年代使用 Serial 串行回收器。</p>
</li>
<li>
<p><code>-XX:+UseParallelOldGC</code>： 年轻代使用 PS 垃圾回收器，老年代使用 PO 垃圾回收器。</p>
</li>
<li>
<p><code>-XX:MaxGCPauseMillis</code>：设置最大的垃圾收集时的停顿时间，单位为毫秒</p>
</li>
</ul>
<p>需要注意的是，ParallelGC 为了达到设置的停顿时间，可能会调整堆大小或其他的参数，如果堆的大小设置的较小，就会导致 GC 工作变得很频繁，反而可能会影响到性能。比如堆满了我们得 GC 了，但是 GC 设置是时间比较短，还没清完垃圾又到时得去工作了，还没 new 几个对象又满了，又得去 GC，GC 又释放不了几个又去工作了。。。恶性循环</p>
<p>该参数使用需谨慎。对于客户来讲是低延迟好。但我们服务器端注重高并发，整体的吞吐量，所以服务器端使用 PS+PO</p>
<ul>
<li><code>-XX:GCTimeRatio</code>
<ul>
<li>设置垃圾回收时间占程序运行时间的百分比，公式为 1/(1+n)</li>
<li>它的值为 1~100 之间的数字，默认值为 99，也就是垃圾回收时间不能超过 1%。一般不设置</li>
</ul>
</li>
<li><code>-XX:UseAdaptiveSizePolicy</code>： 自适应 GC 模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡。一般用于，手动调整参数比较困难的场景，让收集器自动进行调整。</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a35.png" class="" loading="lazy">
<blockquote>
<p>#参数</p>
<p>‐XX:+UseParallelGC ‐XX:+UseParallelOldGC ‐XX:MaxGCPauseMillis=100 ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<p>#打印的信息</p>
<p>[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;480K(4608K)] 4096K-&gt;1700K(15872K), 0.0108734 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</p>
<p>[Full GC (Ergonomics) [PSYoungGen: 498K-&gt;0K(2560K)] [ParOldGen: 8492K-&gt;1889K(11264K)] 8991K-&gt;1889K(13824K), [Metaspace: 3306K-&gt;3306K(1056768K)], 0.0182486 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</p>
</blockquote>
<p>由以上信息可以看出，年轻代和老年代都使用了 ParalledGC 垃圾回收器。</p>
<p>CPU 数量大于 8 个的时候，回收线程个数 = 3+(5×CPU)/8</p>
<blockquote>
<p>将 CMS 之前先明确下并发并行的概念：</p>
<p>我们经常提高并发，并发是指多个 cpu 同时运行，在 gc 中即运行代码 cpu 与垃圾回收 cpu 同时进行，</p>
<p>并发是依次发生。我们只记高并发即可，高并发是多 cpu。</p>
</blockquote>
<h4 id="3-3-CMS垃圾收集器-老年代-PN-年轻代-Serial-Old"><a class="header-anchor" href="#3-3-CMS垃圾收集器-老年代-PN-年轻代-Serial-Old">¶</a>3.3 <code>CMS</code>垃圾收集器 (老年代)+<code>PN</code>(年轻代)+<code>Serial Old</code></h4>
<p>并发标记清除收集器：并发标记清除收集器组合 <code>ParNew + CMS + Serial Old</code></p>
<p>在 JDK1.5 时期， HotSpot 推出了一款在强交互应用中几乎可认为有划 时代意义的垃圾收集器： CMS （Concurrent -Mark -Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS 全称 Concurrent Mark Sweep（并发标记清除，工作线程和垃圾回收线程同时执行），是一款并发的、使用标记 - 清除算法的垃圾回收器，该回收器是针对<code>老年代</code>垃圾回收的，通过参数<code>-XX:+UseConcMarkSweepGC</code>进行设置。是为了解决停顿的问题，所以他的优点是垃圾回收的时候程序可以继续执行，因为我们只回收没用的位置，有用的位置不改变，程序还能找到。</p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时 间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。目前很大一部分的 Java 应用集中在互联网站或者 B/s 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</p>
<p>关注<strong>低延迟</strong>。</p>
<p>当年老代达到特定的占用比例时，CMS 开始执行。</p>
<p>与之对应的年轻代垃圾回收器是 PN，PN 是 PS 为了匹配 CMS 升级的</p>
<blockquote>
<p>PN 在 jdk9 被移除了，CMS 在 JDK10 被移除</p>
<ul>
<li>CMS 的垃圾 收集算法采用标记 - 清除算法，并且也会 “stop the world”</li>
<li>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1. 5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</li>
<li>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</li>
</ul>
</blockquote>
<p>CMS 垃圾回收器的执行过程如下：</p>
<p><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829134936398.png" alt="" loading="lazy"><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a36.jpg" alt="" loading="lazy"></p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a37.png" class="" loading="lazy">
<p>主要有<strong>初始标记，并发标记，重新标记，并发清理</strong>。刚要扔的时候又有别的指向过来了，又不能扔了。</p>
<p>其实不只这四个阶段，中间还有一些其他操作，如预清理、concurrent Abortable Preclean</p>
<h5 id="①初始化标记"><a class="header-anchor" href="#①初始化标记">¶</a><strong>①初始化标记</strong></h5>
<p><strong>初始化标记</strong>（CMS-initial-mark）：标记根对象 root，会导致<code>stw</code>，但因为<strong>只标记根对象和从年轻代顺过来的对象</strong>，所以 stw 很短。一旦标记完成之后就会恢复之前被暂停的所有应用线程。</p>
<ul>
<li>标记老年代中所有的 GC Roots 对象，如下图节点 1；</li>
<li>标记年轻代中活着的对象引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点 2、3；</li>
</ul>
<p><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-b7decc099979b0ef.png" alt="" loading="lazy"><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/2184951-4eb4f86a4db07c72.png" alt="" loading="lazy"></p>
<h5 id="根对象"><a class="header-anchor" href="#根对象">¶</a>根对象</h5>
<ul>
<li>在 Java 语言里，可作为 GC Roots 对象的包括如下几种：
<ol>
<li>虚拟机栈 (栈桢中的本地变量表) 中的引用的对象 ；</li>
<li>方法区中的类静态属性引用的对象 ；</li>
<li>方法区中的常量引用的对象 ；</li>
<li>本地方法栈中 JNI 的引用的对象；<br>
ps：为了加快此阶段处理速度，减少停顿时间，可以开启初始标记并行化，<code>-XX:+CMSParallelInitialMarkEnabled</code>，同时调大并行标记的线程数，线程数不要超过 cpu 的核数。</li>
</ol>
</li>
</ul>
<h5 id="②并发标记"><a class="header-anchor" href="#②并发标记">¶</a>②并发标记</h5>
<ul>
<li><strong>并发标记</strong>（CMS-concurrent-mark）：与用户线程同时运行；<strong>捋着一部分根对象</strong>，进行一部分标记。从 GC Roots 的 直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>遍历 InitialMarking 阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。</strong>
<ul>
<li>因为该阶段并发执行的，在运行期间<strong>可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等</strong>，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。（总结为新到老年代的）</li>
<li>为了提高重新标记的效率，<strong>该阶段会把上述对象所在的 Card 标识为 Dirty，后续只需扫描这些 Dirty Card 的对象，避免扫描整个老年代</strong>。（注：始终不会遍历整个老年代，只遍历其中的 dirty。而且刚开始的时候都是从 gc root 和年轻代顺过来的。在并发标记过程中可能有年轻代晋升到老年代的情况，我们就直接标记为 dirty，这样我们就能顺着我们已经知道的全找到老年代对象，而不是遍历老年代所有）</li>
<li>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/2184951-c1622c7b27675950.png" class="" loading="lazy">
</li>
<li>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/a38.png" class="" loading="lazy">
</li>
<li>并发标记时并不是老年代所有存活对象都会被标记，因为在标记期间用户的程序可能会改变一些引用。比如 3 那么那个节点断开了</li>
</ul>
</li>
</ul>
<p>预清理：</p>
<ul>
<li>
<p>预清理（CMS-concurrent-preclean）：预用户线程同时运行；前一个阶段已经说明，不能标记出老年代全部的存活对象，是因为标记的同时应用程序会改变一些对象引用，这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为 Dirty 的 Card</p>
<ul>
<li>如下图所示，在并发清理阶段，节点 3 的引用指向了 6；则会把节点 3 的 card 标记为 Dirty</li>
</ul>
</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-2d308c6f85c9ee53.png" class="" loading="lazy">
<ul>
<li>
<p>最后将 6 标记为存活, 如下图所示：在预清理阶段，那些从 dirty 对象可达的对象也会被标记，这个标记做完之后，dirty card 标记就会被清除了</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-381bc3a45bc4d46d.png" class="" loading="lazy">
</li>
</ul>
<p>Concurrent Abortable Preclean：</p>
<p>这也是一个并发阶段，但是同样不会影响用户的应用线程</p>
<p>这个阶段是为了尽量承担 STW 中最终标记阶段的工作。这个阶段持续时间依赖于很多的因素，由于这个阶段是在重复做很多相同的工作，直接满足一些条件（比如：重复迭代的次数、完成的工作量或者时钟时间等）</p>
<h5 id="③重新标记"><a class="header-anchor" href="#③重新标记">¶</a>③重新标记</h5>
<blockquote>
<p>想象一下下面这个情形：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b1.png" class="" loading="lazy">
<p>A 对象已经处理过， 但是 B 对象正在处理中。在并发标记阶段，与此同时用户线程正在执行，</p>
<p>现在用户标记完与 A 相关的对象了，而 B 对象原来引用的 C 现在不引用 C 了，但 A（的属性）又引用到了 C。</p>
<p>但是与 A 相关的对象已经标记过了，不会再标记了，系统就会认为 C 没有被其他对象引用，会被垃圾回收。</p>
<p>为了避免这种情况，就需要暂停所有的用户线程，重新扫描一遍全部对象，这样就能扫描到 C 被 A 引用了。</p>
<p>因为这个阶段中大多数对象已经在并发标记阶段标记过了，所以只需重新标记像 C 这种对象，所以 stw 很短。</p>
<p>此外，当 C 被其他对象引用时，JVM 就会给 C 加入写屏障，写屏障的代码就会被执行，C 就会被加入到队列中，把 C 变成灰色，即还没标记完的对象。并发标记结束后，重新标记时就会从队列中取出对象进行检查，发现是灰色的话，进一步处理标记</p>
</blockquote>
<ul>
<li>
<p><strong>重新标记</strong>（CMS-remark）：会导致<code>stw</code>，重新标记的内存范围是<strong>整个堆</strong>，包含<code>_young_gen</code>和<code>_old_gen</code>，只标记上个阶段标记错误的，也很快；（最终标记，为什么要标记两次呢？因为前面<strong>并发标记</strong>的时候也有程序正在运行，应用程序也在不断地申请内存空间，有可能会有新对象，也可能会有垃圾，所以需要二次标记）。这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li>
<blockquote>
<p>这个阶段会导致第二次 stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。由于之前的阶段是并发执行的，gc 线程可能跟不上应用程序的变化，为了完成标记老年代所有存活对象的目标，STW 就非常有必要了。</p>
<p>通过 CMS 的重新标记阶段会在年轻代尽可能感觉的时候运行，目的是为了减少连续 STW 发生的可能性（年轻代存活对象过多的话，也会导致老年代涉及的存活对象会很多）。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>这个阶段，为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做 CMS 的 “gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作 “GC ROOTS”: 当此阶段耗时较长的时候，可以加入参数<code>-XX:+CMSScavengeBeforeRemark</code>，<strong>在重新标记之前，先执行一次 young gc，回收掉年轻带的对象无用的对象</strong>，并将对象放入幸存区或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存区非常小，这大大减少了扫描时间。<br>
由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻代的对象对老年代的引用已经发生了很多改变，这个时候，remark 阶段要花很多时间处理这些改变，会导致很长 stop the word，所以通常 CMS 尽量运行 Final Remark 阶段在年轻代是足够干净的时候。<br>
另外，还可以开启并行收集：-XX:+CMSParallelRemarkEnabled。</p>
</blockquote>
<ul>
<li>
<p>并发标记阶段还可能产生其他新的引用关系如下：</p>
<ul>
<li>老年代的新对象被 GC Roots 引用</li>
<li>老年代的未标记对象被新生代对象引用</li>
<li>老年代已标记的对象增加新引用指向老年代其它对象</li>
<li>新生代对象指向老年代引用被删除</li>
<li>也许还有其它情况…</li>
</ul>
</li>
<li>
<p>上述对象中可能有一些已经在 Precleaning 阶段和 AbortablePreclean 阶段被处理过，但总存在没来得及处理的，所以还有进行如下的处理：</p>
<ul>
<li>遍历新生代对象，重新标记</li>
<li>根据 GC Roots，重新标记</li>
<li>遍历老年代的 Dirty Card，重新标记，这里的 Dirty Card 大部分已经在 clean 阶段处理过</li>
</ul>
</li>
</ul>
<p>经历过上面 5 个阶段之后，老年代所有存活对象都被标记过了，现在可能通过清除算法去清理那么老年代不再使用的对象。</p>
<h5 id="④并发清除"><a class="header-anchor" href="#④并发清除">¶</a>④并发清除</h5>
<ul>
<li>并发清除（CMS-concurrent-sweep）：与用户线程同时运行；此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
<li>调整堆大小：设置 CMS 在清理之后进行内存压缩，目的是清理内存中的碎片；</li>
<li>并发重置状态等待下次 CMS 的触发（CMS-concurrent-reset），与用户线程同时运行；</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/11963487-381bc3a45bc4d46d-1615736853651.png" class="" loading="lazy">
<p>清理过后老年代只剩下 123456</p>
<h5 id="CMS-缺点"><a class="header-anchor" href="#CMS-缺点">¶</a>CMS 缺点</h5>
<p>他的缺点是<strong>当碎片特别多的时候会采取极端的方式用 Serial Old 把年老代清理一遍</strong> (CMS 运行期间预留的内存无法满足程序需要，就出现 Cocurrent Mode Failure，启动 Serial Old)。所以任何一个 jdk 默认的垃圾回收器都不是 CMS。</p>
<ul>
<li>CMS 收集器对 CPU 资源非常敏感</li>
<li>由于并发进行，CMS 在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS 必须要在老年代堆内存用尽之前完成垃圾回收，否则 CMS 回收失败时，将触发担保机制，串行老年代收集器将会以 STW 的方式进行一次 GC，从而造成较大停顿时间；</li>
<li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS 也提供了参数<code>-XX:CMSFullGCsBeForeCompaction</code>(默认 0，即每次都进行内存整理) 来指定多少次 CMS 收集之后，进行一次压缩的 Full GC。</li>
<li>CMS 收集器无法处理<strong>浮动垃圾</strong>（Floating Garbage），可能出现 “Concurrnet Mode Failure&quot; 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太快，可以适当调高参数 - XX:CMSInitiating OccupancyFrac 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。要是 CMS 运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启用 Seriat Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数 - XX:CMSInitiatingOccupancyFraction 设置得太高很容易导致大量“Concurrent Mode Failure” 失败，性能反而降低。</li>
<li>收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次 Full GC.M 收集器提供了一个 - XX:+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在 CMS 收集器顶 Full 不住要进行 GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
</ul>
<blockquote>
<p>并发标记清除 (CMS) 是以关注低延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用 STW 式的并行收集，老年代回收采用 CMS 进行垃圾回收，对延迟的关注也主要体现在老年代 CMS 上。</p>
<p>年轻代 ParNew 与并行收集器类似，而老年代 CMS 每个收集周期都要经历：<strong>初始标记、并发标记、重新标记、并发清除</strong>。其中，初始标记以 STW 的方式标记所有的根对象；并发标记则同应用线程一起并行，标记出根对象的可达路径；在进行垃圾回收前，CMS 再以一个 STW 进行重新标记，标记那些由 mutator 线程 (指引起数据变化的线程，即应用线程) 修改而可能错过的可达对象；最后得到的不可达对象将在并发清除阶段进行回收。<strong>值得注意的是，初始标记和重新标记都已优化为多线程执行</strong>。CMS 非常适合堆内存大、CPU 核数多的服务器端应用，也是 G1 出现之前大型应用的首选收集器。</p>
<p>年轻代为什么不用 cms：年轻代复制算法更好</p>
<ol>
<li>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
</li>
<li>
<p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和重新标记这两个阶段中仍然需要执行 “Stop 一 the 一 World” 机制暂停程序中的工作线程，不过暂停时间并不会太长。</p>
</li>
<li>
<p>因此可以说明目前所有的垃圾收集器都做不到完全不需要 “Stop 一 the 一 World”，只是尽可能地缩短暂停时间。</p>
</li>
<li>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial 0ld 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
</ol>
<p>5.CMS 收集器的垃圾收集算法采用的是标记 - 清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。</p>
<p>那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer） 技术，而只能够选择空闲列表（Free List） 执行内存分配。</p>
<p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact 呢？</strong><br>
答案其实很简答，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合 “Stop the World” 这种场景”下使用。</p>
<ul>
<li>1）会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 Full GC。</li>
<li>2） CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li>3） CMS 收集器无法处理<strong>浮动垃圾</strong>。可能出现 “Concurrent Mode Failure&quot; 失败而导致另一次 Full GC 的产生。</li>
<li>浮动垃圾：在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li>
<li>CMS GC 线程建议设置为总 CPU 数的 1/4</li>
</ul>
<p><code>-XX:CMSInitiatingOccupantFraction</code>默认 92% 时开始 CMS GC</p>
</blockquote>
<h5 id="3-3-1-cms-测试"><a class="header-anchor" href="#3-3-1-cms-测试">¶</a>3.3.1 cms 测试</h5>
<blockquote>
<p>#设置启动参数<br>
‐XX:+UseConcMarkSweepGC ‐XX:+PrintGCDetails ‐Xms16m ‐Xmx16m</p>
<pre class="line-numbers language-none"><code class="language-none">#运行日志

[GC (Allocation Failure) [ParNew: 4416K-&gt;512K(4928K), 0.0074759 secs] 4416K-&gt;1859K(15872K), 0.0075204 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] 
#第一步，初始标记

[GC (CMS Initial Mark) [1 CMS-initial-mark: 6160K(10944K)] 6759K(15872K), 0.0004109 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] 
#第二步，并发标记

[CMS-concurrent-mark-start]
[CMS-concurrent-mark: 0.003&#x2F;0.003 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] 

#第三步，预处理

[CMS-concurrent-preclean-start]
[CMS-concurrent-preclean: 0.000&#x2F;0.000 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]

#第四步，重新标记

[GC (CMS Final Remark) [YG occupancy: 687 K (4928 K)][Rescan (parallel) , 0.0001925 secs][weak refs processing, 0.0000504 secs][class unloading, 0.0002354 secs][scrub symbol table, 0.0004174 secs][scrub string table, 0.0001073 secs][1 CMS-remark: 6160K(10944K)] 6847K(15872K), 0.0010680 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] 
#第五步，并发清理

[CMS-concurrent-sweep-start]
[CMS-concurrent-sweep: 0.003&#x2F;0.003 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] 

#第六步，重置
[CMS-concurrent-reset-start]
[CMS-concurrent-reset: 0.000&#x2F;0.000 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>由以上日志信息，可以看出 CMS 执行的过程。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b2.jpg" class="" loading="lazy">
<blockquote>
<p>场景：订单。虽然有垃圾，但是最后 1s 提交的还不是垃圾，此时并不是放入 s0，而是因为大对象直接放入了老年代。然后老年代太满了就触发 full gc，stw 时间更长。此时把 survivor 区调大即可</p>
</blockquote>
<h2 id="3-4-G1垃圾收集器"><a class="header-anchor" href="#3-4-G1垃圾收集器">¶</a>3.4 <code>G1</code>垃圾收集器</h2>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b3.jpg" class="" loading="lazy">
<p>G1(Garbage First)。G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。</p>
<ul>
<li>JDK6U14 体验</li>
<li>jdk1.7 默认垃圾收集器 Parallel Scavenge（新生代）+Parallel Old（老年代）。JDK7U4 官方支持 G1</li>
<li>jdk1.8 默认垃圾收集器 Parallel Scavenge（新生代）+Parallel Old（老年代）简称 PS PO。分布式锁续期时是不建议的，用 g1。<code>-XX:+UseG1GC</code></li>
<li>jdk1.9 默认垃圾收集器 G1</li>
</ul>
<p>适用场景：</p>
<ul>
<li>同时注重吞吐量和<strong>低延迟</strong>，默认暂停目标为 200ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的 region</li>
<li>整体上是标记 + 整体算法，两个区域之间是复制算法</li>
<li>官方给 G1 设定的目标是：在延迟可控的情况下获得尽可能高的吞吐量。“全功能收集器”</li>
</ul>
<blockquote>
<p><code>-XX:+UseG1GC</code></p>
<p><code>-XX:+PrintCommandLineFlagsjvm</code>参数可查看默认设置收集器类型</p>
<p><code>-XX:+PrintGCDetails</code>亦可通过打印的 GC 日志的新生代、老年代名称判断</p>
<ul>
<li>-XX:G1HeapRegionSize=size</li>
<li>-XX:MaxGCPauseMillis=time</li>
</ul>
</blockquote>
<p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三部即可完成调优：</p>
<ol>
<li>第一步，开启 G1 垃圾收集器</li>
<li>第二步，设置堆的最大内存</li>
<li>第三步，设置最大的停顿时间</li>
</ol>
<p>G1 中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<h4 id="3-4-1-原理"><a class="header-anchor" href="#3-4-1-原理">¶</a>3.4.1 原理</h4>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aef0f4765098">https://www.jianshu.com/p/aef0f4765098</a></p>
<p>G1 垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region）, 这些区域中包含了又逻辑上的年轻代、老年代区域。</p>
<p>G1 采用了分区 (Region) 的思路，将整个堆空间分成若干个大小相等的内存区域，每个 region 可以是年轻代、老年代的一个，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1 并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小 (1MB~32MB，且必须是 2 的幂)，默认将整堆划分为 2048 个分区。</p>
<blockquote>
<p>卡片：在每个分区内部又被分成了若干个大小为 512 Byte 卡片 (Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table) 中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见 RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
</blockquote>
<p>这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代的内存是否足够</p>
<p><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829142240241.png" alt="" loading="lazy"><img src="JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829142257572.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>比如将 Eden 小块拷贝到了某个 Survivor 小块，此时原来 Eden 区就可以放其他内容了。垃圾回收 + 内存压缩。</p>
</li>
<li>
<p>E</p>
</li>
<li>
<p>S</p>
</li>
<li>
<p>O</p>
</li>
<li>
<p>H：Humongous 区域（巨型对象），如果一个对象占用的空间超过了分区容量的 50% 以上，G1 收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。</p>
</li>
<li>
<blockquote>
<p>每一个分配的 Region，都可以分成两个部分，已分配的和未被分配的。它们之间的界限被称为 top。总体上来说，把一个对象分配到 Region 内，只需要简单增加 top 的值。这个做法实际上就是 bump-the-pointer。过程如下：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b4.png" class="" loading="lazy">
<p>Region 可以说是 G1 回收器一次回收的最小单元。即每一次回收都是回收 N 个 Region。这个 N 是多少，主要受到 G1 回收的效率和用户设置的软实时目标有关。每一次的回收，G1 会选择可能回收最多垃圾的 Region 进行回收。与此同时，G1 回收器会维护一个空间 Region 的链表。每次回收之后的 Region 都会被加入到这个链表中。<br>
每一次都只有一个 Region 处于被分配的状态中，被称为 current region。在多线程的情况下，这会带来并发的问题。G1 回收器采用和 CMS 一样的 TLABs 的手段。即为每一个线程分配一个 Buffer，线程分配内存就在这个 Buffer 内分配。但是当线程耗尽了自己的 Buffer 之后，需要申请新的 Buffer。这个时候依然会带来并发的问题。G1 回收器采用的是 CAS（Compate And Swap）操作。</p>
<blockquote>
<p>为线程分配 Buffer 的过程大概是：</p>
<ol>
<li>记录 top 值；</li>
<li>准备分配；</li>
<li>比较记录的 top 值和现在的 top 值，如果一样，则执行分配，并且更新 top 的值；否则，重复 1；</li>
</ol>
</blockquote>
<p>显然的，采用 TLABs 的技术，就会带来碎片。举例来说，当一个线程在自己的 Buffer 里面分配的时候，虽然 Buffer 里面还有剩余的空间，但是却因为分配的对象过大以至于这些空闲空间无法容纳，此时线程只能去申请新的 Buffer，而原来的 Buffer 中的空闲空间就被浪费了。Buffer 的大小和线程数量都会影响这些碎片的多寡。</p>
</blockquote>
</li>
</ul>
<p>G1 的设计目标</p>
<ul>
<li>与应用线程同时关注，几乎不需要 STW(与 CMS 类似)</li>
<li>整理剩余空间，不产生内存碎片（CMS 只能在 Full GC 时，用 STW 整理内存碎片）</li>
<li>GC 停顿更加可控</li>
<li>不牺牲系统的吞吐量</li>
<li>gc 不需要额外的内存空间（CMS 需要预留空间存储浮动垃圾）</li>
</ul>
<p>在 G1 划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活的对象拷贝到老年代或者 Survivor 空间，G1 收集器通过将对象从一个区域复制到另一个区域，完成了清理工作。</p>
<p>这也就意味着，在正常的处理过程中，G1 完成了堆的压缩（至少是部分堆的压缩），这样也就不会有 cms 内存碎片问题的存在了。</p>
<blockquote>
<p>吞吐量：吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量。</p>
<p>对于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力，单词快速的响应并不值得考虑</p>
</blockquote>
<p>G1 GC 有计划第避免在整个 java 堆中进行全区域的垃圾收集。G1 收集各个 region 里面的垃圾堆积的价值大小（回收锁获得的空间大小自己回收所需使劲的经验值），后后台维护一下优先列表，每次根据允许的手机时间，优先回收价值最大的 region</p>
<p>由于这种方式的侧重点在于回收最大量的空间，所以 G1 叫垃圾优先</p>
<p>无需回收整个堆，而是选择一个 Collection Set (CS)</p>
<p>两种 GC：</p>
<ul>
<li>Fully young GC</li>
<li>Mixed GC</li>
</ul>
<p>估计每个 region 中的垃圾比例，优先回收垃圾多的 region</p>
<p>问题：老年代对象可能持有年轻代的引用（跨代引用）</p>
<p>不同的 region 间互相引用</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819011849.png" class="" loading="lazy">
<p>我们想要知道这个 region 外的哪些对象引用了要回收的 region 的。有下面两种机制</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819135645.png" class="" loading="lazy">
<h4 id="3-4-2-Young-GC"><a class="header-anchor" href="#3-4-2-Young-GC">¶</a>3.4.2 <code>Young GC</code></h4>
<ul>
<li>
<p>触发时机：<strong>Eden 空间满时会被触发</strong>。</p>
</li>
<li>
<p>针对区域：Young GC 主要是对 Eden 区进行 GC</p>
</li>
<li>
<p>初始标记</p>
</li>
<li>
<p>Eden 空间的数据移动到 Survivor 空间中，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到年老代空间。</p>
</li>
<li>
<p>Survivor 区的数据移动到新的 Survivor 区中，也有部分数据晋升到老年代空间中。</p>
</li>
<li>
<p>最终 Eden 空间的数据为空，GC 停止工作，应用线程继续执行。</p>
</li>
<li>
<p>E 到 S 有 STW，时间短</p>
</li>
</ul>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819135817.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829145909560.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/201908291459186.png" class="" loading="lazy">
<p>在引用变更时通过 post-write barrier + dirty card queue<br>
concurrent refinement threads 更新 Remembered Set</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819011727.png" class="" loading="lazy">
<h5 id="3-4-2-1-Remembered-Set（已记忆集合）"><a class="header-anchor" href="#3-4-2-1-Remembered-Set（已记忆集合）">¶</a>3.4.2.1 <strong>Remembered Set（已记忆集合）</strong></h5>
<p>在 GC 年轻代的对象时，我们 ** 如何找到年轻代中对象的根对象 ** 呢？（即 A 引用了 B，我们有 B，如何知道谁引用 B）</p>
<p>根对象可能是在年轻代中，也可能在老年代中，那么老年代中的所有对象都是根对象吗？</p>
<p>如果全量扫描老年代，那么这样扫描下来会耗费大量的时间。</p>
<p><strong>已记忆集合 RSet</strong>：于是，G1 引进了 RSet 的概念。它的全称是 Remembered Set，每个 Region 初始化时，会初始化一个 RSet，该集合用来记录并跟踪其他 Region 指向本 Region 中对象的引用，每个 Region 默认按照每 512kb 划分成多个 Card，所以 RSet 需要记录的东西应该是 xx Region 的 xx Card。</p>
<p>比如本 region1 的 card 引用了别的 region2 内容，那么就把该 card 记录在别的 region2 里的 Remember Set 里，回收 region2 的时候就可以发现 region1 的引用了。</p>
<p>Reset 的价值在于使得垃圾回收器不需要扫描整个堆就能找到谁引用了当前分区中的对象，只需要扫描 RSet 即可。</p>
<blockquote>
<p>G1 gc 是在 points-out 的 card table 之上再加了一层结构来构成 points-into RSet: 每个 region 会记录下到底哪些别的 region 有指向自己的指针, 而这些指针分别在哪些 card 的范围内</p>
<p>这个 RSet 其实是一个 hash table,key 是别的 region 的起始地址, value 是一个集合, 里面的元素是 card table 的 index。举例来说, 如果 region A 的 RSet 里有一项的 key 是 region B ,value 里有 index 为 1234 的 card, 它的意思就是 region B 的个 card 里有引用指向 region A。所以对 fregion A 来说, 该 RSe 记录的是 points-into 的关系; 而 card table 仍然记录了 points-out 的关系。</p>
<p>Snapshot-At-The-Beginning(SATB) 是 GC GC 在并发标记阶段使用的增量式的标记算法</p>
</blockquote>
<p>如果 card 改变了，比如从 null 赋值成值了，就在 card table 里标记为 dirty，这样 Rset 就可以指向卡表里对应的一个 entry。</p>
<p>如图，region1 和 region3 中的对象都引用了 region2 中的对象，因此 region2 中的 rset 中记录了这两个引用</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829150653481.png" class="" loading="lazy">
<p><strong>Young Collection 跨代引用</strong><br>
新生代回收的跨代引用（老年代引用新生代）问题</p>
<p>新生代的根对象有一部分来自老年代，这时如果遍历老年代很耗时，所以使用 card table，如果老年代对象引用了新生代对象，就把老年代 card table 这块标记为 dirty card。这样就不要找整个老年代了，减少搜索范围。下面粉色的是脏卡区。而 E 也知道有哪些脏卡引用它，记录在 remember set 中</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200819144217.png" class="" loading="lazy">
<p>在引用变更时通过 post-write barrier 写屏障 + dirty card queue<br>
concurrent refinement threads 更新 Remembered Set</p>
<h4 id="3-4-3-Young-GC-ConMark"><a class="header-anchor" href="#3-4-3-Young-GC-ConMark">¶</a>3.4.3 <code>Young GC+ConMark</code></h4>
<ul>
<li>在 Young GC 时会进行 GC Root 的<strong>初始标记</strong>
<ul>
<li>初始标记是找到根对象，并发标记是顺着根对象找到其他对象。初始标记是新生代 GC 时发生，<strong>并发标记是老年代占用比例达到阈值时</strong></li>
</ul>
</li>
<li>触发时机：老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），阈值由<code>-XX:InitialingHeapOccupancyPercent=percent</code>控制，默认 45%</li>
</ul>
<p><img src="https://fermhan.oss-cn-qingdao.aliyuncs.com/img/20200819135913.png" alt="" loading="lazy"></p>
<h4 id="3-4-3-Mixed-GC"><a class="header-anchor" href="#3-4-3-Mixed-GC">¶</a>3.4.3 <code>Mixed GC</code></h4>
<p>当越来越多的对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region，这里需要注意：是一部分老年代（回收价值高的，这也是为什么叫 g1 的原因 ），而不是全部老年代，可以选择哪些 old region 进行收集，从而可以对垃圾回收的耗时时间进行控制，根据的是最大暂停时间。也要注意的是 Mixed GC 并不是 Full GC。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20200910150955.png" class="" loading="lazy">
<ul>
<li>会对 E、S、O 进行全面垃圾回收</li>
<li>重新标记 remark 会 STW</li>
<li>拷贝存活会 STW</li>
<li>G1 根据暂停时间有选择地回收，找回收价值高的</li>
</ul>
<p>MixedGC 什么时候触发？由参数<code>-XX:InitiatingHeapOccupancyPercent=n</code>决定。默认：45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阈值时触发。</p>
<p>它的 GC 步骤分 2 步：</p>
<ul>
<li>全局并发标记（global concurrent marking）</li>
<li>拷贝存活对象（evacuation）</li>
</ul>
<p><strong>3.4.3.1 全局并发标记</strong></p>
<p>全局并发标记，执行过程分为五个步骤：</p>
<ul>
<li>1 初始标记（initial mark，STW）</li>
</ul>
<p>标记从根节点直接可达的对象，这个阶段会执行一次年轻代 GC，会产生全局停顿 stw。</p>
<ul>
<li>2 根区域扫描（root region scan）</li>
</ul>
<p>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。</p>
<p>该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</p>
<ul>
<li>3 并发标记（Concurrent Marking）</li>
</ul>
<p>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断。</p>
<ul>
<li>4 重新标记（Remark，STW）</li>
</ul>
<p>该阶段是 STW 回收，因为程序在运行，针对上一次的标记进行修正。</p>
<ul>
<li>5 清除垃圾（Cleanup，STW）</li>
</ul>
<p>清点和重置标记状态，该阶段会 STW，这个阶段并不会实际上去做垃圾的收集，等待 evacuation 阶段来回收。</p>
<p><strong>3.4.3.2 拷贝存活对象</strong></p>
<p>Evacuation 阶段是 STW 的。该阶段把一部分 Region 里的活对象拷贝到另一部分 Region 中，从而实现垃圾的回收清理。</p>
<h5 id="Full-GC："><a class="header-anchor" href="#Full-GC：">¶</a>Full GC：</h5>
<blockquote>
<p>SerialGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<p>ParallelGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<p>CMS</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足：
<ul>
<li>垃圾回收速度跟不上垃圾产生速度时，并发收集失败，此时 CMS 会退化为串行收集，</li>
</ul>
</li>
</ul>
<p>G1</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>触发时机：老年代与整个堆占比达到阈值 45%，触发并发标记及混合收集。如果并发收集比垃圾产生快，这时还不叫 full GC。但也会有重标记、拷贝的过程，暂停时间短</li>
<li>重新标记后的筛选回收：<strong>筛选回收 (stop the world 事件 根据用户期望的 GC 停顿时间回收)(注意：CMS 在这一步不需要 stop the world)（阿里问为何停顿时间可以设置，参考：</strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/8663872.html">G1 垃圾收集器架构和如何做到可预测的停顿 (阿里)</a><strong>）</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-4-4-G1-收集器相关参数"><a class="header-anchor" href="#3-4-4-G1-收集器相关参数">¶</a>3.4.4 G1 收集器相关参数</h4>
<ul>
<li>
<p><code>-XX:+UseG1GC</code></p>
<p>使用 G1 垃圾收集器</p>
</li>
<li>
<p><code>-XX:MaxGCPauseMillis</code></p>
<p>设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到），默认值是 200 毫秒。尽可能保证回收时间小于 200ms。</p>
</li>
<li>
<p><code>-XX:G1HeapRegionSize=n</code></p>
<p>设置的 G1 区域的大小（每个小块多大）。值是 2 的幂，范围是 1MB 到 32MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p>
<p>默认是堆内存的 1/2000。</p>
</li>
<li>
<p><code>-XX:ParallelGCThreads=n</code></p>
<p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p>
</li>
<li>
<p><code>-XX:ConcGCThreads=n</code></p>
<p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</p>
</li>
<li>
<p><code>-XX:InitiatingHeapOccupanyPercent=n</code></p>
</li>
</ul>
<p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p>
<h4 id="3-4-5-测试"><a class="header-anchor" href="#3-4-5-测试">¶</a>3.4.5 测试</h4>
<blockquote>
<p>-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:+PrintGCDetails -Xmx16m</p>
<pre class="line-numbers language-none"><code class="language-none">#日志

[GC pause (G1 Evacuation Pause) (young), 0.0046811 secs]
[Parallel Time: 3.7 ms, GC Workers: 4]
[GC Worker Start (ms): Min: 156.2, Avg: 158.1, Max: 159.6, Diff: 3.4]

#扫描根节点
[Ext Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.4, Diff: 0.4, Sum: 0.4]

#更新RS区域所消耗的时间
[Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
  [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]

#对象拷贝
[Object Copy (ms): Min: 0.0, Avg: 1.4, Max: 3.0, Diff: 3.0, Sum: 5.4]
[Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.3, Sum: 0.4]
  [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
[GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
[GC Worker Total (ms): Min: 0.0, Avg: 1.6, Max: 3.4, Diff: 3.4, Sum: 6.3]
[GC Worker End (ms): Min: 159.6, Avg: 159.7, Max: 159.9, Diff: 0.3]
[Code Root Fixup: 0.0 ms]
[Code Root Purge: 0.0 ms]
[Clear CT: 0.0 ms] #清空CardTable
[Other: 0.9 ms]
[Choose CSet: 0.0 ms]  #选取CSet
[Ref Proc: 0.9 ms] #弱引用、软引用的处理耗时
[Ref Enq: 0.0 ms]  #弱引用、软引用的入队耗时
[Redirty Cards: 0.0 ms]
[Humongous Register: 0.0 ms] #大对象区域注册耗时
[Humongous Reclaim: 0.0 ms]  #大对象区域回收耗时
[Free CSet: 0.0 ms]

#年轻代的大小统计
[Eden: 6144.0K(6144.0K)-&gt;0.0B(5120.0K) Survivors: 0.0B-&gt;1024.0K Heap: 6144.0K(16.0M)-&gt;2791.0K(16.0M)]
[Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<h4 id="3-4-6-对于-G1-垃圾收集器的优化建议"><a class="header-anchor" href="#3-4-6-对于-G1-垃圾收集器的优化建议">¶</a>3.4.6 对于 G1 垃圾收集器的优化建议</h4>
<ul>
<li>
<p>年轻代大小</p>
<ul>
<li>避免使用 - Xmn 选项或 - XX:NewRatio 等其他相关选项显示设置年轻代大小。</li>
<li>固定年轻代的大小会覆盖暂停时间目标。</li>
</ul>
</li>
<li>
<p>暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间。</li>
<li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。</li>
</ul>
</li>
</ul>
<h3 id="G1-新功能"><a class="header-anchor" href="#G1-新功能">¶</a>G1 新功能</h3>
<ol>
<li>JDK 8u20 字符串去重。</li>
</ol>
<p>开启：<code>-XX:+UseStringDeduplication</code></p>
<p>优点：节省大量内存<br>
缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p>
<pre class="line-numbers language-none"><code class="language-none">String s1 &#x3D; new String(&quot;hello&quot;); &#x2F;&#x2F; char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;
String s2 &#x3D; new String(&quot;hello&quot;); &#x2F;&#x2F; char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>G1 会将所有新分配的字符串放入一个队列。当新生代回收时，G1 并发检查队列中是否有字符串重复。如果它们值一样，让它们引用同一个 char[]</p>
<p>注意，与 String.intern() 不一样，String.intern() 关注的是字符串对象，而字符串去重关注的是 char[]<br>
在 JVM 内部，使用了不同的字符串表</p>
<ol start="2">
<li>JDK 8u40 并发标记类卸载</li>
</ol>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，占用着内存也很浪费内存。</p>
<p>当一个<strong>类加载器的所有类</strong>都不再使用，则卸载它所加载的所有类 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p>
<ol start="3">
<li>JDK 8u60 回收巨型对象</li>
</ol>
<p>巨型对象：一个对象大于 region 的一半的对象。</p>
<p>如下，巨型对象可能占用多个 region</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b5.png" class="" loading="lazy">
<p>老年代的对象引用了巨型对象的话该老年代对象的卡表会被标记为脏的。当某个巨型对象从老年代的引用为 0 时，他就可以在新生代的垃圾回收时被回收掉。这是为了巨型对象越早回收越好。</p>
<p>G1 不会对巨型对象进行拷贝<br>
G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p>
<ol start="4">
<li>JDK 9 并发标记起始时间的调整</li>
</ol>
<p>并发标记必须在堆空间占满前完成，否则退化为 FullGC<br>
JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent<br>
JDK 9 可以动态调整 -XX:InitiatingHeapOccupancyPercent 用来设置初始值<br>
进行数据采样并动态调整<br>
总会添加一个安全的空档空间</p>
<h3 id="垃圾回收调优"><a class="header-anchor" href="#垃圾回收调优">¶</a>垃圾回收调优</h3>
<p>5.1 调优领域</p>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<p>5.2 确定目标<br>
【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<ul>
<li>低延迟：CMS ，G1，ZGC</li>
<li>高吞吐量：ParallelGC</li>
<li>Zing</li>
</ul>
<p>5.3 最快的 GC</p>
<p>低延迟</p>
<p>查看 FullGC 前后的内存占用，考虑下面几个问题<br>
数据是不是太多？<br>
resultSet = statement.executeQuery(“select * from 大表 limit n”) 查大表前查出来很占内存，所以用法 limit 限制一下<br>
数据表示是否太臃肿？<br>
对象图<br>
对象大小 16 Integer 24 int 4<br>
是否存在内存泄漏？<br>
static Map map =<br>
软、弱<br>
第三方缓存实现</p>
<p>5.4 新生代调优<br>
新生代的特点<br>
所有的 new 操作的内存分配非常廉价<br>
TLAB thread-local allocation buffer<br>
死亡对象的回收代价是零<br>
大部分对象用过即死<br>
Minor GC 的时间远远低于 Full GC</p>
<p>越大越好吗？<br>
-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).<br>
GC is performed in this region more often than in other regions. If the size for the young<br>
generation is too small, then a lot of minor garbage collections are performed. If the size is too<br>
large, then only full garbage collections are performed, which can take a long time to complete.<br>
Oracle recommends that you keep the size for the young generation greater than 25% and less<br>
than 50% of the overall heap size.<br>
新生代能容纳所有【并发量 * (请求 - 响应)】的数据<br>
幸存区大到能保留【当前活跃对象 + 需要晋升对象】<br>
晋升阈值配置得当，让长时间存活对象尽快晋升</p>
<ul>
<li>XX:MaxTenuringThreshold=threshold</li>
<li>XX:+PrintTenuringDistribution<br>
Desired survivor size 48286924 bytes, new threshold 10 (max 10)</li>
<li>age 1: 28992024 bytes, 28992024 total</li>
<li>age 2: 1366864 bytes, 30358888 total</li>
<li>age 3: 1425912 bytes, 31784800 total<br>
…</li>
</ul>
<p>5.5 老年代调优<br>
以 CMS 为例<br>
CMS 的老年代内存越大越好<br>
先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代<br>
观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</p>
<ul>
<li>XX:CMSInitiatingOccupancyFraction=percent</li>
</ul>
<p>5.6 案例<br>
案例 1 Full GC 和 Minor GC 频繁<br>
案例 2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）<br>
案例 3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</p>
<h1>4 可视化 GC 日志分析工具</h1>
<h2 id="4-1-GC-日志输出参数"><a class="header-anchor" href="#4-1-GC-日志输出参数">¶</a>4.1 GC 日志输出参数</h2>
<p>前面通过 - XX:+PrintGCDetails 可以对 GC 日志进行打印，我们就可以在控制台查看，这样虽然可以查看到 GC 的信息，但是并不直观，可以借助于第三方的 GC 日志分析工具进行查看。</p>
<p>在日志打印输出涉及到的参数如下：</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">可选值：
‐XX:+PrintGC 输出GC日志
‐XX:+PrintGCDetails 输出GC的详细日志
‐XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
‐XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2019‐05‐04T21:53:59.234+0800）
‐XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
‐Xloggc:..&#x2F;logs&#x2F;gc.log 日志文件的输出路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>测试：</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">-XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;100 -Xmx256m 
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps 
-XX:+PrintGCDateStamps -XX:+PrintHeapAtGC 
-Xloggc:F:&#x2F;&#x2F;test&#x2F;&#x2F;gc.log
&gt;运行后就可以在F盘下生成gc.log文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<h2 id="4-2-GC-Easy-可视化工具"><a class="header-anchor" href="#4-2-GC-Easy-可视化工具">¶</a>4.2 GC Easy 可视化工具</h2>
<p>GC Easy 是一款在线的可视化工具，易用、功能强大，网站：<a target="_blank" rel="noopener" href="http://gceasy.io/">http://gceasy.io/</a></p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174548869.png" class="" loading="lazy">
<p>上传后，点击 “Analyze” 按钮，即可查看报告</p>
<p>下面是堆大小</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174604652.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174617549.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190829174625924.png" class="" loading="lazy">
<p>1_串行<br>
<code>-XX:+UseSerialGC 相当于 Serial + SerialOld</code>。复制 + 标记整理</p>
<pre class="line-numbers language-none"><code class="language-none">-XX:+UseParallelGC ~ -XX:+UseParallelOldGC（默认）
-XX:GCTimeRatio&#x3D;ratio调整垃圾回收与总时间的占比1&#x2F;1+ration
-XX:MaxGCPauseMillis&#x3D;ms
-XX:ParallelGCThreads&#x3D;n
开启一个另一个就自动开启了。
多个垃圾回收同时进行。个数等于CPU个数。垃圾回收时候CPU利用率是100%。可以指定GC线程数。调整新生代的大小。
-XX:+UserAdaptiveSizePolicy动态调整新生代大小，伊甸园和幸存区比例，晋升阈值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3_响应时间优先</p>
<pre class="line-numbers language-none"><code class="language-none">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld
-XX:ParallelGCThreads&#x3D;n ~ -XX:ConcGCThreads&#x3D;threads
-XX:CMSInitiatingOccupancyFraction&#x3D;percent
-XX:+CMSScavengeBeforeRemark

并发的，而不是并行的。 用户进程与垃圾回收进程是并发的，都会抢占CPU。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Hotspot JVM 提供多种垃圾回收器，我们需要根据具体应该的需要采用不同的回收器</p>
<p>垃圾回收器的并行和并发：</p>
<ul>
<li>并行 Parallel：指多个收集器的线程同时工作，但是用户线程处于等待状态</li>
<li>并发 concurrent：指收集器在工作的时候，可以运行用户线程工作。
<ul>
<li>并发不代表解决了 GC 停顿的问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候。但在清除垃圾的时候，用户线程可以和 GC 线程并发执行。</li>
</ul>
</li>
</ul>
<h4 id="内存泄露的经典原因"><a class="header-anchor" href="#内存泄露的经典原因">¶</a>内存泄露的经典原因</h4>
<p>Java 内存泄露的经典原因：</p>
<ul>
<li>对象定义在错误的范围（Wrong Scope）</li>
<li>异常处理不当</li>
<li>集合数据管理不当</li>
</ul>
<p>对象定义在错误的范围：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;如果Foo实例对象的声明较长，会导致临时性内存泄露（这里的names变量其实只有临时作用）
class Foo&#123;
    private String[] names;
    public void doIt(int length)&#123;
        if(names&#x3D;null || names.length&lt;length)&#123;
            names&#x3D;new String[length];
        &#125;
        popolate(names);
        print(names);
    &#125;&#x2F;&#x2F;names只在doIt这个方法中使用，没必要定义在外面，定义在外面的话Foo对象存在还会占用空间。
&#125;
&#x2F;&#x2F;JVM喜欢生命周期短的对象，这样做已经足够高效：将成员变量转换成局部变量
class Foo&#123;
    public void doIt(int length)&#123;
    String[] names&#x3D;new String([length]);
    populate(names);
    print(names);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>异常处理不当：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;错误的用法
数据库连接的关闭close应该放到finally中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>集合数据管理不当：</p>
<pre class="line-numbers language-none"><code class="language-none">当使用Array-based的数据结构（ArrayList，HashMap等）时，尽量减少resize
    比如new ArrayList时，尽量估算size，在创建的时候确定size
    减少resize可以避免没有必要的aray copying，gc碎片等问题
如果一个List只需要顺序访问，不需要随机访问，用LinkedList代替ArrayList，LinkedList是链表，不需要resize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;-verbose:gc输出详细垃圾回收日志&#x2F;&#x2F;回收前和回收后情况
&#x2F;&#x2F;-Xms20M堆初始大小
&#x2F;&#x2F;-Xmx20M堆最大大小
&#x2F;&#x2F;-Xmn10M堆新生代大小
&#x2F;&#x2F;-XX:+PrintGCDetails&#x2F;&#x2F;各个堆信息
&#x2F;&#x2F;-XX:SurvivorRatio&#x3D;8&#x2F;&#x2F;Eden8:1:1
int size&#x3D;1024*1024;&#x2F;&#x2F;1M
byte[] myAlloc1&#x3D;new byte[2*size];
byte[] myAlloc2&#x3D;new byte[2*size];
byte[] myAlloc3&#x3D;new byte[2*size];
byte[] myAlloc4&#x3D;new byte[2*size];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="5-字节码"><a class="header-anchor" href="#5-字节码">¶</a>5_字节码</h2>
<p>java 虚拟机不和包括 java 在内的任何语言绑定，它只与 “Class” 特定的二进制文件格式关联，Class 文件中包含 Java 虚拟机指令集和符号表以及若干其他辅助信息。本文将以字节码的角度来研究 Java 虚拟机。</p>
<p>字节码</p>
<ul>
<li>Java 跨平台的原因是 JVM 不跨平台</li>
<li>首先编写一个简单的 java 代码，一次为例进行讲解</li>
</ul>
<h3 id="方法的执行过程："><a class="header-anchor" href="#方法的执行过程：">¶</a>方法的执行过程：</h3>
<ul>
<li>
<p>原始 java 代码</p>
</li>
<li>
<p>编译后的字节码文件</p>
</li>
<li>
<p>常量池载入运行时常量池</p>
</li>
<li>
<p>方法字节码载入方法区</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b6.png" class="" loading="lazy">
</li>
<li>
<p>main 线程开始执行，分配栈帧内存</p>
</li>
<li>
<p>执行引擎开始执行字节码</p>
</li>
</ul>
<h6 id="测试代码-原始-java-代码"><a class="header-anchor" href="#测试代码-原始-java-代码">¶</a>测试代码 (原始 java 代码)</h6>
<pre class="line-numbers language-none"><code class="language-none">package JVMtest;

public class MyTest1&#123;
    private int a&#x3D;1;
    public int getA()&#123;
        return a;
    &#125;
    public void setA(int a)&#123;
        this.a&#x3D;a;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译生成 MyTest1.class 文件<br>
使用反编译命令：javap MyTest1 ，对文件进行反编译，生成以下数据</p>
<pre class="line-numbers language-none"><code class="language-none">Compiled from &quot;MyTest1.java&quot;
public class JVMtest.MyTest1 &#123;
  public JVMtest.MyTest1();
  public int getA();
  public void setA(int);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>增加参数，使用反编译命令：javap -c MyTest1，生成以下数据</p>
<pre class="line-numbers language-none"><code class="language-none">Compiled from &quot;MyTest1.java&quot;
public class JVMtest.MyTest1 &#123;
  public JVMtest.MyTest1();
    Code:
       0: aload_0
       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
       4: aload_0
       5: iconst_1
       6: putfield      #2                  &#x2F;&#x2F; Field a:I
       9: return

  public int getA();
    Code:
       0: aload_0
       1: getfield      #2                  &#x2F;&#x2F; Field a:I
       4: ireturn

  public void setA(int);
    Code:
       0: aload_0
       1: iload_1
       2: putfield      #2                  &#x2F;&#x2F; Field a:I
       5: return
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="javap-v-查看-二进制字节码"><a class="header-anchor" href="#javap-v-查看-二进制字节码">¶</a>javap -v 查看 (二进制字节码)</h6>
<p>使用反编译命令：<code>javap -verbose MyTest1.class</code>，生成以下数据</p>
<pre class="line-numbers language-none"><code class="language-none">javap -verbose MyTest1.class
Classfile &#x2F;F:&#x2F;JVMtest&#x2F;out&#x2F;production&#x2F;JVMtest&#x2F;JVMtest&#x2F;MyTest1.class
  Last modified 2020-3-30; size 461 bytes
  MD5 checksum f4687563763f0dcca1cd899030c582fb
  Compiled from &quot;MyTest1.java&quot;
public class JVMtest.MyTest1
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 &#x3D; Methodref          #4.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
   #2 &#x3D; Fieldref           #3.#21         &#x2F;&#x2F; JVMtest&#x2F;MyTest1.a:I
   #3 &#x3D; Class              #22            &#x2F;&#x2F; JVMtest&#x2F;MyTest1
   #4 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object
   #5 &#x3D; Utf8               a
   #6 &#x3D; Utf8               I
   #7 &#x3D; Utf8               &lt;init&gt;
   #8 &#x3D; Utf8               ()V
   #9 &#x3D; Utf8               Code
  #10 &#x3D; Utf8               LineNumberTable
  #11 &#x3D; Utf8               LocalVariableTable
  #12 &#x3D; Utf8               this
  #13 &#x3D; Utf8               LJVMtest&#x2F;MyTest1;
  #14 &#x3D; Utf8               getA
  #15 &#x3D; Utf8               ()I
  #16 &#x3D; Utf8               setA
  #17 &#x3D; Utf8               (I)V
  #18 &#x3D; Utf8               SourceFile
  #19 &#x3D; Utf8               MyTest1.java
  #20 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V
  #21 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; a:I
  #22 &#x3D; Utf8               JVMtest&#x2F;MyTest1
  #23 &#x3D; Utf8               java&#x2F;lang&#x2F;Object
&#123;
  public JVMtest.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  &#x2F;&#x2F; Field a:I
         9: return
      LineNumberTable:
        line 3: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   LJVMtest&#x2F;MyTest1;

  public int getA();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: getfield      #2                  &#x2F;&#x2F; Field a:I
         4: ireturn
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJVMtest&#x2F;MyTest1;

  public void setA(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;2
         0: aload_0
         1: iload_1
         2: putfield      #2                  &#x2F;&#x2F; Field a:I
         5: return
      LineNumberTable:
        line 9: 0
        line 10: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   LJVMtest&#x2F;MyTest1;
            0       6     1     a   I
&#125;
SourceFile: &quot;MyTest1.java&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字节码分析"><a class="header-anchor" href="#字节码分析">¶</a>字节码分析</h3>
<h5 id="常量池分析"><a class="header-anchor" href="#常量池分析">¶</a>常量池分析</h5>
<p>使用 UltraEdit 打开 MyTest1.class 二进制文件：</p>
<p>如下，00 18（即 24）代表常量池有 #1-#24 项，注意 #0 项不计入，也没有值。</p>
<p>每个常量分为 2/3 个部分，比如方法的常量格式为 u1，u2，u3</p>
<p>如下面第一个 u1=0A(十进制的 10)，根据后面常量池的表可以查到 0A 代表的是一个方法的引用，此时结构后面还跟着 2 个值，而 #4 和 #20 又对应别的常量池，最终得到 #1 代表方法的【返回值类型】和【方法名 + 参数】的常量池号，</p>
<pre class="line-numbers language-none"><code class="language-none">网站：http:&#x2F;&#x2F;www.ab126.com&#x2F;GOJU&#x2F;1711.HTML
经测试，将16进制转换为ASCII后如下，刚好是javap -verbose生成Constant pool的结果
#1 &#x3D; Methodref          #4.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
#2 &#x3D; Fieldref           #3.#21         &#x2F;&#x2F; JVMtest&#x2F;MyTest1.a:I
#3 &#x3D; Class              #22            &#x2F;&#x2F; JVMtest&#x2F;MyTest1
#4 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object

#5, 61 &#x3D;&#x3D; a
#6, 49 &#x3D;&#x3D; I
#7, 3C 69 6E 69 74 3E &#x3D;&#x3D; &lt;init&gt;
#8, 28 29 56 &#x3D;&#x3D; ()V代表无参返回值void
#9, 43 6F 64 65 &#x3D;&#x3D; Code
#10, 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 &#x3D;&#x3D; LineNumberTable
#11, 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 &#x3D;&#x3D; LocalVariableTable
#12, 74 68 69 73 &#x3D;&#x3D; this
#13, 4C 4A 56 4D 74 65 73 74 2F 4D 79 54 65 73 74 31 3B &#x3D;&#x3D; LJVMtest&#x2F;MyTest1;
#14, 67 65 74 41 &#x3D;&#x3D; getA
#15, 28 29 49 &#x3D;&#x3D; ()I代表无参返回值为int
#16, 73 65 74 41 &#x3D;&#x3D; setA
#17, 28 49 29 56 &#x3D;&#x3D; (I)V代表参数为int，返回值void
#18, 53 6F 75 72 63 65 46 69 6C 65 &#x3D;&#x3D; SourceFile
#19, 4D 79 54 65 73 74 31 2E 6A 61 76 61 &#x3D;&#x3D; MyTest1.java
##20,名称#7和类型#8
##21,名称#5和类型#6
#22, 4A 56 4D 74 65 73 74 2F 4D 79 54 65 73 74 31 &#x3D;&#x3D; JVMtest&#x2F;MyTest1
#23, 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 &#x3D;&#x3D;java&#x2F;lang&#x2F;Object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b7.png" class="" loading="lazy">
<h4 id="字节码结构"><a class="header-anchor" href="#字节码结构">¶</a>字节码结构</h4>
<ol>
<li>使用 javap -verbose MyTest 命令分析一个字节码文件时，将会分析该字节码文件的魔数，版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量的信息。</li>
</ol>
<h5 id="魔数"><a class="header-anchor" href="#魔数">¶</a>魔数</h5>
<ol start="2">
<li>魔数：所有的. class 文件的前四个字节都是魔数，魔数值为固定值：0xCAFEBABE（咖啡宝贝）</li>
</ol>
<h5 id="版本号"><a class="header-anchor" href="#版本号">¶</a>版本号</h5>
<ol start="3">
<li>版本号：魔数后面 4 个字节是版本信息，前两个字节表示 minor version（次版本号），后两个字节表示 major version（主版本号），十六进制 34 = 十进制 52。所以该文件的版本号为 1.8.0。低版本的编译器编译的字节码可以在高版本的 JVM 下运行，反过来则不行。</li>
</ol>
<h5 id="常量池-v2"><a class="header-anchor" href="#常量池-v2">¶</a>常量池</h5>
<ol start="4">
<li>
<p>常量池（constant pool）：版本号之后的就是常量池入口，一个 java 类定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是 class 文件的资源仓库，包括 java 类定义的方法和变量信息，常量池中主要存储两类常量：字面量和符号引用。字面量如文本字符串、java 中生命的 final 常量值等，符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p>
</li>
<li>
<p>常量池的整体结构：Java 类对应的常量池主要由<strong>常量池数量和常量池数组</strong>两部分共同构成，常量池数量紧跟在主版本号后面，<strong>常量池数量占据两个字节</strong>，而常量池数组在常量池数量之后。常量池数组与一般数组不同的是，常量池数组中元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个 <strong>u1 类型标志位，占据一个字节</strong>，JVM 在解析常量池时，就会根据这个 u1 类型的来获取对应的元素的具体类型。 值得注意的是，常量池数组中元素的个数 = 常量池数 - 1,（其中 0 暂时不使用）。目的是满足某些常量池索引值的数据在特定的情况下需要表达不引用任何常量池的含义。根本原因在于索引为 0 也是一个常量，它是 JVM 的保留常量，它不位于常量表中。这个常量就对应 null，所以常量池的索引从 1 而非 0 开始。</p>
</li>
</ol>
<h6 id="常量池结构表"><a class="header-anchor" href="#常量池结构表">¶</a>常量池结构表</h6>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823162256476.png" class="" loading="lazy">
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/b8.png" class="" loading="lazy">
<blockquote>
<p>以前面的 #1 为例，第 1 字节 u1=10，23 字节 u2 代表类，45 字节 u2 代表名字和类型</p>
<ul>
<li>u2 的 23 字节又指向了 #4，第二个 u2 的 56 字节指向 #20
<ul>
<li>#4 的 u1=7 是类名指向 #23(字符串 java/lang/Object)，</li>
<li>#20 的 u1=12 是又分为
<ul>
<li>方法名称（指向 #7 字符串 “”）+</li>
<li>方法描述符（指向 #8 字符串 ()V，代表无参返回值 void）。</li>
<li>#20 最终为<code>&quot;&lt;init&gt;&quot;:()V</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所以 #1 最终为<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>，其中<code>.</code>为 U 的分割号</p>
<p>总结：最后都会指向字符串</p>
<p>此外分析 #2 最后的结果为<code>JVMtest/MyTest1.a:I</code>，代表是一个属性 a，类型为 int</p>
<p>所以上图的 MethodRef 代表着一个方法，FieldRef 代表是一个属性，其余的是一些基本类型为 utf8 字符串</p>
</blockquote>
<h6 id="类型表示"><a class="header-anchor" href="#类型表示">¶</a>类型表示</h6>
<ol start="6">
<li>在 JVM 规范中，每个变量 / 字段都有描述信息，主要的作用是描述字段的数据类型，方法的参数列表（包括数量、类型和顺序）与返回值。根据描述符规则，</li>
</ol>
<ul>
<li>基本数据类型和代表无返回值的 void 类型都用一个大写字符来表示，</li>
<li>而对象类型使用字符 L + 对象的全限定名称来表示。</li>
<li>为了压缩字节码文件的体积，对于基本数据类型，JVM 都只使用一个大写字母来表示。如下所示: B-byte，C-char，D-double，F-float，I-int，J-long，S-short，Z-boolean，V-void，L - 对象类型，</li>
<li>如 Ljava/lang/String;<br>
对于数组类型来说，每一个维度使用一个前置的 [来表示，如 int[] 表示为 [I ，String [][] 被记录为[[Ljava/lang/String;</li>
</ul>
<ol start="7">
<li>用描述符描述方法的时候，用先参数列表后返回值的方式来描述。参数列表按照参数的严格顺序放在一组 () 之内，如方法<code>String getNameByID(int id ,String name)</code>转换成<code>(I,Ljava/lang/String;)Ljava/lang/String;</code></li>
</ol>
<p>Java 字节码整体结构：</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823162350340.png" class="" loading="lazy">
<p>Class 字节码中有两种数据类型：<br>
（1）字节数据直接量：这是基本的数据类型。共细分为 u1、u2、u4、u8 四种，分别代表连续的 1 个字节、2 个字节、4 个字节、8 个字节组成的整体数据。<br>
（2）表 / 数组：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体：组成表的成分所在的位置和顺序都是已经严格定义好的。</p>
<h5 id="访问权限-Access-Falgs："><a class="header-anchor" href="#访问权限-Access-Falgs：">¶</a>访问权限 Access Falgs：</h5>
<p>2 个字节，访问标志信息包括了该 class 文件是类还是接口，是否被定义成 public，是否是 abstract，如果是类，是否被定义成 final。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/20190823162417381.png" class="" loading="lazy">
<ul>
<li>0x0021 是 0x0020 和 0x0001 的并集，表示 ACC_PUBLIC 和 ACC_SUPER。（我们的字节码文件正是 21，可以调用父类方法）</li>
<li>0x0002:private</li>
</ul>
<h5 id="类名"><a class="header-anchor" href="#类名">¶</a>类名</h5>
<p>2 个字节，对应常量池 #3</p>
<h5 id="父类名"><a class="header-anchor" href="#父类名">¶</a>父类名</h5>
<p>2 个字节，对应常量池 #4</p>
<h5 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h5>
<p>u2 接口数量 + u2 接口名。我们的是 0000，没有接口。</p>
<h5 id="字段表-Fields"><a class="header-anchor" href="#字段表-Fields">¶</a>字段表 Fields</h5>
<p>u2 + 每字段结构 * 个数</p>
<p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量和实例变量，但是不包括方法内部声明的局部变量。</p>
<p>每字段结构</p>
<table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access-flags</td><td>1</td></tr><tr><td>u2</td><td>names-index</td><td>1</td></tr><tr><td>u2</td><td>descriptor-index</td><td>1</td></tr><tr><td>u2</td><td>attributes-count</td><td>1</td></tr><tr><td>attribute-info</td><td>attributes</td><td>attributes-count</td></tr></tbody></table>
<ul>
<li>成员个数：00 01 代表有一个成员</li>
<li>第一个成员：
<ul>
<li>成员属性 access-flags：00 02：代表 private</li>
<li>成员名称 names-index：00 05：代表 #5（a）</li>
<li>成员类型 descriptor-index：00 06：代表 #6（I 即 int）</li>
<li>属性个数 attributes-count：00 00</li>
</ul>
</li>
</ul>
<h5 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h5>
<p>方法个数（2 字节）+ 每方法结构 * 个数（我们的 class 为 3 个 get+set + 构造器）</p>
<p>每方法的结构：</p>
<table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access-flags</td><td>1</td></tr><tr><td>u2</td><td>names-index</td><td>1</td></tr><tr><td>u2</td><td>descriptor-index</td><td>1</td></tr><tr><td>u2</td><td>attributes-count</td><td>1</td></tr><tr><td>attribute-info</td><td>attributes</td><td>attributes-count</td></tr></tbody></table>
<p>方法个数：00 03：3 个方法 set+get + 构造器</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
  public JVMtest.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  &#x2F;&#x2F; Field a:I
         9: return
      LineNumberTable:
        line 3: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   LJVMtest&#x2F;MyTest1;

  public int getA();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: getfield      #2                  &#x2F;&#x2F; Field a:I
         4: ireturn
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJVMtest&#x2F;MyTest1;

  public void setA(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;2
         0: aload_0
         1: iload_1
         2: putfield      #2                  &#x2F;&#x2F; Field a:I
         5: return
      LineNumberTable:
        line 9: 0
        line 10: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   LJVMtest&#x2F;MyTest1;
            0       6     1     a   I
&#125;
SourceFile: &quot;MyTest1.java&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>方法 1：
<ul>
<li>访问权限 access-flags：00 01：代表 PUBLIC</li>
<li>方法名 names-index：00 07：#7（构造器<code>&lt;init&gt;</code>）</li>
<li>方法修饰符 descriptor-index：00 08：#8（<code>()V</code>）</li>
<li>方法属性个数 attributes-count：00 01：1 个</li>
<li>第一个属性 attribute_info：
<ul>
<li>属性名 attribute_name_index：00 09：#9（方法的属性 Code，方法总是有 Code 这个属性）</li>
<li>属性长度 attribute_length：00 00 00 38：56 个字节，56 个字节后是第二个方法</li>
<li>info[56]
<ul>
<li>操作数最大深度 max-stack：00 02</li>
<li>局部变量数量 max_locals：00 01</li>
<li>方法字节长度 code_length：00 00 00 0A：10</li>
<li>往后 00 00 00 0A 个字节：方法运行时候的字节码：2A B7 00 01 2A 04 B5 00 02 B1，对应 jclassLib 中的 ByteCode 信息（init 方法）：<code>0 aload_0【2A：索引为0推送到栈顶】 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;【B7：调用父类构造方法00 01：#1】 4 aload_0【2A】 5 iconst_1【04】 6 putfield #2 &lt;JVMtest/MyTest1.a&gt;【B5 /00 02】 9 return</code></li>
<li>异常表 00 00</li>
<li>Code 属性个数：00 02（LineNumberTable 和 LocalVaribaleTable）</li>
<li>00 0A：#10：LineNumberTable，字节码与源代码的行号对应</li>
<li>00 00 00 0A：往后 10 个字节</li>
<li>00 02 /00 00 00 03 /00 04 00 04</li>
<li>00 0B：#11：LocalVaribaleTable</li>
<li>00 00 00 0C 往后 12 字节是 LocalVaribaleTable</li>
<li>00 01 局部变量个数 / 00 00 局部变量起始位置. 00 0A 结束位置 /00 索引 /0C 局部变量对应 #10this /00 0D 局部变量的描述 #13/ 00 00 检查</li>
<li>对应 java 里非静态方法，至少有一个局部变量 this</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>方法 2：… 省略</li>
<li>方法 3：… 省略</li>
</ul>
<p>方法中的每个属性都是一个 attribute_info 结构：</p>
<p>（1）JVM 预定义了部分 attribute，但是编译器自己也可以实现自己的 attribute 写入 class 文件里，供运行时使用；<br>
（2）不同的 attribute 通过 attribute_name_index 来区分。</p>
<p>attribute_info 格式:</p>
<pre class="line-numbers language-none"><code class="language-none">attribute_info&#123;
    u2 attribute_name_index;&#x2F;&#x2F;eg.Code
    u4 attribute_length;
    u1 info[attribute_length]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Code 结构：</p>
<p>attribute_name_index 值为 code，则为 Code 结构</p>
<p>Code 的作用是保存该方法的结构，所对应的的字节码</p>
<pre class="line-numbers language-none"><code class="language-none">Code_attribute&#123;&#x2F;&#x2F;info
    &#x2F;&#x2F;u2 attribute-name-index;
    &#x2F;&#x2F;u4 attibute-length;
    u2 max-stack;
    u2 max-locals;
    u4 code-length;
    u1 code[code-length];&#x2F;&#x2F;往后code-length个字节是ByteCode
    u2 exception-table-length;
    &#123;
        u2 start-pc;
        u2 end-pc;
        u2 handler-pc;
        u2 catch-type;
    &#125;exception-table[exception-table-length];
    u2 attibute-count;
    attribute-info attributes[attibutes-count];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造器的 Code 结构组成：</p>
<ul>
<li>attribute_length：表示 attribute 所包含的字节数，不包含 attribute_name_index 和 attribute_length 字段</li>
<li>max_stacks：表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</li>
<li>max_locals：表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量</li>
<li>code_length：表示该方法所包含的字节码的字节数以及具体的指令码。具体的字节码是指该方法被调用时，虚拟机所执行的字节码</li>
<li>exception_table：存放处理异常的信息，每个 exception_table 表，是由 start_pc、end_pc、hangder_pc、catch_type 组成
<ul>
<li>start_pc、end_pc：表示在 code 数组中从 start_pc 到 end_pc（包含 start_pc，不包含 end_pc）的指令抛出的异常会由这个表项来处理</li>
<li>hangder_pc：表示处理异常的代码的开始处。</li>
<li>catch_type：表示会被处理的异常类型，它指向常量池中的一个异常类。当 catch_type=0 时，表示处理所有的异常。</li>
</ul>
</li>
</ul>
<p>附加方法其他属性：</p>
<p>LineNumbeTable_attribute:</p>
<pre class="line-numbers language-none"><code class="language-none">LineNumberTable_attribute&#123;
    u2 attribute-name-index;
    u4 attribute-length;
    u2 line-number-table-length;
    &#123;u2 start-pc;
     u2 line-number;
    &#125;line-number-table[line-number-table-length];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个属性表示 code 数组中，字节码与 java 代码行数之间的关系，可以在调试的时候定位代码执行的行数。</p>
<p>LocalVariableTable ：结构类似于 LineNumbeTable_attribute<br>
对于 Java 中的任何一个非静态方法，至少会有一个局部变量，就是 this。</p>
<pre class="line-numbers language-none"><code class="language-none">public JVMtest.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  &#x2F;&#x2F; Field a:I
         9: return
      LineNumberTable:
        line 3: 0
        line 4: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   LJVMtest&#x2F;MyTest1;

  public int getA();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1
         0: aload_0
         1: getfield      #2                  &#x2F;&#x2F; Field a:I
         4: ireturn
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJVMtest&#x2F;MyTest1;

  public void setA(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;2
         0: aload_0
         1: iload_1
         2: putfield      #2                  &#x2F;&#x2F; Field a:I
         5: return
      LineNumberTable:
        line 9: 0
        line 10: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   LJVMtest&#x2F;MyTest1;
            0       6     1     a   I
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字节码查看工具：jclasslib<br>
<a target="_blank" rel="noopener" href="http://github.com/ingokegel/jclasslib">http://github.com/ingokegel/jclasslib</a></p>
<p>测试 2 ------- 反编译分析 MyTest2.class<br>
static 变量会导致出现 static 代码块</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest2&#123;
    String str&#x3D;&quot;Welcome&quot;;
    private int x&#x3D;5;
    public static Integer in&#x3D;5;
    public static void main(String[] args)&#123;
        MyTest2  myTest2&#x3D;new MyTest2();
        myTest2.setX(8);
        in&#x3D;20;
    &#125;
    private synchronized void setX(int x)&#123;
        thisx&#x3D;x;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>javap -verbose -p Abc -p: 将 private 修饰的方法显示出来<br>
synchronized 关键字：<br>
moniterenter<br>
monitorexit</p>
<p>测试 3</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest3&#123;
    public void test()&#123;
        try&#123;
            InputStream is&#x3D;new FileInputStream(&quot;test.txt&quot;);
            ServerSocket ss&#x3D;new ServerSocket(9999);
            ss.accept();

        &#125;catch(FileNotFoundException e)&#123;

        &#125;catch(IOException e)&#123;

        &#125;catch(Exception e)&#123;

        &#125;finally&#123;
            System.out.println(&quot;finally&quot;);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Java 字节码对于异常的处理方式：</p>
<ol>
<li>统一采用异常表的方式来对异常进行处理；</li>
<li>在 jdk1.4.2 之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令方式；</li>
<li>当异常处理存在 finally 语句块时，现代化的 JVM 采取的处理方式是将 finally 语句内的字节码拼接到每个 catch 语句块后面。也就是说，程序中存在多少个 catch，就存在多少个 finally 块的内容。<br>
栈帧（stack frame）：<br>
用于帮助虚拟机执行方法调用和方法执行的数据结构<br>
栈帧本身是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。<br>
符号引用：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。（在编译的时候一个每个 java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。）<br>
直接引用：（1）直接指向目标的指针（指向对象，类变量和类方法的指针）（2）相对偏移量。（指向实例的变量，方法的指针）（3）一个间接定位到对象的句柄。<br>
有些符号引用在加载阶段或者或是第一次使用时，转换为直接引用，这种转换叫做静态解析；另外一些符号引用则是在运行期转换为直接引用，这种转换叫做动态链接。<br>
助记符：<br>
1.invokeinterface：调用接口的方法，在运行期决定调用该接口的哪个对象的特定方法。<br>
2.invokestatic：调用静态方法<br>
3.invokespecial：调用私有方法， 构造方法（），父类的方法<br>
4.invokevirtual：调用虚方法，运行期动态查找的过程<br>
5.invokedynamic：动态调用方法</li>
</ol>
<p>测试 4</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest4&#123;
    public static void test()&#123;
            System.out.println(&quot;static test&quot;);
    &#125;
    public static void main(Stirng[] args)&#123;
        test();             &#x2F;&#x2F;invokestatic
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>静态解析的四种场：静态方法、父类方法、构造方法、私有方法。以上四种方法称为非虚方法，在类加载阶段将符号引用转换为直接引用。</p>
<p>73 没看</p>
<p>字节码结束龙 JVM 笔记</p>
<h1>JVM 调优</h1>
<p>请看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/108312012">https://blog.csdn.net/hancoder/article/details/108312012</a></p>
<h1>张龙类的加载过程代码：</h1>
<ul>
<li>测试 1：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
        对于静态字段来说，只有直接定义了该字段的类才会被初始化
        当一个类在初始化时，要求父类全部都已经初始化完毕
        -XX:+TraceClassLoading，用于追踪类的加载信息并打印出来

        -XX:+&lt;option&gt;，表示开启option选项
        -XX:-&lt;option&gt;，表示关闭option选项
        -XX:&lt;option&gt;&#x3D;value，表示将option的值设置为value
*&#x2F;
public class MyTest&#123;
    public static void main(String[] args)&#123;
        System.out.println(MyChild.str);  &#x2F;&#x2F;输出：MyParent static block 、 hello world   （因为对MyChild不是主动使用）
       &#x2F;&#x2F;对parent的主动使用，因为没有使用到child中的str2，所以child的静态代码块没有执行。子类引用不算主动使用
        System.out.println(MyChild.str2);  &#x2F;&#x2F;输出：MyParent static block  、MyChild static block、welcome
        
 &#x2F;* 输出
MyParent static block
hello world
MyChild static block
welcome
  *&#x2F;
    &#125;
&#125;
class MyParent&#123;
    public static String str&#x3D;&quot;hello world&quot;;
    static &#123;
        System.out.println(&quot;MyParent static block&quot;);
    &#125;
&#125;
class MyChild extends MyParent&#123;
    public static String str2&#x3D;&quot;welcome&quot;;
    static &#123;
        System.out.println(&quot;MyChild static block&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 2：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;** javap -c 类
        常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中
        本质上，调用类并没有直接调用到定义final常量的类，因此并不会触发定义常量的类的初始化
        注意：这里指的是将常量存到MyTest2的常量池中，之后MyTest2和MyParent就没有任何关系了。
        甚至我们可以将MyParent2的class文件删除

        助记符 ldc：表示将int、float或者String类型的常量值从常量池中推送至栈顶
        助记符 bipush：表示将单字节（-128-127）的常量值推送到栈顶
        助记符 sipush：表示将一个短整型值（-32768-32369）推送至栈顶
        助记符 iconst_1：表示将int型的1推送至栈顶（iconst_m1到iconst_5）
*&#x2F;
public class MyTest2&#123;
    public static void main(String[] args)&#123;
        System.out.println(MyParent2.str);    &#x2F;&#x2F;输出 hello world
        System.out.println(MyParent2.s);  
        System.out.println(MyParent2.i);  
        System.out.println(MyParent2.j);  
  &#x2F;*
hello world
   *&#x2F;
    &#125;
&#125;
class MyParent2&#123;
    public static final String str&#x3D;&quot;hello world&quot;;
    public static final short s&#x3D;7;
    public static final int i&#x3D;129;
    public static final int j&#x3D;1;
    static &#123;
        System.out.println(&quot;MyParent static block&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 3</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
但是常量也有例外：
当一个常量的值并非编译期间可以确定的，那么其值就不会放到调用类的常量池中
这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化
*&#x2F;
public class MyTest3&#123;
    public static void main(String[] args)&#123;
        System.out.println(MyParent3.str);  
        &#x2F;*  输出
        MyParent static block &#x2F;&#x2F;触发了类的初始化
        kjqhdun-baoje21w-jxqioj1-2jwejc9029
        *&#x2F;
    &#125;
&#125;
class MyParent3&#123;
    public static final String str&#x3D;UUID.randomUUID().toString();
    static &#123;
        System.out.println(&quot;MyParent static block&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 4</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为 [L com.hisense.classloader.MyParent4 这种形式。
对于数组来说，JavaDoc经构成数据的元素成为Component，实际上是将数组降低一个维度后的类型。
一维&#x2F;二维数组的getSuperClass都是Object

助记符：anewarray：表示创建一个引用类型（如类、接口）的数组，并将其引用值压入栈顶
助记符：newarray：表示创建一个指定原始类型（int boolean float double）d的数组，并将其引用值压入栈顶
    *&#x2F;
public class MyTest4&#123;
    public static void main(String[] args)&#123;
        MyParent4[] myParent4s&#x3D;new MyParent4[1];    &#x2F;&#x2F;不是主动使用
        System.out.println(&quot;--------&quot;);
        MyParent4 myParent4&#x3D;new MyParent4();        &#x2F;&#x2F;创建类的实例，属于主动使用，会导致类的初始化

        System.out.println(myParent4s.getClass());  &#x2F;&#x2F;输出 [L com.hisense.classloader.MyParent4
        System.out.println(myParent4s.getClass().getSuperClass());    &#x2F;&#x2F;输出Object

        int[] i&#x3D;new int[1];
        System.out.println(i.getClass());          &#x2F;&#x2F;输出 [ I
        System.out.println(i.getClass().getSuperClass());    &#x2F;&#x2F;输出Object
    &#125;
    &#x2F;*
------------
MyParent static block
class [LJVMtest.MyParent4;
class java.lang.Object
class [I
class java.lang.Object
    *&#x2F;
&#125;
class MyParent4&#123;
    static &#123;
        System.out.println(&quot;MyParent static block&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 5</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
        当一个接口在初始化时，并不要求其父接口都完成了初始化
        只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化
*&#x2F;
public class MyTest5&#123;
    public static void main(String[] args)&#123;
         public static void main(String[] args)&#123;
            System.out.println(MyChild5.b)
         &#125;
    &#125;
&#125;
interfacce MParent5&#123;
    public static Thread thread&#x3D;new thread()&#123;
        System.out.println(&quot; MParent5 invoke&quot;)
    &#125;;
&#125;
interface MyChild5 extends MParent5&#123;     &#x2F;&#x2F;接口属性默认是 public static final
    public static int b&#x3D;6;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 6</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 准备阶段和初始化的顺序问题
*&#x2F;
public class MyTest6&#123;
    public static void main(String[] args)&#123;
         public static void main(String[] args)&#123;
            Singleton Singleton&#x3D;Singleton.getInstance();
            System.out.println(Singleton.counter1);     &#x2F;&#x2F;输出1，1
            System.out.println(Singleton.counter2);
         &#125;
    &#125;
&#125;
class Singleton&#123;
    public static int counter1;
    public static int counter2&#x3D;0;  
    private static Singleton singleton&#x3D;new Singleton();
    
    private Singleton()&#123;
        counter1++;
        counter2++;
    &#125;
    
    &#x2F;&#x2F; public static int counter2&#x3D;0;       &#x2F;&#x2F;   若改变此赋值语句的位置，输出  1，0
    public static Singleton getInstance()&#123;
        return singleton;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java 编译器在它编译的每一个类都至少生成一个实例化的方法，在 java 的 class 文件中，这个实例化方法被称为<code>&lt;init&gt;</code>。针对源代码中每一个类的构造方法，java 编译器都会产生一个 “<code>&lt;init&gt;</code>” 方法。</p>
<p>测试 7</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;** &#x2F;&#x2F;类加载器测试
 java.lang.String是由根加载器加载，在rt.jar包下
*&#x2F;
public class MyTest7&#123;
    public static void main(String[] args)&#123;
         public static void main(String[] args)&#123;
            Class&lt;?&gt; clazz&#x3D;Class.forName(&quot;java.lang.String&quot;);
            System.out.println(clazz.getClassLoader());  &#x2F;&#x2F;返回null
            
            Class&lt;?&gt; clazz2&#x3D;Class.forName(&quot;C&quot;);
           System.out.println(clazz2.getClassLoader());  &#x2F;&#x2F;输出sun.misc.Launcher$AppClassLoader@18b4aac2  其中AppClassLoader:系统应用类加载器
         &#125;
    &#125;
&#125;
class C&#123;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 8</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    调用ClassLoader的loaderClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化
*&#x2F;
public class MyTest8&#123;
    public static void main(String[] args)&#123;
        ClassLoader loader&#x3D;ClassLoader.getSystemClassLoader();
        Class&lt;?&gt; clazz1&#x3D;loader.loadClass(&quot;CL&quot;); &#x2F;&#x2F;不会初始化
        System.out.println(clazz1);
        System.out.println(&quot;-------------------&quot;);

        Class&lt;?&gt; clazz&#x3D;Class.forName(&quot;CL&quot;);
        System.out.println(clazz);  &#x2F;&#x2F;反射初始化
        
    &#125;
&#125;

class CL&#123;
    static &#123;
        System.out.println(&quot;FinalTest static block&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 9-12 忽略</li>
<li>测试 13</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    输出AppClassLoader、ExtClassLoader、null
*&#x2F;
public class MyTest13&#123;
    public static void main(String[] args)&#123;
         public static void main(String[] args)&#123;
            ClassLoader loader&#x3D;ClassLoader.getSystemClassLoader();
            System.out.println(loader);
            
            while(loader!&#x3D;null)&#123;
                loader&#x3D;loader.getParent();
                 System.out.println(loader);
            &#125;
         &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 14</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest14&#123;
    public static void main(String[] args)&#123;
         public static void main(String[] args)&#123;
            ClassLoader loader&#x3D;Thread.currentThread().getContextClassLoader();
            System.out.println(loader);         &#x2F;&#x2F;输出AppClassLoader
            &#x2F;&#x2F;下面这段没整明白什么用，先记录下来
            String resource;
            Enumeration&lt;URL&gt; urls&#x3D;loader.getResources(resourceName);
            whilr(urls.hasMoreElements())&#123;
                URL url&#x3D;urls.nextElement();
                System.out.println(url);
            &#125;
         &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试 15</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    对于数组，它对应的class对象不是由类加载器加载，而是由JVM在运行期动态的创建。然而对于数组类的类加载器来说，它返回的类加载器和数组内元素的类加载器是一样的。如果数组类元素是原生类，那么数组是没有类加载器的。
*&#x2F;
public class MyTest15&#123;
    public static void main(String[] args)&#123;
            String[] strings&#x3D;new String[2];
            System.out.println(strings.getClass());
            System.out.println(strings.getClass().getClassLoader());    &#x2F;&#x2F;输出null
            
            MyTest15[] mytest15&#x3D;new MyTest15[2];
            System.out.println(mytest15.getClass().getClassLoader());   &#x2F;&#x2F;输出应用类加载器
            
            int[] arr&#x3D;new int[2];
            System.out.println(arr.getClass().getClassLoader());        &#x2F;&#x2F;输出null，此null非彼null
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并行类加载器可支持并发加载，需要在类初始化期间调用 ClassLoader.registerAaParallelCapable() 方法进行注册。ClassLoader 类默认支持并发加载，但是其子类必须在初始化期间进行注册。</p>
<p>loadClass() 包含如下方法</p>
<ul>
<li>
<p>findLoadedClass(String);// 检查是否已经被加载</p>
</li>
<li>
<p>loadClass();</p>
</li>
<li>
<p>findClass();// 我们重写的</p>
</li>
<li>
<p>测试 16</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    创建自定义加载器，继承ClassLoader
*&#x2F;
public class MyTest16 extends ClassLoader&#123;
    private String classLoaderName;
    private String path；
    private final String fileExtension&#x3D;&quot;.class&quot;;
    
    public MyTest16(String classLoaderName)&#123;
        super();        &#x2F;&#x2F;将系统类当做该类的父加载器
        this.classLoaderName&#x3D;classLoaderName;
    &#125;
    public MyTest16(ClassLoader parent,String classLoaderName)&#123;
        super(parent);      &#x2F;&#x2F;显式指定该类的父加载器
        this.classLoaderName&#x3D;classLoaderName;
    &#125;
    
   public MyTest16(ClassLoader parent)&#123;
        super(parent);      &#x2F;&#x2F;显式指定该类的父加载器
    &#125;
    
    public void setPath(String path)&#123;&#x2F;&#x2F;指定加载的路径（系统加载器路径为out目录）
        this.path&#x3D;path;
    &#125;
    @Override
    protect Class&lt;?&gt; findClass(String className)&#123;
        System.out.println(&quot;calssName&#x3D;&quot;+className);
        class,File.separator);
        byte[] data&#x3D;loadClassData(className);
        return defineClass(className,data,0,data.length); &#x2F;&#x2F;define方法为父类方法
    &#125;
    
    private byte[] loadClassData(String name)&#123;
        InputStream is&#x3D;null;
        byte[] data&#x3D;null;
        ByteArrayOutputStream baos&#x3D;null;
        try&#123;
            is&#x3D;new FileInputStream(new File(this.path+name+this.fileExtension));
            baos&#x3D;new ByteArrayOutputStream();
            int ch;
            while(-1!&#x3D;(ch&#x3D;is.read()))&#123;
                baos.write(ch);
            &#125;
            data&#x3D;baos.toByteArray();
            
        &#125;catch(Exception e)&#123;
        &#125;finally&#123;
            is.close();
            baos.close();
             return data;
        &#125;
    &#125;
    public static void test(ClassLoader classLoader)&#123;
        Class&lt;?&gt; clazz&#x3D;classLoader.loadClass(&quot;com.hisense.MyTest1&quot;);  &#x2F;&#x2F;loader不一样，但是类一样
        &#x2F;&#x2F;loadClass()是父类方法，在方法内部调用findClass
        System.out.println(clazz.hashCode());
        Object  object&#x3D;clazz.newInstance();
        System.out.println(object);
    &#125;
    public static void main(String[] args)&#123;
        &#x2F;&#x2F;父亲是系统类加载器，根据父类委托机制，MyTest1由系统类加载器加载了
        MyTest16 loader1&#x3D;new MyTest16(&quot;loader1&quot;);       
        test(loader1);
        
        &#x2F;&#x2F;仍然是系统类加载器进行加载的，因为路径正好是classpath
        MyTest16 loader2&#x3D;new MyTest16(&quot;loader2&quot;);  &#x2F;&#x2F;如果都是由系统加载器加载的，那么class就一样
        loader2.path&#x3D;&quot;D:\Eclipse\workspace\HiATMP-DDMS\target\classes\&quot;;
        test(loader2);
        
         &#x2F;&#x2F;自定义的类加载器被执行，findClass方法下的输出被打印。前提是当前classpath下不存在MyTest1.class，MyTest16的父加载器-系统类加载器会尝试从classpath中寻找MyTest1。
        MyTest16 loader3&#x3D;new MyTest16(&quot;loader3&quot;);  
        loader3.path&#x3D;&quot;C:\Users\weichengjie\Desktop\&quot;;&#x2F;&#x2F;
        test(loader3);
        
        &#x2F;&#x2F;与3同时存在，输出两个class的hash不一致，findClass方法下的输出均被打印，原因是类加载器的命名空间问题。
        MyTest16 loader4&#x3D;new MyTest16(&quot;loader4&quot;);  
        loader4.path&#x3D;&quot;C:\Users\weichengjie\Desktop\&quot;;
        test(loader4);
        
        &#x2F;&#x2F;将loader3作为父加载器
        MyTest16 loader5&#x3D;new MyTest16(loader3,&quot;loader3&quot;);  
        loader3.path&#x3D;&quot;C:\Users\weichengjie\Desktop\&quot;;
        test(loader5);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类的卸载</p>
<ul>
<li>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，类在方法区内的数据也会被卸载。</li>
<li>一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期。</li>
<li>由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java 虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的 Class 对象，因此这些 Class 对象是可触及的。</li>
<li>由用户自定义的类加载器所加载的类是可以被卸载的。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    自定义类加载器加载类的卸载
    -XX：+TraceClassUnloading
*&#x2F;
   public static void main(String[] args)&#123;
        MyTest16 loader2&#x3D;new MyTest16(&quot;loader2&quot;);  
        loader2.path&#x3D;&quot;D:\Eclipse\workspace\HiATMP-DDMS\target\classes\&quot;;
        test(loader2);
        loader2&#x3D;null;
        System.gc();   &#x2F;&#x2F;让系统去显式执行垃圾回收
        
        输出的两个对象hashcode值不同，因为前面加载的已经被卸载了
        loader2&#x3D;new MyTest16(&quot;loader6&quot;); &#x2F;&#x2F;  
        test(loader2);
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>gvisualvm</code>命令 查看当前 java 进程 (<code>gvisualvm</code>在 jdk/bin 下面)</p>
<ul>
<li>测试 17</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    创建自定义加载器，继承ClassLoader
*&#x2F;
class MyCat&#123;
    public MyCat()&#123;
        System.out.println(&quot;MyCat is loaded...&quot;+this.getClass().getClassLoader());
    &#125;
&#125;

class MySample&#123;
    public MySample()&#123;
        System.out.println(&quot;MySample is loaded...&quot;+this.getClass().getClassLoader());
        new MyCat();
    &#125;
&#125;

public class MyTest17 extends ClassLoader&#123;
    private String classLoaderName;
    private String path；
    private final String fileExtension&#x3D;&quot;.class&quot;;
    
    public MyTest17(String classLoaderName)&#123;
        super();        &#x2F;&#x2F;将系统类当做该类的父加载器
        this.classLoaderName&#x3D;classLoaderName;
    &#125;
    public MyTest17(ClassLoader parent,String classLoaderName)&#123;
        super(parent);      &#x2F;&#x2F;显式指定该类的父加载器
        this.classLoaderName&#x3D;classLoaderName;
    &#125;
    
    public void setPath(String path)&#123;
        this.path&#x3D;path;
    &#125;
    @Override
    protect Class&lt;?&gt; findClass(String className)&#123;
        System.out.println(&quot;calssName&#x3D;&quot;+className);
        class,File.separator);
        byte[] data&#x3D;loadClassData(className);
        return defineClass(className,data,0,data.length); &#x2F;&#x2F;define方法为父类方法
    &#125;&#x2F;&#x2F;系统加载器就能加载类了，所以可能不通过我们自定义的类加载器。
    
    private byte[] loadClassData(String name)&#123;
        InputStream is&#x3D;null;
        byte[] data&#x3D;null;
        ByteArrayOutputStream baos&#x3D;null;
        try&#123;
            is&#x3D;new FileInputStream(new File(this.path+name+this.fileExtension));
            baos&#x3D;new ByteArrayOutputStream();
            int ch;
            while(-1!&#x3D;(ch&#x3D;is.read()))&#123;
                baos.write(ch);
            &#125;
            data&#x3D;baos.toByteArray();
        &#125;catch(Exception e)&#123;
        &#125;finally&#123;
            is.close();
            baos.close();
             return data;
        &#125;
    &#125;
    public static void main(String[] args)&#123;
        MyTest17 loader1&#x3D;new MyTest17(&quot;loader1&quot;);
        Class&lt;?&gt; clazz&#x3D;loader1.loadClass(&quot;com.hisense.MySample&quot;);  
        System.out.println(clazz.hashCode());
        &#x2F;&#x2F;如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）
        Object  object&#x3D;clazz.newInstance(); &#x2F;&#x2F;加载和实例化了MySample和MyCat
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试 17_1</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest17_1 extends ClassLoader&#123;
    private String classLoaderName;
    private String path；
    private final String fileExtension&#x3D;&quot;.class&quot;;
    
    public MyTest17_1(String classLoaderName)&#123;
        super();        &#x2F;&#x2F;将系统类当做该类的父加载器
        this.classLoaderName&#x3D;classLoaderName;
    &#125;
    public MyTest17_1(ClassLoader parent,String classLoaderName)&#123;
        super(parent);      &#x2F;&#x2F;显式指定该类的父加载器
        this.classLoaderName&#x3D;classLoaderName;
    &#125;
    
    public void setPath(String path)&#123;
        this.path&#x3D;path;
    &#125;
    @Override
    protect Class&lt;?&gt; findClass(String className)&#123;
        System.out.println(&quot;calssName&#x3D;&quot;+className);
        class,File.separator);
        byte[] data&#x3D;loadClassData(className);
        return defineClass(className,data,0,data.length); &#x2F;&#x2F;define方法为父类方法
    &#125;
    
    private byte[] loadClassData(String name)&#123;
        InputStream is&#x3D;null;
        byte[] data&#x3D;null;
        ByteArrayOutputStream baos&#x3D;null;
        try&#123;
            is&#x3D;new FileInputStream(new File(this.path+name+this.fileExtension));
            baos&#x3D;new ByteArrayOutputStream();
            int ch;
            while(-1!&#x3D;(ch&#x3D;is.read()))&#123;
                baos.write(ch);
            &#125;
            data&#x3D;baos.toByteArray();
        &#125;catch(Exception e)&#123;
        &#125;finally&#123;
            is.close();
            baos.close();
             return data;
        &#125;
    &#125;
    public static void main(String[] args)&#123;
        MyTest17_1 loader1&#x3D;new MyTest17_1(&quot;loader1&quot;);
        loader1.path&#x3D;&quot;C:\Users\weichengjie\Desktop&quot;;
        Class&lt;?&gt; clazz&#x3D;loader1.loadClass(&quot;com.hisense.MySample&quot;);  
        System.out.println(clazz.hashCode());
        &#x2F;&#x2F;MyCat是由加载MySample的加载器去加载的：
        如果只删除classpath下的MyCat，则会报错，NoClassDefFoundError；
        如果只删除calsspath下的MySample，则由自定义加载器加载桌面上的MySample，由系统应用加载器加载MyCat。
        Object  object&#x3D;clazz.newInstance(); 
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试 17_1_1</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;修改MyCat和MySample
class MyCat&#123;
    public MyCat()&#123;
        System.out.println(&quot;MyCat is loaded...&quot;+this.getClass().getClassLoader());
        System.out.println(&quot;from MyCat: &quot;+MySample.class);
    &#125;
&#125;

class MySample&#123;
    public MySample()&#123;
        System.out.println(&quot;MySample is loaded...&quot;+this.getClass().getClassLoader());
        new MyCat();
        System.out.println(&quot;from MySample :&quot;+ MyCat.class);
    &#125;
&#125;

public class MyTest17_1 &#123;
        public static void main(String[] args)&#123;
        &#x2F;&#x2F;修改MyCat后，仍然删除classpath下的MySample，留下MyCat，程序报错
        &#x2F;&#x2F;因为命名空间，父加载器找不到子加载器所加载的类，因此MyCat找不到        
        &#x2F;&#x2F;MySample。
        MyTest17_1 loader1&#x3D;new MyTest17_1(&quot;loader1&quot;);
        loader1.path&#x3D;&quot;C:\Users\weichengjie\Desktop&quot;;
        Class&lt;?&gt; clazz&#x3D;loader1.loadClass(&quot;com.hisense.MySample&quot;);  
        System.out.println(clazz.hashCode());
        Object  object&#x3D;clazz.newInstance(); 
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于命名空间重要说明：</p>
<ol>
<li>子加载器所加载的类能够访问父加载器所加载的类；</li>
<li>而父加载器所加载的类无法访问子加载器所加载的类。</li>
</ol>
<p>加载路径：</p>
<p>测试 18</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest18&#123;
    public static void main(String[] args)&#123;
        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));&#x2F;&#x2F;根加载器路径
        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));&#x2F;&#x2F;扩展类加载器路径
        System.out.println(System.getProperty(&quot;java.class.path&quot;));&#x2F;&#x2F;应用类加载器路径
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 18_1</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest18_1&#123;
    public static void main(String[] args)&#123;
        MyTest16 loader1&#x3D;new MyTest16(&quot;loader1&quot;);
        loader1.setPath(&quot;C:\Users\weichengjie\Desktop&quot;);
        
        &#x2F;&#x2F;把MyTest1.class文件放入到根类加载器路径中，则由根类加载器加载MyTest1
        Class&lt;?&gt; clazz&#x3D; loader1.loadClass(&quot;MyTest1&quot;);
        
        System.out.println(&quot;clazz:&quot;+clazz.hashCode());
        System.out.println(&quot;class loader:&quot;+clazz.getClassLoader());
        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 19</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
    各加载器的路径是可以修改的，修改后会导致运行失败，ClassNotFoundExeception
*&#x2F;
public class MyTest19&#123;
    public static void main(String[] args)&#123;
        AESKeyGenerator aesKeyGenerator&#x3D;new AESKeyGenerator();
        System.out.println(aesKeyGenerator.getClass().getClassLoader());&#x2F;&#x2F;输出扩展类加载器
        System.out.println(MyTest19.class.getClassLoader());&#x2F;&#x2F;输出应用类加载器
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 20</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">class Person&#123;
    private Person person;
    public setPerson(Object object)&#123;
        this.person&#x3D;(Person)object;
    &#125;
 &#125;
 
 public class MyTest20&#123;
    public static void main(String[] args)&#123;
        MyTest16 loader1&#x3D;new MyTest16(&quot;loader1&quot;);
        MyTest16 loader2&#x3D;new MyTest16(&quot;loader2&quot;);
        
        Class&lt;?&gt; clazz1&#x3D;load1.loadClass(&quot;Person&quot;);
        Class&lt;?&gt; clazz2&#x3D;load1.loadClass(&quot;Person&quot;);
        &#x2F;&#x2F;clazz1和clazz均由应用类加载器加载的，第二次不会重新加载，结果为true
        System.out.println(clazz1&#x3D;&#x3D;clazz2);
        
        Object object1&#x3D;clazz1.getInstance();
        Object object2&#x3D;clazz2.getInstance();
        
        Method method&#x3D;clazz1.getMethod(&quot;setPerson&quot;,Object.class);
        method.invoke(object1,object2);
        
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 21</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest21&#123;
    public static void main(String[] args)&#123;
        MyTest16 loader1&#x3D;new MyTest16(&quot;loader1&quot;);
        MyTest16 loader2&#x3D;new MyTest16(&quot;loader2&quot;);
        loader1.setPath(&quot;C:\Users\weichengjie\Desktop&quot;);
        loader2.setPath(&quot;C:\Users\weichengjie\Desktop&quot;);
        &#x2F;&#x2F;删掉classpath下的Person类
        Class&lt;?&gt; clazz1&#x3D;load1.loadClass(&quot;Person&quot;);
        Class&lt;?&gt; clazz2&#x3D;load1.loadClass(&quot;Person&quot;);
        &#x2F;&#x2F;clazz1和clazz由loader1和loader2加载，结果为false
        System.out.println(clazz1&#x3D;&#x3D;clazz2);
        
        Object object1&#x3D;clazz1.getInstance();
        Object object2&#x3D;clazz2.getInstance();
        
        Method method&#x3D;clazz1.getMethod(&quot;setPerson&quot;,Object.class);
        &#x2F;&#x2F;此处报错，loader1和loader2所处不用的命名空间
        method.invoke(object1,object2);
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 22</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest22&#123;
    static&#123;
        System.out.println(&quot;MyTest22 init...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        System.out.println(MyTest22.class.getClassLoader());
        
        System.out.println(MyTest1.class.getClassLoader());
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>扩展类加载器只加载 jar 包，需要把 class 文件打成 jar</p>
<ul>
<li>测试 23</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。
    在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：
    Error occurred during initialization of VM
    java&#x2F;lang&#x2F;NoClassDeFoundError: java&#x2F;lang&#x2F;Object
*&#x2F;
 public class MyTest23&#123;
    public static void main(String[] args)&#123;
        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));
        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));
        System.out.println(System.getProperty(&quot;java.calss.path&quot;));
        
        System.out.println(ClassLoader.class.getClassLoader);
        System.out.println(Launcher.class.getClassLoader);
        
        &#x2F;&#x2F;下面的系统属性指定系统类加载器，默认是AppClassLoader
        System.out.println(System.getProperty(&quot;java.system.class.loader&quot;));
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）<br>
类加载器是由启动类加载器去加载的，启动类加载器是 C++ 写的，内嵌在 JVM 中。</li>
<li>内嵌于 JVM 中的启动类加载器会加载 java.lang.ClassLoader 以及其他的 Java 平台类。当 JVM 启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。</li>
<li>启动类加载器并不是 java 类，其他的加载器都是 java 类。</li>
<li>启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。</li>
</ul>
<p>OpenJDK</p>
<p><a target="_blank" rel="noopener" href="http://grepcode.com">grepcode.com</a>: 源码分析<br>
Launcher 类</p>
<p>Class.forName(String name, boolean initialize, ClassLoader loader);</p>
<p>—利用给定的加载器，返回字符串对应的 Class 对象。当 initialize 为 true 时，会对该类进行初始化（该类之前未初始化），默认为 true。<br>
Class.forName(“Foo”) 等同于 == Class.forName(“Foo”,true,this.getClass.getClassLoader());</p>
<pre class="line-numbers language-none"><code class="language-none">public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)
    throws ClassNotFoundException&#123;
    if (loader &#x3D;&#x3D; null) &#123;
        SecurityManager sm &#x3D; System.getSecurityManager();
        if (sm !&#x3D; null) &#123;
            ClassLoader ccl &#x3D; ClassLoader.getCallerClassLoader();  &#x2F;&#x2F;获取调用者类的ClassLoader
            if (ccl !&#x3D; null) &#123;
                sm.checkPermission(
                    SecurityConstants.GET_CLASSLOADER_PERMISSION);
            &#125;
        &#125;
    &#125;
    return forName0(name, initialize, loader);  &#x2F;&#x2F;forName0 是一个native方法
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="上下文类加载器-Thread-getContextClassLoader"><a class="header-anchor" href="#上下文类加载器-Thread-getContextClassLoader">¶</a>上下文类加载器 Thread.getContextClassLoader()</h4>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest24&#123;
    public static void main(String[] args)&#123;
        System.out.println(Thread.currentThread().getContextClassLoader());
        &#x2F;&#x2F;
        System.out.println(Thread.class.getClassLoader());
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>当前类加载器 (Current ClassLoader)</strong><br>
每个类都会尝试使用自己的类加载器去加载依赖的类。<br>
如果 ClassX 引用 ClassY，那么 ClassX 的类加载器会尝试加载 ClassY。（前提是 ClassY 尚未被加载）<br>
<strong>线程上下文类加载器 (Context ClassLoader)</strong><br>
线程上下文加载器 @ jdk1.2<br>
线程 Thread 类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader loader)<br>
如果没有通过 setContextClassLoader() 方法设置，线程将继承父线程的上下文类加载器，java 应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。<br>
<strong>线程上下文类加载器的作用：</strong><br>
父 ClassLoader 可以使用当前线程 Thread.currentThread().getContextClassLoader() 所制定的 ClassLoader 加载的类，这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的 ClassLoader 加载的类的情况，即改变了双亲委托模型。<br>
· 线程上下文类加载器就是当前线程的 Current ClassLoader。<br>
在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是有些接口是 Java 核心库所提供的的（如 JDBC），Java 核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的 jar 包（厂商提供），Java 的启动类加载器是不会加载其他来源的 jar 包，这样传统的双亲委托模型就无法满足要求。通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>
<ul>
<li>测试 25</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class MyTest25 implement Runable&#123;
    private Thread thread；
    public MyTest25()&#123;
        thread &#x3D;new Thread(this);
        thread.start();
    &#125;
    
    public void run()&#123;
        ClassLoader classLoader&#x3D;this.thread.getContextLoader();
        this.setContextLoader(classLoader);
        
        System.out.println(&quot;Class:&quot;+classLoader.getClass());
        System.out.println(&quot;Parent:&quot;+classLoader.getParent().getClass());
    &#125;
    
    public static void main(String[] args)&#123;
        new MyTest25();
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">ClassLoader contextClassLoader &#x3D; Thread.currentThread().getContextClassLoader();
        try &#123;
            Thread.currentThread().setContextClassLoader(targetTccl);
            myMethod();&#x2F;&#x2F;调用了Thread.currentThead().getContextClassLoader();
        &#125; finally &#123;
            Thread.currentThread().setContextClassLoader(contextClassLoader);
        &#125;
        &#x2F;&#x2F;如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载（如果没被加载过）
        &#x2F;&#x2F;ContextClassLoader的作用就是为了破坏java的类加载委托机制。
        &#x2F;&#x2F;当高层提供了统一的接口让底层实现，同时又要被高层加载（或实例化）底层类时，
        &#x2F;&#x2F;就必须通过线程上下文类加载器来帮助高层的classloader找到并加载类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>线程上下文类加载器的一般使用模式：<strong>获取 - 使用 - 还原</strong><br>
伪代码：<br>
ClassLoader classLoader=Thread.currentThread().getContextLoader();<br>
try{<br>
Thread.currentThread().setContextLoader(classLoader);<br>
}</p>
<p>—在 myMethod 中调用 Thread.currentThread().getContextLoader() 做某些事情<br>
—ContextClassLoader 的目的就是为了破坏类加载委托机制<br>
—使用线程上下文类加载器就可以成功的加载到当前的类的加载器无法加载到的类。<br>
—当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须通过上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。</p>
<p>SPI：Service Provide Interface 服务提供者接口</p>
<p>双亲委托机制在父类加载器加载的类中访问子类加载器加载的类时会出现问题，比如 JDBC。JDBC 中规定，Driver(数据库驱动) 必须向 DriverManage 注册自己，而 DriverManage 是 BootStrapClassloader 加载的，所以 DriverManage 中是无法加载到具体的 Driver。<br>
此时，服务提供者可以将配置文件放到资源目录的 META-INF/services 下，高层的接口通过 SPI 的方式，读取 META-INF/services 下文件中的类名。<br>
<strong>SPI 的具体约定</strong>为：当服务的提供者提供了服务接口的一种实现之后，在 jar 包的 META-INF/services / 目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。当外部程序装配这个模块的时候，就能通过该 jar 包 META-INF/services 里的配置文件找到具体的实现类，并装载实例化，完成模块的注入。基于这一个约定就能很好的找到服务接口的实现类，而不需要在代码里指定。jdk 提供服务实现查找的一个工具类：java.util.ServiceLoader</p>
<ul>
<li>测试 27—JDBC 案例分析</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;跟踪代码
 public class MyTest27&#123;
    public static void main(String[] args)&#123;
        &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;由于ServiceLoader机制的存在，此行可以注释掉不影响
        Connection connection&#x3D;DriverManager.getConnection(
  &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;&#x2F;mydb&quot;,&quot;user&quot;,&quot;password&quot;);
        
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当调用 DriverManager 的静态方法是，会造成类的初始化</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;类初始化时会运行静态代码块
    static &#123;
        loadInitialDrivers();
        println(&quot;JDBC DriverManager initialized&quot;);
    &#125;
    private static void loadInitialDrivers() &#123;
       String drivers;
        try &#123;
            drivers &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;
                public String run() &#123;
                    return System.getProperty(&quot;jdbc.drivers&quot;);
                &#125;
            &#125;);
        &#125; catch (Exception ex) &#123;
            drivers &#x3D; null;
        &#125;
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;
            public Void run() &#123;
                ServiceLoader&lt;Driver&gt; loadedDrivers &#x3D; ServiceLoader.load(Driver.class);
                Iterator&lt;Driver&gt; driversIterator &#x3D; loadedDrivers.iterator();
                try&#123;
                    while(driversIterator.hasNext()) &#123;
                        driversIterator.next();
                    &#125;
                &#125; catch(Throwable t) &#123;
                &#125;
                return null;
            &#125;
        &#125;);
        println(&quot;DriverManager.initialize: jdbc.drivers &#x3D; &quot; + drivers);
        if (drivers &#x3D;&#x3D; null || drivers.equals(&quot;&quot;)) &#123;
            return;
        &#125;
        String[] driversList &#x3D; drivers.split(&quot;:&quot;);
        println(&quot;number of Drivers:&quot; + driversList.length);
        for (String aDriver : driversList) &#123;
            try &#123;
                println(&quot;DriverManager.Initialize: loading &quot; + aDriver);
                Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());
            &#125; catch (Exception ex) &#123;
                println(&quot;DriverManager.Initialize: load failed: &quot; + ex);
            &#125;
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 loadInitialDrivers() 方法的代码中，可以发现 DriverManager 加载 Driver 的包括两部分：</p>
<ol>
<li>通过 System.getProperty(“jdbc.drivers”) 进行获取，使用系统类加载器进行加载。但是系统参数 “jdbc.drivers” 为 null，因此不会进行 Driver 的加载；</li>
<li>通过 SPI 的方式，读取 META-INF/services 文件夹下的类名，使用当前线程类加载器进行加载。</li>
</ol>
<p>ServiceLoader</p>
<p>ServiceLoader 是由 BootStrap Classloader 加载的，所以类中引用的其它类也会由 BootStrap 尝试去加载。</p>
<pre class="line-numbers language-none"><code class="language-none">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;
        &#x2F;&#x2F;ServiceLoader中会尝试用BootStrap 加载具体的Mysql Driver，
        &#x2F;&#x2F;但ServiceLoader中是不可见的，这样就无法加载。
        &#x2F;&#x2F;所以取出当前线程的上下文类加载器即appCL，用于后面加载具体的Mysql Driver
        ClassLoader cl &#x3D; Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    &#125;
    
 public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,ClassLoader loader)
    &#123;
        return new ServiceLoader&lt;&gt;(service, loader);
    &#125;

private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;
        service &#x3D; Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);
    
        &#x2F;&#x2F;loader 为ServiceLoader的私有常量，在后面加载具体实现类时会用该加载器进行加载。
        &#x2F;&#x2F; loader 在构造方法内赋了值，即为上文取到的线程上下文类加载器。
        loader &#x3D; (cl &#x3D;&#x3D; null) ? ClassLoader.getSystemClassLoader() : cl
        acc &#x3D; (System.getSecurityManager() !&#x3D; null) ? AccessController.getContext() : null;
        reload();
    &#125;
    
public void reload() &#123;
        providers.clear();
        lookupIterator &#x3D; new LazyIterator(service, loader);
    &#125;
&#x2F;&#x2F;LazyIterator是一个ServiceLoader的私有内部类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>DriverManager 初始化完毕，我们再来看一下 mysql 提供的 Driver 类内部的情况</p>
<ul>
<li>↓ com.mysql.jdbc.Driver 是 java.sql.Driver 的具体实现类，在初始化时会向 DriverManager 注册自己。就是将自身加入到一个名为 registeredDrivers 的静态成员 CopyOnWriteArrayList 中。但是实际中，Driver 已经在初始化的过程总使用 SPI 的方式将其进行了注册。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">static 
    &#123; 
        try &#123; 
        &#x2F;&#x2F;会向DriverManager注册自己，注册时会先完成DriverManager的加载和初始化
        DriverManager.registerDriver(new Driver());
        &#125; catch (SQLException var1) &#123; 
            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);    
          &#125;
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此为止，DriverManager 类在初始化的过程中，已经使用 SPI 的方式将 mysql 提供的 Driver 加载完毕。<br>
最后再来看看 DriverManager 调用 DriverManager.getConnection(“URL”,“user”,“password”) 的内容：<br>
// 使用了 mysql 提供的具体方法获取连接。</p>
<pre class="line-numbers language-none"><code class="language-none">public static Connection getConnection(String url,tring user, String password) throws SQLException &#123;
        &#x2F;&#x2F;将用户名和密码加入到Properties中
        java.util.Properties info &#x3D; new java.util.Properties();
        if (user !&#x3D; null) &#123;
            info.put(&quot;user&quot;, user);
        &#125;
        if (password !&#x3D; null) &#123;
            info.put(&quot;password&quot;, password);
        &#125;
        return (getConnection(url, info, Reflection.getCallerClass()));
    &#125;
private static Connection getConnection(String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123;
        ClassLoader callerCL &#x3D; caller !&#x3D; null ? caller.getClassLoader() : null;
        synchronized(DriverManager.class) &#123;
            if (callerCL &#x3D;&#x3D; null) &#123;
                callerCL &#x3D; Thread.currentThread().getContextClassLoader();
            &#125;
        &#125;
        if(url &#x3D;&#x3D; null) &#123;
            throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);、
        &#125;
        println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);
        SQLException reason &#x3D; null;
        
        &#x2F;&#x2F;遍历注册到registeredDrivers的Driver类
        for(DriverInfo aDriver : registeredDrivers) &#123;
            &#x2F;&#x2F;检查Driver类的有效性
            if(isDriverAllowed(aDriver.driver, callerCL)) &#123;
                try &#123;
                    println(&quot;    trying &quot; + aDriver.driver.getClass().getName());
                    &#x2F;&#x2F;调用com.myql.jdbc.Driver.connect(...)方法获取连接
                    Connection con &#x3D; aDriver.driver.connect(url, info);
                    if (con !&#x3D; null) &#123;
                        println(&quot;getConnection returning &quot; + 
aDriver.driver.getClass().getName());
                        return (con);
                    &#125;
                &#125; catch (SQLException ex) &#123;
                    if (reason &#x3D;&#x3D; null) &#123;
                        reason &#x3D; ex;
                    &#125;
                &#125;
            &#125; else &#123;
                println(&quot;    skipping: &quot; + aDriver.getClass().getName());
            &#125;
        &#125;
        if (reason !&#x3D; null)    &#123;
            println(&quot;getConnection failed: &quot; + reason);
            throw reason;
        &#125;
        println(&quot;getConnection: no suitable driver found for &quot;+ url);
        throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);
    &#125;
&#125;
private static boolean isDriverAllowed(Driver driver, ClassLoader 
classLoader) &#123;
        boolean result &#x3D; false;
        if(driver !&#x3D; null) &#123;
            Class&lt;?&gt; aClass &#x3D; null;
            try &#123;
                &#x2F;&#x2F;传入的classloader为调用getConnection的当前类加载器，从而寻找driver的class对象  
                aClass &#x3D;  Class.forName(driver.getClass().getName(), true, classLoader);
            &#125; catch (Exception ex) &#123;
                result &#x3D; false;
            &#125;
            
            &#x2F;&#x2F;注意，只有同一个类加载器的Class使用&#x3D;&#x3D;比较时才会相等，此处就是校验用户注册Driver时该Driver所属的类加载器和调用的类加载器是否是同一个
            &#x2F;&#x2F;driver.getClass()拿到的就是当初执行Class.forName(&quot;com.mysql.jdbc.Driver&quot;)时的应用AppClassLoader
             result &#x3D; ( aClass &#x3D;&#x3D; driver.getClass() ) ? true : false;
        &#125;
        return result;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>测试 26</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
 public class MyTest26&#123;
    public static void main(String[] args)&#123;
    
    &#x2F;&#x2F;一旦加入下面此行，将使用ExtClassLoader去加载Driver.class， ExtClassLoader不会去加载classpath，因此无法找到MySql的相关驱动。
 &#x2F;&#x2F;Thread.getCurrentThread().setContextClassLoader(MyTest26.class.getClassLoader().parent());    
 
        ServiceLoader服务提供者，加载实现的服务
        ServiceLoader&lt;Driver&gt; loader&#x3D;ServiceLoader.load(Driver.class);
        Iterator&lt;Driver&gt; iterator&#x3D;loader.iterator();
        while(iterator.hasNext())&#123;
            Driver driver&#x3D;iterator.next();
            System.out.println(&quot;driver:&quot;+driver.class+
                                &quot;,loader&quot;+driver.class.getClassLoader());
        &#125;
        System.out.println(&quot;当前上下文加载器&quot;
                    +Thread.currentThread().getContextClassLoader());
        System.out.println(&quot;ServiceLoader的加载器&quot;
                    +ServiceLoader.class.getClassLoader());
    &#125;
 &#125;     
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完结</p>
<h1>张龙内存机制</h1>
<p>字节码先看完了 45</p>
<p>指针碰撞（前提是堆内的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间）：当未被占用的空间被放置一个对象之后，指针就发生偏移。<br>
空闲列表（前提是堆内存空间中已被使用或未被使用的空间是交织在一起的）：这时，虚拟机就需要一个列表来记录哪些空间是可以使用的，哪些空间是已被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放对象，同时修改列表上的记录）。</p>
<p>对象在内存中的布局：</p>
<ul>
<li>对象头</li>
<li>实例数据（类中所声明的各项信息）</li>
<li>对齐填充（可选）</li>
</ul>
<p>对象引用访问的两种方式：</p>
<ul>
<li>句柄</li>
<li>直接指针</li>
</ul>
<p>附 1：另一个字节文件解析</p>
<p>这个文件的字节码部分：<a target="_blank" rel="noopener" href="https://download.csdn.net/download/hancoder/12834607">https://download.csdn.net/download/hancoder/12834607</a></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li>类加载：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38405354/article/details/100042169">https://blog.csdn.net/weixin_38405354/article/details/100042169</a></li>
<li>字节码：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38405354/article/details/100041386">https://blog.csdn.net/weixin_38405354/article/details/100041386</a></li>
<li>内存机制：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38405354/article/details/104712746">https://blog.csdn.net/weixin_38405354/article/details/104712746</a></li>
<li><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare1/index.html?id=9ff70d936a330dcd9d42ecb427602975&amp;type=notebook">https://note.youdao.com/ynoteshare1/index.html?id=9ff70d936a330dcd9d42ecb427602975&amp;type=notebook</a></li>
</ul>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>momo</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/" title="JVM笔记(黑马+尚硅谷+张龙整合笔记)">https://ppxiaodi.github.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/JVM%E7%AC%94%E8%AE%B0(%E9%BB%91%E9%A9%AC+%E5%B0%9A%E7%A1%85%E8%B0%B7+%E5%BC%A0%E9%BE%99%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0)/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E7%AC%94%E8%AE%B0_%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A73/" rel="prev" title="谷粒商城笔记_分布式高级3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">谷粒商城笔记_分布式高级3</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/Redis%E7%AC%94%E8%AE%B0(%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%BB%91%E9%A9%AC%E6%95%B4%E5%90%88)/" rel="next" title="Redis笔记(尚硅谷黑马整合)"><span class="post-nav-text">Redis笔记(尚硅谷黑马整合)</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> momo</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>