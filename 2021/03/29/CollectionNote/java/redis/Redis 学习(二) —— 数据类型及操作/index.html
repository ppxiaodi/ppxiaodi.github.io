<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="momo"><meta name="copyright" content="momo"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>数据类型及操作 | 我的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ppxiaodi.gitee.io","root":"/","title":"momo的小站","version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="Redis 学习(二) —— 数据类型及操作 Redis支持string、list、set、zset、hash等数据类型，这一篇学习redis的数据类型、命令及某些使用场景。 回到顶部 ¶一、String，字符串 字符串是 Redis 最基本的数据类型。一个字符串最大为 512M 字节。字符串数据类型适用于很多场景，例如，缓存 HTML 片段或者页面。 Redis 字符串是二进制安全的，也就是说，">
<meta property="og:type" content="article">
<meta property="og:title" content="数据类型及操作">
<meta property="og:url" content="https://ppxiaodi.gitee.io/2021/03/29/CollectionNote/java/redis/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E2%80%94%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="Redis 学习(二) —— 数据类型及操作 Redis支持string、list、set、zset、hash等数据类型，这一篇学习redis的数据类型、命令及某些使用场景。 回到顶部 ¶一、String，字符串 字符串是 Redis 最基本的数据类型。一个字符串最大为 512M 字节。字符串数据类型适用于很多场景，例如，缓存 HTML 片段或者页面。 Redis 字符串是二进制安全的，也就是说，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-28T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-11T08:54:53.979Z">
<meta property="article:author" content="momo">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="momo"><img width="96" loading="lazy" src="/yun.png" alt="momo"></a><div class="site-author-name"><a href="/about/">momo</a></div><a class="site-name" href="/about/site.html">我的笔记</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">199</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">58</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ 群 1050458482" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Redis 学习(二) —— 数据类型及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81String%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">一、String，字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81set-key-value-ex-%E7%A7%92%E6%95%B0-px-%E6%AF%AB%E7%A7%92%E6%95%B0-nx-xx"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、set key value [ex 秒数]&#x2F;[px 毫秒数] [nx]&#x2F;[xx]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81setnx-key-value%EF%BC%9Akey%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E8%AE%BE%E7%BD%AEvalue"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、setnx key value：key不存在时设置value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81get-key%EF%BC%9A%E8%8E%B7%E5%8F%96key%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、get key：获取key的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81mset-k1-v1-k2-v2-%E2%80%A6-kn-vn%EF%BC%9Amulti-set-%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、mset k1 v1 k2 v2 … kn vn：multi set 一次性设置多个键值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81msetnx-k1-v1-k2-v2-%E2%80%A6-kn-vn%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%EF%BC%8C%E5%BD%93%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E6%89%8D%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.1.5.</span> <span class="toc-text">5、msetnx k1 v1 k2 v2 … kn vn：设置多个键值，当键不存在时才设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81mget-k1-k2-%E2%80%A6-kn%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AAkey%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.6.</span> <span class="toc-text">6、mget k1 k2 … kn：获取多个key的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81setrange-key-offset-value%EF%BC%9A%E5%B0%86key%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%EF%BC%8C%E5%81%8F%E7%A7%BBoffset%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2%E4%B8%BAvalue%E3%80%82"><span class="toc-number">1.1.7.</span> <span class="toc-text">7、setrange key offset value：将key对应的值，偏移offset位置的字符替换为value。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81getrange-key-start-end%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD-start-end-%E8%8C%83%E5%9B%B4%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.8.</span> <span class="toc-text">8、getrange key start end：获取字符串中[start, end]范围的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81getset-key-newvalue%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%80%BC%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%96%B0%E5%80%BC"><span class="toc-number">1.1.9.</span> <span class="toc-text">9、getset key newvalue：获取原值，并设置新值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81append-key-value%EF%BC%9A%E6%8A%8Avalue%E8%BF%BD%E5%8A%A0%E5%88%B0key%E7%9A%84%E5%8E%9F%E5%80%BC%E4%B8%8A"><span class="toc-number">1.1.10.</span> <span class="toc-text">10、append key value：把value追加到key的原值上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81strlen-key%EF%BC%9A%E8%8E%B7%E5%8F%96key%E5%80%BC%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.1.11.</span> <span class="toc-text">11、strlen key：获取key值的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81incr-decr-key%EF%BC%9A%E6%8C%87%E5%AE%9Akey%E7%9A%84%E5%80%BC%E5%8A%A01%E6%88%96%E5%87%8F1%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%8A%A01%E6%88%96%E5%87%8F1%E5%90%8E%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.12.</span> <span class="toc-text">12、incr&#x2F;decr key：指定key的值加1或减1，返回加1或减1后的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81incrby-decrby-key-num%EF%BC%9A%E6%8C%87%E5%AE%9A%E7%9A%84key%E5%80%BC%E5%8A%A0%E6%88%96%E5%87%8Fnum%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%8A%A0num%E6%88%96%E5%87%8Fnum%E5%90%8E%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.13.</span> <span class="toc-text">13、incrby&#x2F;decrby key num：指定的key值加或减num，返回加num或减num后的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81incrbyfloat-key-float%EF%BC%9Akey%E5%80%BC%E5%8A%A0float%EF%BC%8Cfloat%E4%B8%BA%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.1.14.</span> <span class="toc-text">14、incrbyfloat key float：key值加float，float为浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81setbit-key-offset-value%EF%BC%9A%E8%AE%BE%E7%BD%AEkey%E5%80%BC%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E4%B8%8Aoffset%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.15.</span> <span class="toc-text">15、setbit key offset value：设置key值的二进制位上offset对应的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81getbit-key-offset%EF%BC%9A%E8%8E%B7%E5%8F%96key%E5%80%BC%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E4%B8%8Aoffset%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.16.</span> <span class="toc-text">16、getbit key offset：获取key值的二进制位上offset对应的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81bitop-operation-destkey-key1-key2-%E2%80%A6-keyn%EF%BC%9A%E5%AF%B9key1%E3%80%81key2-%E2%80%A6-keyn%E5%81%9Aoperation%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%88%B0destkey%E4%B8%8A"><span class="toc-number">1.1.17.</span> <span class="toc-text">17、bitop operation destkey key1 key2 … keyn：对key1、key2 … keyn做operation操作，并将结果保存到destkey上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81bitcount-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E8%A2%AB%E7%BD%AE%E4%B8%BA1%E7%9A%84%E4%BD%8D%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.1.18.</span> <span class="toc-text">18、bitcount key：返回被置为1的位的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81bitops-key-1-0%EF%BC%9A%E8%BF%94%E5%9B%9E%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A2%AB%E7%BD%AE%E4%B8%BA1-0%E7%9A%84%E4%BD%8D"><span class="toc-number">1.1.19.</span> <span class="toc-text">19、bitops key 1&#x2F;0：返回第一个被置为1&#x2F;0的位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81List%EF%BC%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二、List，链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81lpush-key-value%EF%BC%9A%E6%8A%8A%E5%80%BC%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、lpush key value：把值插入链表头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81lrange-key-start-end%EF%BC%9A%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E4%B8%AD-start-end-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、lrange key start end：返回链表中[start, end]中的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81rpush-key-value%EF%BC%9A%E6%8A%8A%E5%80%BC%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E9%83%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、rpush key value：把值插入链表的尾部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81lpop-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%B9%B6%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%A4%B4%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">4、lpop key：返回并删除链表头元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81rpop-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%B9%B6%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.5.</span> <span class="toc-text">5、rpop key：返回并删除链表尾部元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81lrem-key-count-value%EF%BC%9A%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4value%E5%80%BC"><span class="toc-number">1.2.6.</span> <span class="toc-text">6、lrem key count value：从链表中删除value值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81ltrim-key-start-end%EF%BC%9A%E6%88%AA%E5%8F%96-start-end-%E7%9A%84%E5%88%97%E8%A1%A8%E5%B9%B6%E9%87%8D%E6%96%B0%E8%B5%8B%E7%BB%99key"><span class="toc-number">1.2.7.</span> <span class="toc-text">7、ltrim key start end：截取[start, end]的列表并重新赋给key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81lindex-key-index%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E7%B4%A2%E5%BC%95index%E4%B8%8A%E7%9A%84%E5%80%BC"><span class="toc-number">1.2.8.</span> <span class="toc-text">8、lindex key index：返回列表索引index上的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81llen-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.2.9.</span> <span class="toc-text">9、llen key：返回列表的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81linsert-key-after-before-search-value%EF%BC%9A%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BEsearch%EF%BC%8C%E5%9C%A8search%E4%B9%8B%E5%90%8E-%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5value"><span class="toc-number">1.2.10.</span> <span class="toc-text">10、linsert key after|before search value：在列表中查找search，在search之后|之前插入value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81lset-key-index-value%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%88%97%E8%A1%A8index%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%BAvalue"><span class="toc-number">1.2.11.</span> <span class="toc-text">11、lset key index value：设置列表index位置的元素为value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81brpop-blpop-key-timeout%EF%BC%9A%E7%AD%89%E5%BE%85%E5%BC%B9%E5%87%BAkey%E7%9A%84%E5%B0%BE%E9%83%A8-%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.12.</span> <span class="toc-text">12、brpop&#x2F;blpop key timeout：等待弹出key的尾部&#x2F;头部元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81rpoplpush-source-dest%EF%BC%9A%E6%8A%8Asource%E7%9A%84%E5%B0%BE%E9%83%A8%E6%8B%BF%E5%87%BA%E6%9D%A5%E6%94%BE%E5%88%B0dest%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="toc-number">1.2.13.</span> <span class="toc-text">13、rpoplpush source dest：把source的尾部拿出来放到dest的头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81brpoplpush-source-dest-timout%EF%BC%9A%E7%AD%89%E5%BE%85%E5%BC%B9%E5%87%BA%EF%BC%8C%E6%94%BE%E5%88%B0dest%E4%B8%AD"><span class="toc-number">1.2.14.</span> <span class="toc-text">14、brpoplpush source dest timout：等待弹出，放到dest中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Set%EF%BC%8C%E9%9B%86%E5%90%88"><span class="toc-number">1.3.</span> <span class="toc-text">三、Set，集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81sadd-key-val1-val2-%E2%80%A6-valn%EF%BC%9A%E5%90%91%E9%9B%86%E5%90%88%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、sadd key val1 val2 … valn：向集合中添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81srandmember-key%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%88%96%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、srandmember key：随机或一个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81smembers-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、smembers key：返回列表的所有元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81sismember-key-value%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.</span> <span class="toc-text">4、sismember key value：判断是否存在某个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81scard-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">5、scard key：返回集合的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81spop-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%B9%B6%E5%88%A0%E9%99%A4%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.6.</span> <span class="toc-text">6、spop key：返回并删除其中一个随机元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81srem-val1-val2-%E2%80%A6-valn%EF%BC%9A%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.7.</span> <span class="toc-text">7、srem val1 val2 … valn：删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81smove-source-dest-value%EF%BC%9A%E5%B0%86source%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84value%E5%88%A0%E9%99%A4%E5%B9%B6%E7%A7%BB%E5%88%B0dest%E4%B8%AD"><span class="toc-number">1.3.8.</span> <span class="toc-text">8、smove source dest value：将source集合中的value删除并移到dest中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81sinter-k1-k2-%E2%80%A6-kn%EF%BC%9A%E6%B1%82%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">1.3.9.</span> <span class="toc-text">9、sinter k1 k2 … kn：求集合的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81sunion-k1-k2-%E2%80%A6-kn%EF%BC%9A%E6%B1%82%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86"><span class="toc-number">1.3.10.</span> <span class="toc-text">11、sunion k1 k2 … kn：求集合的并集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81sdiff-k1-k2-%E2%80%A6-kn%EF%BC%9A%E6%B1%82%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%AE%E9%9B%86"><span class="toc-number">1.3.11.</span> <span class="toc-text">12、sdiff k1 k2 … kn：求集合的差集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Sorted-Set%EF%BC%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">1.4.</span> <span class="toc-text">四、Sorted Set，有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81zadd-key-score1-value1-score2-value2-%E2%80%A6-scoren-valuen%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、zadd key score1 value1 score2 value2 … scoren valuen：添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81zrange-key-start-end-withscores-%EF%BC%9A%E8%8E%B7%E5%8F%96-start-end-%E7%9A%84%E5%85%83%E7%B4%A0-%E5%8D%87%E5%BA%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、zrange key start end [withscores]：获取[start, end]的元素(升序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81zrevrange-key-start-end-withscores-%EF%BC%9A%E8%8E%B7%E5%8F%96-start-end-%E7%9A%84%E5%85%83%E7%B4%A0-%E9%99%8D%E5%BA%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、zrevrange key start end [withscores]：获取[start, end]的元素(降序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81zrank-key-member%EF%BC%9A%E6%9F%A5member%E7%9A%84%E6%8E%92%E5%90%8D-%E5%8D%87%E5%BA%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、zrank key member：查member的排名(升序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81zrevrank-key-member%EF%BC%9A%E6%9F%A5member%E7%9A%84%E6%8E%92%E5%90%8D-%E9%99%8D%E5%BA%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、zrevrank key member：查member的排名(降序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81zcard-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">6、zcard key：返回元素个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81zcount-key-min-max%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%88%86%E6%95%B0-min-max-%E5%8C%BA%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.4.7.</span> <span class="toc-text">7、zcount key min max：返回分数[min, max]区间的元素个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81zscore-key-member%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E6%95%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">8、zscore key member：获取元素的分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81zrangebyscore-key-min-max-withscores-limit-offset-N-%EF%BC%9A%E8%8E%B7%E5%8F%96-min-max-%E5%8C%BA%E9%97%B4%E5%B9%B6%E5%81%8F%E7%A7%BBoffset%E4%B8%AA%EF%BC%8C%E5%8F%96%E5%87%BA%E5%90%8EN%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%8D%87%E5%BA%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">9、zrangebyscore key min max [withscores] [limit offset N]：获取[min, max]区间并偏移offset个，取出后N个元素(升序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81zrevrangebyscore-key-max-min-withscores-limit-offset-N-%EF%BC%9A%E8%8E%B7%E5%8F%96-max-min-%E5%8C%BA%E9%97%B4%E5%B9%B6%E5%81%8F%E7%A7%BBoffset%E4%B8%AA%EF%BC%8C%E5%8F%96%E5%87%BA%E5%90%8EN%E4%B8%AA%E5%85%83%E7%B4%A0-%E9%99%8D%E5%BA%8F"><span class="toc-number">1.4.10.</span> <span class="toc-text">10、zrevrangebyscore key max min [withscores] [limit offset N]：获取[max, min]区间并偏移offset个，取出后N个元素(降序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81zrem-key-value1-value2-%E2%80%A6-valuen%EF%BC%9A%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.11.</span> <span class="toc-text">11、zrem key value1 value2 … valuen：删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81zremrangebyscore-key-min-max%EF%BC%9A%E5%88%A0%E9%99%A4%E5%88%86%E6%95%B0-min-max-%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.12.</span> <span class="toc-text">12、zremrangebyscore key min max：删除分数[min, max]范围的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81zremrangebyrank-key-start-end%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%90%8D-min-max-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.13.</span> <span class="toc-text">13、zremrangebyrank key start end：删除排名[min, max]之间的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81zinterstore-dest-numkeys-key1-key2-%E2%80%A6-keyn-weights-weight1-weight2-%E2%80%A6-weightn-aggregate-sum-min-max"><span class="toc-number">1.4.14.</span> <span class="toc-text">14、zinterstore dest numkeys key1 [key2 … keyn] [weights weight1 [weight2 … weightn]] [aggregate sum|min|max]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Hash%EF%BC%8C%E5%93%88%E5%B8%8C"><span class="toc-number">1.5.</span> <span class="toc-text">五、Hash，哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81hset-key-field-value%EF%BC%9A%E8%AE%BE%E7%BD%AEkey%E4%B8%ADfield%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.1.</span> <span class="toc-text">1、hset key field value：设置key中field的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81hsetnx-key-field-value%EF%BC%9A%E5%BD%93%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E6%89%8D%E8%AE%BE%E7%BD%AE%E5%80%BC"><span class="toc-number">1.5.2.</span> <span class="toc-text">2、hsetnx key field value：当键不存在时才设置值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81hmset-key-field1-value1-%E2%80%A6-fieldn-valuen%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="toc-number">1.5.3.</span> <span class="toc-text">3、hmset key field1 value1 … fieldn valuen：设置多个键值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81hget-key-field%EF%BC%9A%E8%8E%B7%E5%8F%96key%E4%B8%ADfield%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.4.</span> <span class="toc-text">4、hget key field：获取key中field的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81hmget-key-field1-%E2%80%A6-fieldn%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-number">1.5.5.</span> <span class="toc-text">5、hmget key field1 … fieldn：获取多个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81hgetall-key%EF%BC%9A%E8%8E%B7%E5%8F%96key%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E9%94%AE%E5%80%BC"><span class="toc-number">1.5.6.</span> <span class="toc-text">6、hgetall key：获取key中所有的键值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81hdel-key-field%EF%BC%9A%E5%88%A0%E9%99%A4key%E4%B8%AD%E7%9A%84field"><span class="toc-number">1.5.7.</span> <span class="toc-text">7、hdel key field：删除key中的field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81hlen-key%EF%BC%9A%E8%BF%94%E5%9B%9Ekey%E4%B8%AD%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.5.8.</span> <span class="toc-text">8、hlen key：返回key中的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81hexists-key-field%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AAkey"><span class="toc-number">1.5.9.</span> <span class="toc-text">9、hexists key field：判断是否存在某个key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81hkeys-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E7%9A%84%E9%94%AE"><span class="toc-number">1.5.10.</span> <span class="toc-text">10、hkeys key：返回所有的键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81hvals-key%EF%BC%9A%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.11.</span> <span class="toc-text">11、hvals key：返回所有的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81hincyby-key-field-value%EF%BC%9A%E5%A2%9E%E5%8A%A0%E6%95%B4%E6%95%B0%E5%80%BC"><span class="toc-number">1.5.12.</span> <span class="toc-text">12、hincyby key field value：增加整数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81hincrbyfloat-key-field-value%EF%BC%9A%E5%A2%9E%E5%8A%A0%E5%B0%8F%E6%95%B0"><span class="toc-number">1.5.13.</span> <span class="toc-text">13、hincrbyfloat key field value：增加小数</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ppxiaodi.gitee.io/2021/03/29/CollectionNote/java/redis/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E2%80%94%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="momo"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据类型及操作</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-29T00:00:00+08:00">2021-03-29</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-07-11 16:54:53" itemprop="dateModified" datetime="2021-07-11T16:54:53+08:00">2021-07-11</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/redis/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">redis</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/redis/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">redis</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1>Redis 学习(二) —— 数据类型及操作</h1>
<p>Redis支持string、list、set、zset、hash等数据类型，这一篇学习redis的数据类型、命令及某些使用场景。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chiangchou/p/7748009.html#_labelTop">回到顶部</a></p>
<h2 id="一、String，字符串"><a class="header-anchor" href="#一、String，字符串">¶</a>一、String，字符串</h2>
<p>字符串是 Redis 最基本的数据类型。一个字符串最大为 512M 字节。字符串数据类型适用于很多场景，例如，缓存 HTML 片段或者页面。</p>
<p>Redis 字符串是二进制安全的，也就是说，一个 Redis 字符串可以包含任意类型的数据，例如一张 JPEG 图像，或者一个序列化的对象。</p>
<p>我们可以把字符串当做位数组(位图)来处理，很容易统计一些基于0/1逻辑的业务；</p>
<p>使用 INCR 命令族 (INCR，DECR，INCRBY)，将字符串作为原子计数器；</p>
<p>使用 APPEND 命令追加字符串等等。</p>
<h3 id="1、set-key-value-ex-秒数-px-毫秒数-nx-xx"><a class="header-anchor" href="#1、set-key-value-ex-秒数-px-毫秒数-nx-xx">¶</a>1、set key value [ex 秒数]/[px 毫秒数] [nx]/[xx]</h3>
<p>set name tom，永久有效。</p>
<p>set name tom ex 60，60秒后过期。</p>
<p>set name tom px 6000，6000毫秒(6秒)后过期。</p>
<p>ex、px 不能同时写，否则以后面一个时间为准。</p>
<p>如set name tom ex 60 px 6000，实际上6秒后就过期了。</p>
<p>nx表示key不存在时执行操作，xx表示key存在时执行操作。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028211128945-728507313.png)</p>
<h3 id="2、setnx-key-value：key不存在时设置value"><a class="header-anchor" href="#2、setnx-key-value：key不存在时设置value">¶</a>2、setnx key value：key不存在时设置value</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029001344758-5639978.png)</p>
<h3 id="3、get-key：获取key的值"><a class="header-anchor" href="#3、get-key：获取key的值">¶</a>3、get key：获取key的值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028212038633-1936400874.png)</p>
<h3 id="4、mset-k1-v1-k2-v2-…-kn-vn：multi-set-一次性设置多个键值"><a class="header-anchor" href="#4、mset-k1-v1-k2-v2-…-kn-vn：multi-set-一次性设置多个键值">¶</a>4、mset k1 v1 k2 v2 … kn vn：multi set 一次性设置多个键值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028211946398-1053069264.png)</p>
<h3 id="5、msetnx-k1-v1-k2-v2-…-kn-vn：设置多个键值，当键不存在时才设置"><a class="header-anchor" href="#5、msetnx-k1-v1-k2-v2-…-kn-vn：设置多个键值，当键不存在时才设置">¶</a>5、msetnx k1 v1 k2 v2 … kn vn：设置多个键值，当键不存在时才设置</h3>
<p>只要有一个存在就都不会被设置。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029001737273-30223088.png)</p>
<h3 id="6、mget-k1-k2-…-kn：获取多个key的值"><a class="header-anchor" href="#6、mget-k1-k2-…-kn：获取多个key的值">¶</a>6、mget k1 k2 … kn：获取多个key的值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028212111742-2137972222.png)</p>
<h3 id="7、setrange-key-offset-value：将key对应的值，偏移offset位置的字符替换为value。"><a class="header-anchor" href="#7、setrange-key-offset-value：将key对应的值，偏移offset位置的字符替换为value。">¶</a>7、setrange key offset value：将key对应的值，偏移offset位置的字符替换为value。</h3>
<p>返回新字符串的长度。</p>
<p>偏移量的下标以0开始，value有多少个长度，则替换多少个长度的字符。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028212835195-1187052708.png)</p>
<p>如果offset超出字符串的长度，则以空白的部分以0x00填充。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028213505023-1736873027.png)</p>
<h3 id="8、getrange-key-start-end：获取字符串中-start-end-范围的值"><a class="header-anchor" href="#8、getrange-key-start-end：获取字符串中-start-end-范围的值">¶</a>8、getrange key start end：获取字符串中[start, end]范围的值</h3>
<p>字符串下标左数从0开始，右数从-1开始。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028214141648-1754427684.png)</p>
<p>获取左边第二个(1)到右边第一个(-2)的值。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028214846336-231438016.png)</p>
<p>start &gt;= length，返回空字符串。end &gt;= length，截取至字符结尾。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028215328914-568535861.png)</p>
<h3 id="9、getset-key-newvalue：获取原值，并设置新值"><a class="header-anchor" href="#9、getset-key-newvalue：获取原值，并设置新值">¶</a>9、getset key newvalue：获取原值，并设置新值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028220034289-358379735.png)</p>
<h3 id="10、append-key-value：把value追加到key的原值上"><a class="header-anchor" href="#10、append-key-value：把value追加到key的原值上">¶</a>10、append key value：把value追加到key的原值上</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028213741226-919486319.png)</p>
<h3 id="11、strlen-key：获取key值的长度"><a class="header-anchor" href="#11、strlen-key：获取key值的长度">¶</a>11、strlen key：获取key值的长度</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029001932242-2063356096.png)</p>
<h3 id="12、incr-decr-key：指定key的值加1或减1，返回加1或减1后的值"><a class="header-anchor" href="#12、incr-decr-key：指定key的值加1或减1，返回加1或减1后的值">¶</a>12、incr/decr key：指定key的值加1或减1，返回加1或减1后的值</h3>
<p>incr/decr 命令将字符串值解析为整数，可作为原子计数器。incr 命令是原子的，因为即使多个客户端对同一个键发送 incr 命令也不会造成竞争条件，读 - 加/减 - 写操作在执行时，其他客户端此时不会执行相关命令。</p>
<p>incr/decr通常可用于计数、抢单的场合，例如有2000张火车票，同时有10万人抢2000张火车票，可能一分钟内就抢完了。如果同时去数据库查询剩余票数或下订单，数据库压力很大。</p>
<p>此时可在redis中设置一个票数的缓存，抢票的人先抢到下订单的资格，后台再慢慢去下订单更新数据库。获得资格后，自动减一，并返回了剩余票数。剩余票数为0，就可过滤掉绝大部分请求了。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028225643742-1539744827.png)</p>
<p>如果key不存在，则默认key为0，再执行加减的操作。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028230044758-1365245050.png)</p>
<h3 id="13、incrby-decrby-key-num：指定的key值加或减num，返回加num或减num后的值"><a class="header-anchor" href="#13、incrby-decrby-key-num：指定的key值加或减num，返回加num或减num后的值">¶</a>13、incrby/decrby key num：指定的key值加或减num，返回加num或减num后的值</h3>
<p>num为整数。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028231646258-285261501.png)</p>
<h3 id="14、incrbyfloat-key-float：key值加float，float为浮点数"><a class="header-anchor" href="#14、incrbyfloat-key-float：key值加float，float为浮点数">¶</a>14、incrbyfloat key float：key值加float，float为浮点数</h3>
<p>如果要减少，float为负数即可。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028232222539-950097723.png)</p>
<h3 id="15、setbit-key-offset-value：设置key值的二进制位上offset对应的值"><a class="header-anchor" href="#15、setbit-key-offset-value：设置key值的二进制位上offset对应的值">¶</a>15、setbit key offset value：设置key值的二进制位上offset对应的值</h3>
<p>例如，我要将大写的字母变为小写的字母，大写字母和小写字母相差32，差异就是大写字母二进制位偏移量2的位置为0，小写字母为1,。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028233224805-132085364.png)</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028233141586-1259441066.png)</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171028233505867-166197536.png)</p>
<p>经典的应用就是使用位图法统计活跃用户，例如统计连续一周登录用户。</p>
<p>如果有1亿用户，登录日志存储在数据库表中，表急剧增大，直接在数据库中统计，计算较慢。</p>
<p>那么使用位图法就能轻松解决这个问题，每天按日期生成一个位图(位数组)，用户是否登录就用1/0标识，用户登录后，把user_id位上的值置为1，标识该用户已登录。把一周的位图做and运算，位上为1的就是连续登录的用户。</p>
<p>一个位图算1亿个位，100000000/8/1024/1024 ≈ 12M，也就是说每天只需要12M就能存储1亿用户是否登录的情况，节约空间，计算方便。</p>
<p>ID为100000000的用户，设置周一、周二、周三连续登录，最后做AND操作，得出该用户连续登录：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029202356180-2133123296.png)</p>
<p>ID为5000的用户，周一登录，周二不登录，周三登录(可以不设置，默认填充0)，做AND操作，得出未连续登录：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029202732851-1805659852.png)</p>
<h3 id="16、getbit-key-offset：获取key值的二进制位上offset对应的值"><a class="header-anchor" href="#16、getbit-key-offset：获取key值的二进制位上offset对应的值">¶</a>16、getbit key offset：获取key值的二进制位上offset对应的值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029201338930-825271887.png)</p>
<h3 id="17、bitop-operation-destkey-key1-key2-…-keyn：对key1、key2-…-keyn做operation操作，并将结果保存到destkey上"><a class="header-anchor" href="#17、bitop-operation-destkey-key1-key2-…-keyn：对key1、key2-…-keyn做operation操作，并将结果保存到destkey上">¶</a>17、bitop operation destkey key1 key2 … keyn：对key1、key2 … keyn做operation操作，并将结果保存到destkey上</h3>
<p>operation 可以是AND、OR、NOT、XOR</p>
<h3 id="18、bitcount-key：返回被置为1的位的数量"><a class="header-anchor" href="#18、bitcount-key：返回被置为1的位的数量">¶</a>18、bitcount key：返回被置为1的位的数量</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031223429920-312814434.png)</p>
<h3 id="19、bitops-key-1-0：返回第一个被置为1-0的位"><a class="header-anchor" href="#19、bitops-key-1-0：返回第一个被置为1-0的位">¶</a>19、bitops key 1/0：返回第一个被置为1/0的位</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031223600951-319189275.png)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chiangchou/p/7748009.html#_labelTop">回到顶部</a></p>
<h2 id="二、List，链表"><a class="header-anchor" href="#二、List，链表">¶</a>二、List，链表</h2>
<p>Redis列表是简单的字符串列表，排序为插入的顺序。列表的最大长度为2^32 - 1 。</p>
<p>Redis 的列表是使用链表实现的。这意味着，即使你的列表中有上百万个元素，增加一个元素到列表的头部或者尾部的操作都是在常量时间完成。Redis 采用链表来实现列表是因为，对于数据库系统来说，快速插入一个元素到一个很长的列表非常重要。</p>
<p>我们可以用列表获取最新的内容(像帖子、微博等)，用ltrim很容易就获取最新的内容，并移除旧的内容。</p>
<p>用列表可以实现生产者消费者模式，生产者调用 lpush 添加项到列表中，消费者调用 rpop 从列表提取，如果没有元素，则轮询去获取，或者使用brpop等待生产者添加项到列表中。</p>
<h3 id="1、lpush-key-value：把值插入链表头部"><a class="header-anchor" href="#1、lpush-key-value：把值插入链表头部">¶</a>1、lpush key value：把值插入链表头部</h3>
<p>插入成功，返回列表的个数。可以同时插入多个值。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029173337648-266902728.png)</p>
<p><strong>lpushx key value：当key存在是才插入数据</strong></p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030122635183-1135697216.png)</p>
<h3 id="2、lrange-key-start-end：返回链表中-start-end-中的元素"><a class="header-anchor" href="#2、lrange-key-start-end：返回链表中-start-end-中的元素">¶</a>2、lrange key start end：返回链表中[start, end]中的元素</h3>
<p>左数从0开始，右数从-1开始。所以想取出全部元素可以用lrange key 0 -1。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029173636242-1287231584.png)</p>
<h3 id="3、rpush-key-value：把值插入链表的尾部"><a class="header-anchor" href="#3、rpush-key-value：把值插入链表的尾部">¶</a>3、rpush key value：把值插入链表的尾部</h3>
<p><strong>rpushx key value：当key存在是才插入数据。</strong></p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029173847758-2008253187.png)</p>
<h3 id="4、lpop-key：返回并删除链表头元素"><a class="header-anchor" href="#4、lpop-key：返回并删除链表头元素">¶</a>4、lpop key：返回并删除链表头元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029174112148-707833661.png)</p>
<h3 id="5、rpop-key：返回并删除链表尾部元素"><a class="header-anchor" href="#5、rpop-key：返回并删除链表尾部元素">¶</a>5、rpop key：返回并删除链表尾部元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029174255273-827962984.png)</p>
<h3 id="6、lrem-key-count-value：从链表中删除value值"><a class="header-anchor" href="#6、lrem-key-count-value：从链表中删除value值">¶</a>6、lrem key count value：从链表中删除value值</h3>
<p>删除count绝对值个value，count&gt;0，从头部开始删除；count&lt;0，从尾部开始删除。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029183317773-361892517.png)</p>
<h3 id="7、ltrim-key-start-end：截取-start-end-的列表并重新赋给key"><a class="header-anchor" href="#7、ltrim-key-start-end：截取-start-end-的列表并重新赋给key">¶</a>7、ltrim key start end：截取[start, end]的列表并重新赋给key</h3>
<p>有些时候我们只想用列表存储最近的项，我们可以使用ltrim命令仅仅只记住最近的10项，而丢弃所有老的项。可以很容易实现新增一个元素而抛弃超出的元素。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029183811133-1550491533.png)</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029183933023-326276855.png)</p>
<h3 id="8、lindex-key-index：返回列表索引index上的值"><a class="header-anchor" href="#8、lindex-key-index：返回列表索引index上的值">¶</a>8、lindex key index：返回列表索引index上的值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029184238023-830429642.png)</p>
<h3 id="9、llen-key：返回列表的个数"><a class="header-anchor" href="#9、llen-key：返回列表的个数">¶</a>9、llen key：返回列表的个数</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029184339398-1719908688.png)</p>
<h3 id="10、linsert-key-after-before-search-value：在列表中查找search，在search之后-之前插入value"><a class="header-anchor" href="#10、linsert-key-after-before-search-value：在列表中查找search，在search之后-之前插入value">¶</a>10、linsert key after|before search value：在列表中查找search，在search之后|之前插入value</h3>
<p>只会在第一个匹配的search之后|之前插入，不会插入多个value。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029185215273-343697653.png)</p>
<h3 id="11、lset-key-index-value：设置列表index位置的元素为value"><a class="header-anchor" href="#11、lset-key-index-value：设置列表index位置的元素为value">¶</a>11、lset key index value：设置列表index位置的元素为value</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030123053965-821813983.png)</p>
<h3 id="12、brpop-blpop-key-timeout：等待弹出key的尾部-头部元素"><a class="header-anchor" href="#12、brpop-blpop-key-timeout：等待弹出key的尾部-头部元素">¶</a>12、brpop/blpop key timeout：等待弹出key的尾部/头部元素</h3>
<p>如果有元素则直接弹出，没有则阻塞，timeout为等待超时时间，如果timeout为0，则一直等待。</p>
<p>一般可用于轮询，在线聊天，例如有一个message列表，在获取消息的时候，没有就等待，有就弹出。</p>
<p>使用一个终端来等待消息：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029192602820-1259328802.png)</p>
<p>另一个终端插入消息：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029192827742-130005274.png)</p>
<p>消息被弹出：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029192856320-2075692416.png)</p>
<p>等待超时：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029193016836-914897781.png)</p>
<h3 id="13、rpoplpush-source-dest：把source的尾部拿出来放到dest的头部"><a class="header-anchor" href="#13、rpoplpush-source-dest：把source的尾部拿出来放到dest的头部">¶</a>13、rpoplpush source dest：把source的尾部拿出来放到dest的头部</h3>
<p>使用rpoplpush相比分开rpop，lpush两步操作是原子性的，使用 rpoplpush 可以构建更安全的队列和旋转队列。</p>
<p>rpoplpush一般可用于构建安全任务队列，比如有一个任务队列task，每次从中取出一个任务来执行，放到另一个列表bak来备份。这样任务如果执行成功，从bak列表中移除该任务；失败，可以再拿回task列表。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171029191218273-369708876.png)</p>
<h3 id="14、brpoplpush-source-dest-timout：等待弹出，放到dest中"><a class="header-anchor" href="#14、brpoplpush-source-dest-timout：等待弹出，放到dest中">¶</a>14、brpoplpush source dest timout：等待弹出，放到dest中</h3>
<p>结合了brpop喝rpoplpush的特性，有则弹出放到另一个列表，没有则等待。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030122038777-887357659.png)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chiangchou/p/7748009.html#_labelTop">回到顶部</a></p>
<h2 id="三、Set，集合"><a class="header-anchor" href="#三、Set，集合">¶</a>三、Set，集合</h2>
<p>Redis 集合是无序的字符串集合，集合中的值是唯一的、无序的。可以对集合执行很多操作，例如，测试元素是否存在，对多个集合执行交集、并集和差集，等等。</p>
<p>我们通常可以用集合存储一些无关顺序的，表达对象间关系的数据，例如用户的角色，可以用sismember很容易就判断用户是否拥有某个角色。</p>
<p>在一些用到随机值的场合是非常适合的，可以用 srandmember/spop 获取/弹出一个随机元素。</p>
<h3 id="1、sadd-key-val1-val2-…-valn：向集合中添加元素"><a class="header-anchor" href="#1、sadd-key-val1-val2-…-valn：向集合中添加元素">¶</a>1、sadd key val1 val2 … valn：向集合中添加元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030231030902-1336508295.png)</p>
<h3 id="2、srandmember-key：随机或一个元素"><a class="header-anchor" href="#2、srandmember-key：随机或一个元素">¶</a>2、srandmember key：随机或一个元素</h3>
<p>在string和list的命令中，可以通过range来获取某几个字符或某几个元素，但集合是无序的，无法通过下标或范围来访问部分元素，因此要么随机选一个，要么全选。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030231345808-2042556485.png)</p>
<h3 id="3、smembers-key：返回列表的所有元素"><a class="header-anchor" href="#3、smembers-key：返回列表的所有元素">¶</a>3、smembers key：返回列表的所有元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030232045011-523398882.png)</p>
<h3 id="4、sismember-key-value：判断是否存在某个元素"><a class="header-anchor" href="#4、sismember-key-value：判断是否存在某个元素">¶</a>4、sismember key value：判断是否存在某个元素</h3>
<p>存在则返回1，不存在则返回0</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030231843277-1201945856.png)</p>
<h3 id="5、scard-key：返回集合的个数"><a class="header-anchor" href="#5、scard-key：返回集合的个数">¶</a>5、scard key：返回集合的个数</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030232135215-315459275.png)</p>
<h3 id="6、spop-key：返回并删除其中一个随机元素"><a class="header-anchor" href="#6、spop-key：返回并删除其中一个随机元素">¶</a>6、spop key：返回并删除其中一个随机元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030232252918-1995713255.png)</p>
<h3 id="7、srem-val1-val2-…-valn：删除元素"><a class="header-anchor" href="#7、srem-val1-val2-…-valn：删除元素">¶</a>7、srem val1 val2 … valn：删除元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030232447402-1715275507.png)</p>
<h3 id="8、smove-source-dest-value：将source集合中的value删除并移到dest中"><a class="header-anchor" href="#8、smove-source-dest-value：将source集合中的value删除并移到dest中">¶</a>8、smove source dest value：将source集合中的value删除并移到dest中</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030232711027-330203852.png)</p>
<h3 id="9、sinter-k1-k2-…-kn：求集合的交集"><a class="header-anchor" href="#9、sinter-k1-k2-…-kn：求集合的交集">¶</a>9、sinter k1 k2 … kn：求集合的交集</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030233613465-1511098222.png)</p>
<p><strong>sinterstore dest k1 k2 … kn：求集合的交集，并将结果赋给dest</strong></p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030233749418-538649547.png)</p>
<h3 id="11、sunion-k1-k2-…-kn：求集合的并集"><a class="header-anchor" href="#11、sunion-k1-k2-…-kn：求集合的并集">¶</a>11、sunion k1 k2 … kn：求集合的并集</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030233955090-1329146219.png)</p>
<p>同理，sunionstore则将并集的结果赋给dest。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030234036277-2009229719.png)</p>
<p><strong>可以用sunionstore复制一个集合</strong></p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031220040451-1600835442.png)</p>
<h3 id="12、sdiff-k1-k2-…-kn：求集合的差集"><a class="header-anchor" href="#12、sdiff-k1-k2-…-kn：求集合的差集">¶</a>12、sdiff k1 k2 … kn：求集合的差集</h3>
<p>即k1-k2-kn</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171030234608371-2134081783.png)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chiangchou/p/7748009.html#_labelTop">回到顶部</a></p>
<h2 id="四、Sorted-Set，有序集合"><a class="header-anchor" href="#四、Sorted-Set，有序集合">¶</a>四、Sorted Set，有序集合</h2>
<p>有序集合由唯一的，不重复的字符串元素组成。有序集合中的每个元素都关联了一个浮点值，称为分数。可以把有序看成hash和集合的混合体，分数即为hash的key。</p>
<p>有序集合中的元素是按序存储的，不是请求时才排序的。</p>
<h3 id="1、zadd-key-score1-value1-score2-value2-…-scoren-valuen：添加元素"><a class="header-anchor" href="#1、zadd-key-score1-value1-score2-value2-…-scoren-valuen：添加元素">¶</a>1、zadd key score1 value1 score2 value2 … scoren valuen：添加元素</h3>
<p>score为分数，他们按照如下规则排序：</p>
<ul>
<li>如果 A 和 B 是拥有不同分数的元素，A.score &gt; B.score，则 A &gt; B。</li>
<li>如果 A 和 B 是有相同的分数的元素，如果按字典顺序 A 大于 B，则 A &gt; B。A 和 B 不能相同，因为排序集合只能有唯一元素。</li>
</ul>
<p>向有序集合中添加元素，会自动排序且为升序</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031230410404-1086126331.png)</p>
<p>有序集合的分数可以重复，但值不能重复，元素是唯一的。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031230850420-1770472310.png)</p>
<h3 id="2、zrange-key-start-end-withscores-：获取-start-end-的元素-升序"><a class="header-anchor" href="#2、zrange-key-start-end-withscores-：获取-start-end-的元素-升序">¶</a>2、zrange key start end [withscores]：获取[start, end]的元素(升序)</h3>
<p>withscores，是否显示排序分数。zrange默认返回升序序列。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031232253748-840762581.png)</p>
<h3 id="3、zrevrange-key-start-end-withscores-：获取-start-end-的元素-降序"><a class="header-anchor" href="#3、zrevrange-key-start-end-withscores-：获取-start-end-的元素-降序">¶</a>3、zrevrange key start end [withscores]：获取[start, end]的元素(降序)</h3>
<p>与zrange获取的顺序相反。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031232558326-1006692034.png)</p>
<h3 id="4、zrank-key-member：查member的排名-升序"><a class="header-anchor" href="#4、zrank-key-member：查member的排名-升序">¶</a>4、zrank key member：查member的排名(升序)</h3>
<p>返回的排名升序从下标0开始</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031231448576-806147938.png)</p>
<h3 id="5、zrevrank-key-member：查member的排名-降序"><a class="header-anchor" href="#5、zrevrank-key-member：查member的排名-降序">¶</a>5、zrevrank key member：查member的排名(降序)</h3>
<p>返回的排名降序从下标0开始</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031231730576-392885375.png)</p>
<h3 id="6、zcard-key：返回元素个数"><a class="header-anchor" href="#6、zcard-key：返回元素个数">¶</a>6、zcard key：返回元素个数</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031232741185-1513565122.png)</p>
<h3 id="7、zcount-key-min-max：返回分数-min-max-区间的元素个数"><a class="header-anchor" href="#7、zcount-key-min-max：返回分数-min-max-区间的元素个数">¶</a>7、zcount key min max：返回分数[min, max]区间的元素个数</h3>
<p>+inf表示正无穷，-inf表示负无穷。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031233108248-106561463.png)</p>
<h3 id="8、zscore-key-member：获取元素的分数"><a class="header-anchor" href="#8、zscore-key-member：获取元素的分数">¶</a>8、zscore key member：获取元素的分数</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101222421607-1217366188.png)</p>
<h3 id="9、zrangebyscore-key-min-max-withscores-limit-offset-N-：获取-min-max-区间并偏移offset个，取出后N个元素-升序"><a class="header-anchor" href="#9、zrangebyscore-key-min-max-withscores-limit-offset-N-：获取-min-max-区间并偏移offset个，取出后N个元素-升序">¶</a>9、zrangebyscore key min max [withscores] [limit offset N]：获取[min, max]区间并偏移offset个，取出后N个元素(升序)</h3>
<p>类似于分页查询，如果N超出个数，返回直到结尾。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031234047591-64948708.png)</p>
<h3 id="10、zrevrangebyscore-key-max-min-withscores-limit-offset-N-：获取-max-min-区间并偏移offset个，取出后N个元素-降序"><a class="header-anchor" href="#10、zrevrangebyscore-key-max-min-withscores-limit-offset-N-：获取-max-min-区间并偏移offset个，取出后N个元素-降序">¶</a>10、zrevrangebyscore key max min [withscores] [limit offset N]：获取[max, min]区间并偏移offset个，取出后N个元素(降序)</h3>
<p>与zrangebyscore顺序相反，注意范围是[max, min]</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031234759685-1642103947.png)</p>
<h3 id="11、zrem-key-value1-value2-…-valuen：删除元素"><a class="header-anchor" href="#11、zrem-key-value1-value2-…-valuen：删除元素">¶</a>11、zrem key value1 value2 … valuen：删除元素</h3>
<p>从这里也可以看出有序集合中的元素是唯一性的。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031233311341-1328368592.png)</p>
<h3 id="12、zremrangebyscore-key-min-max：删除分数-min-max-范围的元素"><a class="header-anchor" href="#12、zremrangebyscore-key-min-max：删除分数-min-max-范围的元素">¶</a>12、zremrangebyscore key min max：删除分数[min, max]范围的元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031235316873-498737788.png)</p>
<h3 id="13、zremrangebyrank-key-start-end：删除排名-min-max-之间的元素"><a class="header-anchor" href="#13、zremrangebyrank-key-start-end：删除排名-min-max-之间的元素">¶</a>13、zremrangebyrank key start end：删除排名[min, max]之间的元素</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171031235715029-1374233405.png)</p>
<h3 id="14、zinterstore-dest-numkeys-key1-key2-…-keyn-weights-weight1-weight2-…-weightn-aggregate-sum-min-max"><a class="header-anchor" href="#14、zinterstore-dest-numkeys-key1-key2-…-keyn-weights-weight1-weight2-…-weightn-aggregate-sum-min-max">¶</a>14、zinterstore dest numkeys key1 [key2 … keyn] [weights weight1 [weight2 … weightn]] [aggregate sum|min|max]</h3>
<p>求key1、key2的交集，key1、key2的权重分别是weight1、weight2；numkeys指定key的个数。</p>
<p>聚合方法为sum|min|max，结果保存到dest中，默认交集求和。可以看做先做交集再做后面的运算。</p>
<p>同样，取并集用zunionstore，其余参数一样。</p>
<p>添加两组数据：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101003149185-1040753235.png)</p>
<p>交集求和：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101003325029-1536536455.png)</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101002930763-208074519.png)</p>
<p>交集最大值：</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101003027654-1314445244.png)</p>
<p>交集加上权重取最大值：加上权重时：score = score * weight</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101003455560-1310642649.png)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chiangchou/p/7748009.html#_labelTop">回到顶部</a></p>
<h2 id="五、Hash，哈希"><a class="header-anchor" href="#五、Hash，哈希">¶</a>五、Hash，哈希</h2>
<p>Redis的哈希值是字符串字段和字符串值之间的映射，是表示对象的完美数据类型。</p>
<p>哈希中的字段数量没有限制，所以你可以在你的应用程序以不同的方式来使用哈希。</p>
<h3 id="1、hset-key-field-value：设置key中field的值"><a class="header-anchor" href="#1、hset-key-field-value：设置key中field的值">¶</a>1、hset key field value：设置key中field的值</h3>
<p>没有field则写入，有则覆盖</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101223512545-867213512.png)</p>
<h3 id="2、hsetnx-key-field-value：当键不存在时才设置值"><a class="header-anchor" href="#2、hsetnx-key-field-value：当键不存在时才设置值">¶</a>2、hsetnx key field value：当键不存在时才设置值</h3>
<p>使用hsetnx就不会覆盖原值</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101225739591-1704288606.png)</p>
<h3 id="3、hmset-key-field1-value1-…-fieldn-valuen：设置多个键值"><a class="header-anchor" href="#3、hmset-key-field1-value1-…-fieldn-valuen：设置多个键值">¶</a>3、hmset key field1 value1 … fieldn valuen：设置多个键值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101223706716-1087627181.png)</p>
<h3 id="4、hget-key-field：获取key中field的值"><a class="header-anchor" href="#4、hget-key-field：获取key中field的值">¶</a>4、hget key field：获取key中field的值</h3>
<h3 id="5、hmget-key-field1-…-fieldn：获取多个值"><a class="header-anchor" href="#5、hmget-key-field1-…-fieldn：获取多个值">¶</a>5、hmget key field1 … fieldn：获取多个值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101223829123-1942450775.png)</p>
<h3 id="6、hgetall-key：获取key中所有的键值"><a class="header-anchor" href="#6、hgetall-key：获取key中所有的键值">¶</a>6、hgetall key：获取key中所有的键值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101223906045-715628029.png)</p>
<h3 id="7、hdel-key-field：删除key中的field"><a class="header-anchor" href="#7、hdel-key-field：删除key中的field">¶</a>7、hdel key field：删除key中的field</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101224035326-1860426450.png)</p>
<h3 id="8、hlen-key：返回key中的个数"><a class="header-anchor" href="#8、hlen-key：返回key中的个数">¶</a>8、hlen key：返回key中的个数</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101224126279-1311055930.png)</p>
<h3 id="9、hexists-key-field：判断是否存在某个key"><a class="header-anchor" href="#9、hexists-key-field：判断是否存在某个key">¶</a>9、hexists key field：判断是否存在某个key</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101224226341-1005634926.png)</p>
<h3 id="10、hkeys-key：返回所有的键"><a class="header-anchor" href="#10、hkeys-key：返回所有的键">¶</a>10、hkeys key：返回所有的键</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101225444748-1557832390.png)</p>
<h3 id="11、hvals-key：返回所有的值"><a class="header-anchor" href="#11、hvals-key：返回所有的值">¶</a>11、hvals key：返回所有的值</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101225515341-1738625993.png)</p>
<h3 id="12、hincyby-key-field-value：增加整数值"><a class="header-anchor" href="#12、hincyby-key-field-value：增加整数值">¶</a>12、hincyby key field value：增加整数值</h3>
<p>只能增加整数，不能增加小数。也可以增加负数。</p>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101230122482-2062466154.png)</p>
<h3 id="13、hincrbyfloat-key-field-value：增加小数"><a class="header-anchor" href="#13、hincrbyfloat-key-field-value：增加小数">¶</a>13、hincrbyfloat key field value：增加小数</h3>
<p>![img](Redis 学习(二) —— 数据类型及操作/856154-20171101230418904-768845251.png)</p>
<hr>
<p>redis数据类型基本学完，下一篇学习事物、消息订阅等。</p>
<p>完！！！</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>momo</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://ppxiaodi.gitee.io/2021/03/29/CollectionNote/java/redis/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E2%80%94%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C/" title="数据类型及操作">https://ppxiaodi.gitee.io/2021/03/29/CollectionNote/java/redis/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E2%80%94%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/03/29/CollectionNote/java/mysql/%E8%A7%A6%E5%8F%91%E5%99%A8/" rel="prev" title="触发器"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">触发器</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/03/29/CollectionNote/java/redis/RedisTemplate%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BBRedisUtils/" rel="next" title="RedisTemplate通用工具类RedisUtils"><span class="post-nav-text">RedisTemplate通用工具类RedisUtils</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> momo</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>