<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="momo"><meta name="copyright" content="momo"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>认证服务_验证码、社交登录、分布式 session、单点登录 | 我的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ppxiaodi.gitee.io","root":"/","title":"momo的小站","version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="认证服务_验证码、社交登录、分布式 session、单点登录  图片未下载到本地   本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net   本文是谷粒商城项目笔记 打赏与索要笔记请看谷粒商城的笔记末尾  ¶认证服务 ¶1 gulimall-auth-server 创建gulimall-auth-server微服务，导入依赖，引入login.html和reg.html，并">
<meta property="og:type" content="article">
<meta property="og:title" content="认证服务_验证码、社交登录、分布式 session、单点登录">
<meta property="og:url" content="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="认证服务_验证码、社交登录、分布式 session、单点登录  图片未下载到本地   本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net   本文是谷粒商城项目笔记 打赏与索要笔记请看谷粒商城的笔记末尾  ¶认证服务 ¶1 gulimall-auth-server 创建gulimall-auth-server微服务，导入依赖，引入login.html和reg.html，并">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190524214449242.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/690ea78bd63dc40da24d629c8934f4c2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/bc0c877c555ed6b992607f3c69ce9f5b.gif">
<meta property="og:image" content="https://fermhan.oss-cn-qingdao.aliyuncs.com/img/20210228144701.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/81582c3f7407aeb38e390e22f1556184.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b3e6040714dc676fecb24d3a1c7af97b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/fb76e9a30e844c5c1ec50020cf2f67e1.png">
<meta property="article:published_time" content="2020-03-13T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-11T08:54:54.210Z">
<meta property="article:author" content="momo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="谷粒商城">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190524214449242.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="momo"><img width="96" loading="lazy" src="/yun.png" alt="momo"></a><div class="site-author-name"><a href="/about/">momo</a></div><a class="site-name" href="/about/site.html">我的笔记</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">198</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">58</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ 群 1050458482" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">认证服务_验证码、社交登录、分布式 session、单点登录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">认证服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-gulimall-auth-server"><span class="toc-number">1.1.1.</span> <span class="toc-text">1 gulimall-auth-server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">2 注册验证码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%80%92%E8%AE%A1%E6%97%B6"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">(1) 验证码倒计时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%98%BF%E9%87%8C%E4%BA%91-%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">(2) 阿里云 - 短信服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">(3) 接口防刷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%A8%E5%86%8C-VO"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">(4) 注册 VO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7%E4%BF%9D%E5%AD%98"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">(5) 注册用户保存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">(6) 密码加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">(7) 用户名密码登录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">3 社交登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-OAuth2-0"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">(1) OAuth2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BE%AE%E5%8D%9A%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">(2) 微博开放平台使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">(3) 代码编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#weibo-success"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">&#x2F;weibo&#x2F;success</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#token-%E4%BF%9D%E5%AD%98"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">token 保存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-SpringSession"><span class="toc-number">1.1.4.</span> <span class="toc-text">4 SpringSession</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-session-%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">(1) session 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F-session-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">(2) 分布式 session 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-session-%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">1) session 复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-hash-%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">2) hash 一致性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-redis-%E7%BB%9F%E4%B8%80%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">3) redis 统一存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SpringSession-%E6%95%B4%E5%90%88-redis"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">(3) SpringSession 整合 redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">1) 环境搭建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%A9%E5%A4%A7-session-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">2) 扩大 session 作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-SpringSession-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">(4) SpringSession 核心原理 - 装饰者模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%99%BB%E5%BD%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">分布式登录总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">1.1.6.</span> <span class="toc-text">5 单点登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sso-%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">sso 思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">开源项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sso-%E8%A7%A3%E5%86%B3"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">sso 解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#server"><span class="toc-number">1.1.6.4.1.</span> <span class="toc-text">server</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="momo"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">认证服务_验证码、社交登录、分布式 session、单点登录</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">2020-03-14</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-07-11 16:54:54" itemprop="dateModified" datetime="2021-07-11T16:54:54+08:00">2021-07-11</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">谷粒商城</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a><a class="tag-item" href="/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">谷粒商城</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1>认证服务_验证码、社交登录、分布式 session、单点登录</h1>
<blockquote>
<p>图片未下载到本地</p>
</blockquote>
<blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/114242184">blog.csdn.net</a></p>
</blockquote>
<blockquote>
<p>本文是谷粒商城项目笔记</p>
<p>打赏与索要笔记请看谷粒商城的笔记末尾</p>
</blockquote>
<h2 id="认证服务"><a class="header-anchor" href="#认证服务">¶</a>认证服务</h2>
<h3 id="1-gulimall-auth-server"><a class="header-anchor" href="#1-gulimall-auth-server">¶</a><strong>1 gulimall-auth-server</strong></h3>
<p>创建<code>gulimall-auth-server</code>微服务，导入依赖，引入<code>login.html</code>和<code>reg.html</code>，并把静态资源放到 nginx 的 static 目录下，修改 hosts 192.168.56.10 <a target="_blank" rel="noopener" href="http://auth.gulimall.com">auth.gulimall.com</a></p>
<p>网关配置启动起来即可</p>
<p>登录：<a target="_blank" rel="noopener" href="http://auth.gulimall.com/">http://auth.gulimall.com/</a></p>
<p>注册：<a target="_blank" rel="noopener" href="http://auth.gulimall.com/reg.html">http://auth.gulimall.com/reg.html</a></p>
<p>主页：<a target="_blank" rel="noopener" href="http://gulimall.com/">http://gulimall.com/</a></p>
<h3 id="2-注册验证码"><a class="header-anchor" href="#2-注册验证码">¶</a><strong>2 注册验证码</strong></h3>
<h4 id="1-验证码倒计时"><a class="header-anchor" href="#1-验证码倒计时">¶</a>(1) 验证码倒计时</h4>
<p>点击获取验证码后，进入倒计时</p>
<ul>
<li>计时功能可以使用 js 的 timing 计时时间，setTimeout() 可以设置一段时间后执行代码</li>
<li>递归回调可以解决倒计时刷新的功能</li>
<li>开始倒计时后设置按钮不可用<code>$(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;disabled&quot;)</code></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$(function () &#123;
    $(&quot;#sendCode&quot;).click(function () &#123;
        if ($(this).hasClass(&quot;disabled&quot;)) &#123;
            &#x2F;&#x2F; 1.进入倒计时效果
        &#125; else &#123;
            $.get(&quot;&#x2F;sms&#x2F;snedcode?phone&#x3D;&quot; + $(&quot;#phoneNum&quot;).val(), function (data) &#123;
                if (data.code !&#x3D; 0) &#123;
                    layer.msg(data.msg)
                &#125;
            &#125;);
            &#x2F;&#x2F; 2.给指定手机号发送验证码
            timeoutChangeStyle()
        &#125;
    &#125;)
&#125;)

let num &#x3D; 60;

function timeoutChangeStyle() &#123;
    $(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;disabled&quot;)
    if (num &#x3D;&#x3D; 0) &#123;
        num &#x3D; 60;
        $(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;&quot;);
        $(&quot;#sendCode&quot;).text(&quot;发送验证码&quot;);
    &#125; else &#123;
        var str &#x3D; num + &quot;s 后再次发送&quot;;
        $(&quot;#sendCode&quot;).text(str);
        &#x2F;&#x2F; 1s后回调
        setTimeout(&quot;timeoutChangeStyle()&quot;, 1000);
    &#125;
    num--
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 controller 只是跳转视图功能</p>
<pre class="line-numbers language-none"><code class="language-none">@Configuration
public class MyWebConfig implements WebMvcConfigurer &#123;

    @Override
    public void addViewControllers(ViewControllerRegistry registry) &#123;

        registry.addViewController(&quot;&#x2F;reg.html&quot;).setViewName(&quot;reg&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-阿里云-短信服务"><a class="header-anchor" href="#2-阿里云-短信服务">¶</a>(2) 阿里云 - 短信服务</h4>
<p><a target="_blank" rel="noopener" href="https://market.aliyun.com/products/?keywords">https://market.aliyun.com/products/?keywords</a> = 短信</p>
<p>购买页面下有请求的 url，点击去调试测试</p>
<p>请求参数：</p>
<table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">是否必须</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">content</td><td align="center">STRING</td><td align="center">必选</td><td align="center">模板中变量名与参数值，多项值以 "," 分隔</td></tr><tr><td align="center">phone_number</td><td align="center">STRING</td><td align="center">必选</td><td align="center">手机号码</td></tr><tr><td align="center">template_id</td><td align="center">STRING</td><td align="center">必选</td><td align="center">模板 ID</td></tr></tbody></table>
<p>一般来说，就是 html 发送给 java，java 再发送给短信服务商。用户接收到验证码后，发送过来填写的验证码，进行验证。</p>
<p>逻辑：</p>
<ul>
<li>认证服务中短信 controller 接收到电话号请求后，认证服务生成一个验证码</li>
<li>认证服务发送<code>电话+验证码</code>，调用第三方服务</li>
<li>第三方服务调用短信服务商提供的接口，让短信服务商给手机发送生成好的验证码信息</li>
<li>手机接收到验证码后，封装到账号信息中，发送给注册 controller</li>
</ul>
<p>在<code>gulimall-third-party</code>中编写发送短信组件, 其中<code>host</code>、<code>path</code>、<code>appcode</code>可以在配置文件中使用前缀<code>spring.cloud.alicloud.sms</code>进行配置</p>
<pre class="line-numbers language-none"><code class="language-none">@Data
@ConfigurationProperties(prefix &#x3D; &quot;spring.cloud.alicloud.sms&quot;)
@Component
public class SmsComponent &#123;

	private String host;

	private String path;

	private String skin;

	private String sign;

	private String appCode;

	public String sendSmsCode(String phone, String code)&#123;
		String method &#x3D; &quot;GET&quot;;
		Map&lt;String, String&gt; headers &#x3D; new HashMap&lt;String, String&gt;();
		&#x2F;&#x2F;最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
		headers.put(&quot;Authorization&quot;, &quot;APPCODE &quot; + this.appCode);
		Map&lt;String, String&gt; querys &#x3D; new HashMap&lt;String, String&gt;();
		querys.put(&quot;code&quot;, code);
		querys.put(&quot;phone&quot;, phone);
		querys.put(&quot;skin&quot;, this.skin);
		querys.put(&quot;sign&quot;, this.sign);
		HttpResponse response &#x3D; null;
		try &#123;
			response &#x3D; HttpUtils.doGet(this.host, this.path, method, headers, querys);
			&#x2F;&#x2F;获取response的body
			if(response.getStatusLine().getStatusCode() &#x3D;&#x3D; 200)&#123;
				return EntityUtils.toString(response.getEntity());
			&#125;
		&#125; catch (Exception e) &#123;
			e.printStackTrace();
		&#125;
		return &quot;fail_&quot; + response.getStatusLine().getStatusCode();
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编写 controller，给别的服务提供远程调用发送验证码的接口</p>
<pre class="line-numbers language-none"><code class="language-none">@Controller
@RequestMapping(&quot;&#x2F;sms&quot;)
public class SmsSendController &#123;

    @Autowired
    private SmsComponent smsComponent;

    &#x2F;*** 提供给别的服务进行调用的
	 *&#x2F;
    @GetMapping(&quot;&#x2F;sendcode&quot;)
    public R sendCode(@RequestParam(&quot;phone&quot;) String phone, @RequestParam(&quot;code&quot;) String code)&#123;
        if(!&quot;fail&quot;.equals(smsComponent.sendSmsCode(phone, code).split(&quot;_&quot;)[0]))&#123;
            return R.ok();
        &#125;
        return R.error(BizCodeEnum.SMS_SEND_CODE_EXCEPTION.getCode(), BizCodeEnum.SMS_SEND_CODE_EXCEPTION.getMsg());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>短信服务编写好后，我们在认证微服务中远程调用。</p>
<h4 id="3-接口防刷"><a class="header-anchor" href="#3-接口防刷">¶</a>(3) 接口防刷</h4>
<p>为了防止恶意攻击短信接口，用 redis 缓存电话号</p>
<ul>
<li>在 redis 中以<code>phone-code</code>将电话号码和验证码进行存储并将当前时间与 code 一起存储
<ul>
<li>如果调用时以当前<code>phone</code>取出的 v 不为空且当前时间在存储时间的 60s 以内，说明 60s 内该号码已经调用过，返回错误信息</li>
<li>60s 以后再次调用，需要删除之前存储的<code>phone-code</code></li>
<li>code 存在一个过期时间，我们设置为 10min，10min 内验证该验证码有效</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@ResponseBody
@GetMapping(&quot;&#x2F;sms&#x2F;snedcode&quot;)
public R sendCode(@RequestParam(&quot;phone&quot;) String phone)&#123;

    &#x2F;&#x2F;  接口防刷，redis缓存 sms:code:电话号
    String redisCode &#x3D; stringRedisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone);
    &#x2F;&#x2F; 如果不为空，返回错误信息
    if(null !&#x3D; redisCode &amp;&amp; redisCode.length() &gt; 0)&#123;
        long CuuTime &#x3D; Long.parseLong(redisCode.split(&quot;_&quot;)[1]);
        if(System.currentTimeMillis() - CuuTime &lt; 60 * 1000)&#123; &#x2F;&#x2F; 60s
            return R.error(BizCodeEnum.SMS_CODE_EXCEPTION.getCode(), BizCodeEnum.SMS_CODE_EXCEPTION.getMsg());
        &#125;
    &#125;
    &#x2F;&#x2F; 生成验证码
    String code &#x3D; UUID.randomUUID().toString().substring(0, 6);
    String redis_code &#x3D; code + &quot;_&quot; + System.currentTimeMillis();
    &#x2F;&#x2F; 缓存验证码
    stringRedisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone, redis_code , 10, TimeUnit.MINUTES);
    try &#123;&#x2F;&#x2F; 调用第三方短信服务
        return thirdPartFeignService.sendCode(phone, code);
    &#125; catch (Exception e) &#123;
        log.warn(&quot;远程调用不知名错误 [无需解决]&quot;);
    &#125;
    return R.ok();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-注册-VO"><a class="header-anchor" href="#4-注册-VO">¶</a>(4) 注册 VO</h4>
<p>前端也可以进行校验，此处是</p>
<pre class="line-numbers language-none"><code class="language-none">@Data
public class UserRegisterVo &#123;&#x2F;&#x2F; JSR303校验

	@Length(min &#x3D; 6,max &#x3D; 20,message &#x3D; &quot;用户名长度必须在6-20之间&quot;)
	@NotEmpty(message &#x3D; &quot;用户名必须提交&quot;)
	private String userName;

	@Length(min &#x3D; 6,max &#x3D; 20,message &#x3D; &quot;用户名长度必须在6-20之间&quot;)
	@NotEmpty(message &#x3D; &quot;密码必须提交&quot;)
	private String password;

	@NotEmpty(message &#x3D; &quot;手机号不能为空&quot;)
	@Pattern(regexp &#x3D; &quot;^[1]([3-9])[0-9]&#123;9&#125;$&quot;, message &#x3D; &quot;手机号格式不正确&quot;)
	private String phone;

	@NotEmpty(message &#x3D; &quot;验证码必须填写&quot;)
	private String code;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-注册用户保存"><a class="header-anchor" href="#5-注册用户保存">¶</a>(5) 注册用户保存</h4>
<p>在<code>gulimall-auth-server</code>服务中编写注册的主体逻辑</p>
<ul>
<li>JSR303 校验的结果，被封装到<code>BindingResult</code>，有错误就重定向至注册页面</li>
<li>从<code>redis</code>中确认手机验证码是否正确，一致则删除验证码，令牌机制</li>
<li>会员服务调用成功后，重定向至登录页（防止表单重复提交），否则封装远程服务返回的错误信息返回至注册页面</li>
<li>重定向的请求数据，可以利用 RedirectAttributes 参数转发
<ul>
<li>但是他是利用的 session 原理，所以后期我们需要解决分布式的 session 问题</li>
<li>重定向取一次后，session 数据就消失了，因为使用的是. addFlashAttribute(</li>
</ul>
</li>
<li>重定向时，如果不指定 host，就直接显示了注册服务的 ip，所以我们重定义写 http://…</li>
</ul>
<p>注： <code>RedirectAttributes</code>可以通过 session 保存信息并在重定向的时候携带过去</p>
<pre class="line-numbers language-none"><code class="language-none">@PostMapping(&quot;&#x2F;register&quot;)
public String register(@Valid UserRegisterVo registerVo, BindingResult result, RedirectAttributes attributes) &#123;
    &#x2F;&#x2F;1.判断校验是否通过
    Map&lt;String, String&gt; errors &#x3D; new HashMap&lt;&gt;();
    if (result.hasErrors())&#123;
        &#x2F;&#x2F;1.1 如果校验不通过，则封装校验结果
        result.getFieldErrors().forEach(item-&gt;&#123;
            errors.put(item.getField(), item.getDefaultMessage());
            &#x2F;&#x2F;1.2 将错误信息封装到session中
            attributes.addFlashAttribute(&quot;errors&quot;, errors);
        &#125;);
        &#x2F;&#x2F;1.2 重定向到注册页
        return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;reg.html&quot;;
    &#125;else &#123;
        &#x2F;&#x2F;2.若JSR303校验通过
        &#x2F;&#x2F;判断验证码是否正确
        String code &#x3D; redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + registerVo.getPhone());
        &#x2F;&#x2F;2.1 如果对应手机的验证码不为空且与提交上的相等-》验证码正确
        if (!StringUtils.isEmpty(code) &amp;&amp; registerVo.getCode().equals(code.split(&quot;_&quot;)[0])) &#123;
            &#x2F;&#x2F;2.1.1 使得验证后的验证码失效
            redisTemplate.delete(AuthServerConstant.SMS_CODE_CACHE_PREFIX + registerVo.getPhone());

            &#x2F;&#x2F;2.1.2 远程调用会员服务注册
            R r &#x3D; memberFeignService.register(registerVo);
            if (r.getCode() &#x3D;&#x3D; 0) &#123;
                &#x2F;&#x2F;调用成功，重定向登录页
                return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;login.html&quot;;
            &#125;else &#123;
                &#x2F;&#x2F;调用失败，返回注册页并显示错误信息
                String msg &#x3D; (String) r.get(&quot;msg&quot;);
                errors.put(&quot;msg&quot;, msg);
                attributes.addFlashAttribute(&quot;errors&quot;, errors);
                return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;reg.html&quot;;
            &#125;
        &#125;else &#123;
            &#x2F;&#x2F;2.2 验证码错误
            errors.put(&quot;code&quot;, &quot;验证码错误&quot;);
            attributes.addFlashAttribute(&quot;errors&quot;, errors);
            return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;reg.html&quot;;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过<code>gulimall-member</code>会员服务注册逻辑</p>
<ul>
<li>通过异常机制判断当前注册会员名和电话号码是否已经注册，如果已经注册，则抛出对应的自定义异常，并在返回时封装对应的错误信息</li>
<li>如果没有注册，则封装传递过来的会员信息，并设置默认的会员等级、创建时间</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@RequestMapping(&quot;&#x2F;register&quot;)
    public R register(@RequestBody MemberRegisterVo registerVo) &#123;
        try &#123;
            memberService.register(registerVo);
            &#x2F;&#x2F;异常机制：通过捕获对应的自定义异常判断出现何种错误并封装错误信息
        &#125; catch (UserExistException userException) &#123;
            return R.error(BizCodeEnum.USER_EXIST_EXCEPTION.getCode(), BizCodeEnum.USER_EXIST_EXCEPTION.getMsg());
        &#125; catch (PhoneNumExistException phoneException) &#123;
            return R.error(BizCodeEnum.PHONE_EXIST_EXCEPTION.getCode(), BizCodeEnum.PHONE_EXIST_EXCEPTION.getMsg());
        &#125;
        return R.ok();
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>注册时检查用户名和手机唯一性</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@Override
    public void register(UserRegisterVo userRegisterVo)  throws PhoneExistException, UserNameExistException &#123;

        MemberEntity entity &#x3D; new MemberEntity();
        &#x2F;&#x2F; 设置默认等级
        MemberLevelEntity memberLevelEntity &#x3D; memberLevelDao.getDefaultLevel();
        entity.setLevelId(memberLevelEntity.getId());

        &#x2F;&#x2F; 检查手机号 用户名是否唯一
        checkPhone(userRegisterVo.getPhone());
        checkUserName(userRegisterVo.getUserName());

        entity.setMobile(userRegisterVo.getPhone());
        entity.setUsername(userRegisterVo.getUserName());

        &#x2F;&#x2F; 密码要加密存储
        BCryptPasswordEncoder bCryptPasswordEncoder &#x3D; new BCryptPasswordEncoder();
        entity.setPassword(bCryptPasswordEncoder.encode(userRegisterVo.getPassword()));
        &#x2F;&#x2F; 其他的默认信息
        entity.setCity(&quot;湖南 长沙&quot;);
        entity.setCreateTime(new Date());
        entity.setStatus(0);
        entity.setNickname(userRegisterVo.getUserName());
        entity.setBirth(new Date());
        entity.setEmail(&quot;xxx@gmail.com&quot;);
        entity.setGender(1);
        entity.setJob(&quot;JAVA&quot;);
        baseMapper.insert(entity);
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">@Override &#x2F;&#x2F; void 无需bool &#x2F;&#x2F; 自定义异常继承 extends RuntimeException
public void checkPhone(String phone) throws PhoneExistException&#123;
    if(this.baseMapper.selectCount(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;mobile&quot;, phone)) &gt; 0)&#123;
        throw new PhoneExistException();
    &#125;
&#125;

public class PhoneExistException extends RuntimeException &#123;
    public PhoneExistException() &#123;
        super(&quot;手机号存在&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="6-密码加密"><a class="header-anchor" href="#6-密码加密">¶</a>(6) 密码加密</h4>
<p>java 密码安全可以参考我之前的笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/111464250">https://blog.csdn.net/hancoder/article/details/111464250</a></p>
<p>本文采样 md5 信息照耀算法，但其实他不安全，可以加盐提高安全性<code>Md5Crypt.md5Crypt(bytes,salt)</code></p>
<p>spring 有个加密的工 BCryptPasswordEncoder.match()</p>
<h4 id="7-用户名密码登录"><a class="header-anchor" href="#7-用户名密码登录">¶</a>(7) 用户名密码登录</h4>
<p>在<code>gulimall-auth-server</code>模块中的主体逻辑</p>
<ul>
<li>通过会员服务远程调用登录接口
<ul>
<li>如果调用成功，重定向至首页</li>
<li>如果调用失败，则封装错误信息并携带错误信息重定向至登录页</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@RequestMapping(&quot;&#x2F;login&quot;)
public String login(UserLoginVo vo,RedirectAttributes attributes)&#123;
    R r &#x3D; memberFeignService.login(vo);
    if (r.getCode() &#x3D;&#x3D; 0) &#123;
        return &quot;redirect:http:&#x2F;&#x2F;gulimall.com&#x2F;&quot;;
    &#125;else &#123;
        String msg &#x3D; (String) r.get(&quot;msg&quot;);
        Map&lt;String, String&gt; errors &#x3D; new HashMap&lt;&gt;();
        errors.put(&quot;msg&quot;, msg);
        attributes.addFlashAttribute(&quot;errors&quot;, errors);
        return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;login.html&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>gulimall-member</code>模块中完成登录</p>
<ul>
<li>当数据库中含有以当前登录名为用户名或电话号且密码匹配时，验证通过，返回查询到的实体</li>
<li>否则返回 null，并在 controller 返回<code>用户名或密码错误</code></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@RequestMapping(&quot;&#x2F;login&quot;)
public R login(@RequestBody MemberLoginVo loginVo) &#123;
    MemberEntity entity&#x3D;memberService.login(loginVo);
    if (entity!&#x3D;null)&#123;
        return R.ok();
    &#125;else &#123;
        return R.error(BizCodeEnum.LOGINACCT_PASSWORD_EXCEPTION.getCode(), BizCodeEnum.LOGINACCT_PASSWORD_EXCEPTION.getMsg());
    &#125;
&#125;

@Override
public MemberEntity login(MemberLoginVo loginVo) &#123;
    String loginAccount &#x3D; loginVo.getLoginAccount();
    &#x2F;&#x2F;以用户名或电话号登录的进行查询
    MemberEntity entity &#x3D; this.getOne(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;username&quot;, loginAccount).or().eq(&quot;mobile&quot;, loginAccount));
    if (entity!&#x3D;null)&#123;
        BCryptPasswordEncoder bCryptPasswordEncoder &#x3D; new BCryptPasswordEncoder();
        boolean matches &#x3D; bCryptPasswordEncoder.matches(loginVo.getPassword(), entity.getPassword());
        if (matches)&#123;
            entity.setPassword(&quot;&quot;);
            return entity;
        &#125;
    &#125;
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-社交登录"><a class="header-anchor" href="#3-社交登录">¶</a><strong>3 社交登录</strong></h3>
<p>社交登录指的是用 QQ 微信等方式登录</p>
<ul>
<li>点击 QQ 按钮</li>
<li>引导跳转到 QQ 授权页</li>
<li>用户主动点击授权，跳回之前网页</li>
</ul>
<h4 id="1-OAuth2-0"><a class="header-anchor" href="#1-OAuth2-0">¶</a>(1) OAuth2.0</h4>
<p>上面社交登录的流程就是 OAuth 协议</p>
<p>OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0 是 OAuth 协议的延续版本，但不向后兼容 OAuth 1.0 即完全废止了 OAuth1.0。</p>
<p><img src="https://img-blog.csdnimg.cn/20190524214449242.png" alt="" loading="lazy"></p>
<blockquote>
<p>微信：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html">https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html</a></p>
<p>客户端是</p>
<p>资源拥有者：用户本人</p>
<p>授权服务器：QQ 服务器，微信服务器等。返回访问令牌</p>
<p>资源服务器：拿着令牌访问资源服务器看令牌合法性</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/690ea78bd63dc40da24d629c8934f4c2.png" alt="" loading="lazy"></p>
<p>1、使用 Code 换取 AccessToken，Code 只能用一次<br>
2、同一个用户的 accessToken 一段时间是不会变化的，即使多次获取</p>
<h4 id="2-微博开放平台使用"><a class="header-anchor" href="#2-微博开放平台使用">¶</a>(2) 微博开放平台使用</h4>
<p><a target="_blank" rel="noopener" href="https://open.weibo.com/authentication">https://open.weibo.com/authentication</a></p>
<p><a target="_blank" rel="noopener" href="https://open.weibo.com/connect">https://open.weibo.com/connect</a> 点击网站接入</p>
<p>填写一些个人信息后，<a target="_blank" rel="noopener" href="https://open.weibo.com/apps/new?sort=web">https://open.weibo.com/apps/new?sort=web</a> 创建新应用 gulimallxxx，会得到<code>APP KEY</code>和<code>APP Secret</code></p>
<p>在高级信息里填写</p>
<ul>
<li><code>授权回调页</code>：<a target="_blank" rel="noopener" href="http://gulimall.com/success">gulimall.com/success</a></li>
<li><code>取消授权回调页</code>：<a target="_blank" rel="noopener" href="http://gulimall.com/fail">gulimall.com/fail</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E">https://open.weibo.com/wiki / 授权机制说明</a> 查看 OAuth2</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bc0c877c555ed6b992607f3c69ce9f5b.gif" alt="" loading="lazy"></p>
<p>\1. 引导需要授权的用户到如下地址：</p>
<pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;api.weibo.com&#x2F;oauth2&#x2F;authorize?client_id&#x3D;YOUR_CLIENT_ID&amp;response_type&#x3D;code&amp;redirect_uri&#x3D;授权后跳转的uri

示例：
https:&#x2F;&#x2F;api.weibo.com&#x2F;oauth2&#x2F;authorize?
client_id&#x3D;刚才申请的APP-KEY &amp;
response_type&#x3D;code&amp;
redirect_uri&#x3D;http:&#x2F;&#x2F;gulimall.com&#x2F;success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>\2. 如果用户同意授权 (输入账号密码)，带着 code，页面跳转至 <a target="_blank" rel="noopener" href="http://gulimall.com/success/?code=CODE">gulimall.com/success/?code=CODE</a></p>
<p>跳回我们网站的时候，带了一个 code 码，这个 code 码可以理解为用户登录的 sessionID</p>
<p>\3. POST 拿着 code 码换取 Access Token</p>
<pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;api.weibo.com&#x2F;oauth2&#x2F;access_token?
client_id&#x3D;YOUR_CLIENT_ID&amp;
client_secret&#x3D;YOUR_CLIENT_SECRET&amp;
grant_type&#x3D;authorization_code&amp;
redirect_uri&#x3D;YOUR_REGISTERED_REDIRECT_URI&amp;
code&#x3D;CODE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET 可以使用 basic 方式加入 header 中，返回值</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
    &quot;access_token&quot;: &quot;SlAV32hkKG&quot;,
    &quot;remind_in&quot;: 3600, # 也是声明周期，但将废弃
    &quot;expires_in&quot;: 3600 # access_token的生命周期；
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>\4. 使用获得的 Access Token 调用 API，可以获取头像等信息 <a target="_blank" rel="noopener" href="https://open.weibo.com/wiki/2/users/show">https://open.weibo.com/wiki/2/users/show</a></p>
<p>结果返回 json</p>
<h4 id="3-代码编写"><a class="header-anchor" href="#3-代码编写">¶</a>(3) 代码编写</h4>
<p>注意点：</p>
<ul>
<li>登录成功得到了 code，这不应该提供给用户</li>
<li>拿着 code 还有其他信息 APP-KEY 去获取 token，更不应该给用户看到</li>
<li>应该回调的是后台的 controller，在后台处理完 token 逻辑后返回</li>
<li>把成功后回调改为：<a target="_blank" rel="noopener" href="http://gulimall.com/oauthn2.0/weibo/success">gulimall.com/oauthn2.0/weibo/success</a></li>
</ul>
<h5 id="weibo-success"><a class="header-anchor" href="#weibo-success">¶</a>/weibo/success</h5>
<ul>
<li>通过<code>HttpUtils</code>发送请求获取<code>token</code>, 并将<code>token</code>等信息交给<code>member</code>服务进行社交登录
<ul>
<li>进行账号保存，主要有 uid、token、expires_in</li>
</ul>
</li>
<li>若获取<code>token</code>失败或远程调用服务失败，则封装错误信息重新转回登录页</li>
</ul>
<blockquote>
<p>登录成功跳转到首页，但是怎么保证没有验证情况下访问不了首页：用 shiro 等拦截器功能</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;&#x2F;weibo&#x2F;success&quot;) &#x2F;&#x2F; Oath2Controller
public String weiBo(@RequestParam(&quot;code&quot;) String code, HttpSession session) throws Exception &#123;

    &#x2F;&#x2F; 根据code换取 Access Token
    Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();
    map.put(&quot;client_id&quot;, &quot;1294828100&quot;);
    map.put(&quot;client_secret&quot;, &quot;a8e8900e15fba6077591cdfa3105af44&quot;);
    map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;);
    map.put(&quot;redirect_uri&quot;, &quot;http:&#x2F;&#x2F;auth.gulimall.com&#x2F;oauth2.0&#x2F;weibo&#x2F;success&quot;);
    map.put(&quot;code&quot;, code);
    Map&lt;String, String&gt; headers &#x3D; new HashMap&lt;&gt;();

    &#x2F;&#x2F; 去获取token
    HttpResponse response &#x3D; HttpUtils.doPost(&quot;https:&#x2F;&#x2F;api.weibo.com&quot;, &quot;&#x2F;oauth2&#x2F;access_token&quot;, &quot;post&quot;, headers, null, map);
    if(response.getStatusLine().getStatusCode() &#x3D;&#x3D; 200)&#123;
        &#x2F;&#x2F; 获取响应体： Access Token
        String json &#x3D; EntityUtils.toString(response.getEntity());
        SocialUser socialUser &#x3D; JSON.parseObject(json, SocialUser.class);

        &#x2F;&#x2F; 相当于我们知道了当前是那个用户
        &#x2F;&#x2F; 1.如果用户是第一次进来 自动注册进来(为当前社交用户生成一个会员信息 以后这个账户就会关联这个账号)
        R login &#x3D; memberFeignService.login(socialUser);
        if(login.getCode() &#x3D;&#x3D; 0)&#123;
            MemberRsepVo rsepVo &#x3D; login.getData(&quot;data&quot; ,new TypeReference&lt;MemberRsepVo&gt;() &#123;&#125;);

            log.info(&quot;\n欢迎 [&quot; + rsepVo.getUsername() + &quot;] 使用社交账号登录&quot;);
            &#x2F;&#x2F; 第一次使用session 命令浏览器保存这个用户信息 JESSIONSEID 每次只要访问这个网站就会带上这个cookie
            &#x2F;&#x2F; 在发卡的时候扩大session作用域 (指定域名为父域名)
            &#x2F;&#x2F; TODO 1.默认发的当前域的session (需要解决子域session共享问题)
            &#x2F;&#x2F; TODO 2.使用JSON的方式序列化到redis
            &#x2F;&#x2F;				new Cookie(&quot;JSESSIONID&quot;,&quot;&quot;).setDomain(&quot;gulimall.com&quot;);
            session.setAttribute(AuthServerConstant.LOGIN_USER, rsepVo);
            &#x2F;&#x2F; 登录成功 跳回首页
            return &quot;redirect:http:&#x2F;&#x2F;gulimall.com&quot;;
        &#125;else&#123;
            return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;login.html&quot;;
        &#125;
    &#125;else&#123;
        return &quot;redirect:http:&#x2F;&#x2F;auth.gulimall.com&#x2F;login.html&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="token-保存"><a class="header-anchor" href="#token-保存">¶</a>token 保存</h5>
<ul>
<li>登录包含两种流程，实际上包括了注册和登录</li>
<li>如果之前未使用该社交账号登录，则使用<code>token</code>调用开放 api 获取社交账号相关信息（头像等），注册并将结果返回</li>
<li>如果之前已经使用该社交账号登录，则更新<code>token</code>并将结果返回</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@RequestMapping(&quot;&#x2F;oauth2&#x2F;login&quot;)
public R login(@RequestBody SocialUser socialUser) &#123;
    MemberEntity entity&#x3D;memberService.login(socialUser);
    if (entity!&#x3D;null)&#123;
        return R.ok().put(&quot;memberEntity&quot;,entity);
    &#125;else &#123;
        return R.error();
    &#125;
&#125;

@Override &#x2F;&#x2F; 已经用code生成了token
public MemberEntity login(SocialUser socialUser) &#123;

    &#x2F;&#x2F; 微博的uid
    String uid &#x3D; socialUser.getUid();
    &#x2F;&#x2F; 1.判断社交用户登录过系统
    MemberDao dao &#x3D; this.baseMapper;
    MemberEntity entity &#x3D; dao.selectOne(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;social_uid&quot;, uid));

    MemberEntity memberEntity &#x3D; new MemberEntity();
    if(entity !&#x3D; null)&#123; &#x2F;&#x2F; 注册过
        &#x2F;&#x2F; 说明这个用户注册过, 修改它的资料
        &#x2F;&#x2F; 更新令牌
        memberEntity.setId(entity.getId());
        memberEntity.setAccessToken(socialUser.getAccessToken());
        memberEntity.setExpiresIn(socialUser.getExpiresIn());
        &#x2F;&#x2F; 更新
        dao.updateById(memberEntity);

        entity.setAccessToken(socialUser.getAccessToken());
        entity.setExpiresIn(socialUser.getExpiresIn());
        entity.setPassword(null);
        return entity;
    &#125;else&#123; &#x2F;&#x2F; 没有注册过
        &#x2F;&#x2F; 2. 没有查到当前社交用户对应的记录 我们就需要注册一个
        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();
        map.put(&quot;access_token&quot;, socialUser.getAccessToken());
        map.put(&quot;uid&quot;, socialUser.getUid());
        try &#123;
            &#x2F;&#x2F; 3. 查询当前社交用户账号信息(昵称、性别、头像等)
            HttpResponse response &#x3D; HttpUtils.doGet(&quot;https:&#x2F;&#x2F;api.weibo.com&quot;, &quot;&#x2F;2&#x2F;users&#x2F;show.json&quot;, &quot;get&quot;, new HashMap&lt;&gt;(), map);
            if(response.getStatusLine().getStatusCode() &#x3D;&#x3D; 200)&#123;
                &#x2F;&#x2F; 查询成功
                String json &#x3D; EntityUtils.toString(response.getEntity());
                &#x2F;&#x2F; 这个JSON对象什么样的数据都可以直接获取
                JSONObject jsonObject &#x3D; JSON.parseObject(json);
                memberEntity.setNickname(jsonObject.getString(&quot;name&quot;));
                memberEntity.setUsername(jsonObject.getString(&quot;name&quot;));
                memberEntity.setGender(&quot;m&quot;.equals(jsonObject.getString(&quot;gender&quot;))?1:0);
                memberEntity.setCity(jsonObject.getString(&quot;location&quot;));
                memberEntity.setJob(&quot;自媒体&quot;);
                memberEntity.setEmail(jsonObject.getString(&quot;email&quot;));
            &#125;
        &#125; catch (Exception e) &#123;
            log.warn(&quot;社交登录时远程调用出错 [尝试修复]&quot;);
        &#125;
        memberEntity.setStatus(0);
        memberEntity.setCreateTime(new Date());
        memberEntity.setBirth(new Date());
        memberEntity.setLevelId(1L);
        memberEntity.setSocialUid(socialUser.getUid());
        memberEntity.setAccessToken(socialUser.getAccessToken());
        memberEntity.setExpiresIn(socialUser.getExpiresIn());

        &#x2F;&#x2F; 注册 -- 登录成功
        dao.insert(memberEntity);
        memberEntity.setPassword(null);
        return memberEntity;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-SpringSession"><a class="header-anchor" href="#4-SpringSession">¶</a><strong>4 SpringSession</strong></h3>
<h4 id="1-session-原理"><a class="header-anchor" href="#1-session-原理">¶</a>(1) session 原理</h4>
<p>session 存储在服务端，jsessionId 存在客户端，每次通过<code>jsessionid</code>取出保存的数据</p>
<p>问题：但是正常情况下<code>session</code>不可跨域，它有自己的作用范围</p>
<p><img src="https://fermhan.oss-cn-qingdao.aliyuncs.com/img/20210228144701.png" alt="" loading="lazy"></p>
<p>这个 session 被 sessionManager 管理者</p>
<table><thead><tr><th>JsessionId 列</th><th>说明</th></tr></thead><tbody><tr><td>Value</td><td>XXXXXX…</td></tr><tr><td>Domain</td><td>gulimall.com 要放大域名作用域</td></tr><tr><td>Path</td><td>/</td></tr><tr><td>Expires/Max-Age</td><td>40</td></tr></tbody></table>
<h4 id="2-分布式-session-解决方案"><a class="header-anchor" href="#2-分布式-session-解决方案">¶</a>(2) 分布式 session 解决方案</h4>
<p>session 要能在不同服务和同服务的集群的共享</p>
<h5 id="1-session-复制"><a class="header-anchor" href="#1-session-复制">¶</a>1) session 复制</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/81582c3f7407aeb38e390e22f1556184.png" alt="" loading="lazy"></p>
<h5 id="2-hash-一致性"><a class="header-anchor" href="#2-hash-一致性">¶</a>2) hash 一致性</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b3e6040714dc676fecb24d3a1c7af97b.png" alt="" loading="lazy"></p>
<h5 id="3-redis-统一存储"><a class="header-anchor" href="#3-redis-统一存储">¶</a>3) redis 统一存储</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fb76e9a30e844c5c1ec50020cf2f67e1.png" alt="" loading="lazy"></p>
<h4 id="3-SpringSession-整合-redis"><a class="header-anchor" href="#3-SpringSession-整合-redis">¶</a>(3) SpringSession 整合 redis</h4>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-session-data-redis">https://spring.io/projects/spring-session-data-redis</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-session/docs/2.4.2/reference/html5/#modules">https://docs.spring.io/spring-session/docs/2.4.2/reference/html5/#modules</a></p>
<p>通过<code>SpringSession</code>修改<code>session</code>的作用域</p>
<p>会员服务、订单服务、商品服务，都是去 redis 里存储 session</p>
<h5 id="1-环境搭建"><a class="header-anchor" href="#1-环境搭建">¶</a>1) 环境搭建</h5>
<p>Oauth 导入依赖</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改配置</p>
<pre class="line-numbers language-none"><code class="language-none">spring.session.store-type&#x3D;redis
server.servlet.session.timeout&#x3D;30m
spring.redis.host&#x3D;192.168.56.10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>添加注解</p>
<pre class="line-numbers language-none"><code class="language-none">@EnableRedisHttpSession &#x2F;&#x2F;创建了一个springSessionRepositoryFilter ，负责将原生HttpSession 替换为Spring Session的实现
public class GulimallAuthServerApplication &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是现在还有一些问题：</p>
<ul>
<li>序列化的问题</li>
<li>cookie 的 domain 的问题</li>
</ul>
<h5 id="2-扩大-session-作用域"><a class="header-anchor" href="#2-扩大-session-作用域">¶</a>2) 扩大 session 作用域</h5>
<ul>
<li>
<p>由于默认使用 jdk 进行序列化，通过导入<code>RedisSerializer</code>修改为 json 序列化</p>
</li>
<li>
<p>并且通过修改<code>CookieSerializer</code>扩大<code>session</code>的作用域至<code>**.gulimall.com</code></p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@Configuration
public class GulimallSessionConfig &#123;

    @Bean
    public RedisSerializer&lt;Object&gt; springSessionDefaultRedisSerializer() &#123;
        return new GenericJackson2JsonRedisSerializer();
    &#125;

    @Bean
    public CookieSerializer cookieSerializer() &#123;
        DefaultCookieSerializer serializer &#x3D; new DefaultCookieSerializer();
        serializer.setCookieName(&quot;GULISESSIONID&quot;);
        serializer.setDomainName(&quot;gulimall.com&quot;);
        return serializer;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把这个配置放到每个微服务下</p>
<h4 id="4-SpringSession-核心原理-装饰者模式"><a class="header-anchor" href="#4-SpringSession-核心原理-装饰者模式">¶</a>(4) SpringSession 核心原理 - 装饰者模式</h4>
<p>网上百度一下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46539364/article/details/110533408">https://blog.csdn.net/m0_46539364/article/details/110533408</a></p>
<p>就是分析 @EnableRedisHttpSession，</p>
<pre class="line-numbers language-none"><code class="language-none">@Import(&#123;RedisHttpSessionConfiguration.class&#125;)
@Configuration( proxyBeanMethods &#x3D; false)
public @interface EnableRedisHttpSession &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">public class RedisHttpSessionConfiguration 
    extends SpringHttpSessionConfiguration &#x2F;&#x2F; 继承
    implements 。。。&#123;
    
    &#x2F;&#x2F; 后面SessionRepositoryFilter会构造时候自动注入他
    @Bean &#x2F;&#x2F; 操作session的方法，如getSession()  deleteById()
    public RedisIndexedSessionRepository sessionRepository() &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SessionRepositoryFilter，每个请求都要经过该 filter</p>
<pre class="line-numbers language-none"><code class="language-none">public class SpringHttpSessionConfiguration 
    implements ApplicationContextAware &#123;

    @Bean
    public &lt;S extends Session&gt; SessionRepositoryFilter&lt;? extends Session&gt; springSessionRepositoryFilter(SessionRepository&lt;S&gt; sessionRepository) &#123;
        SessionRepositoryFilter&lt;S&gt; sessionRepositoryFilter &#x3D; new SessionRepositoryFilter(sessionRepository);
        sessionRepositoryFilter.setHttpSessionIdResolver(this.httpSessionIdResolver);
        return sessionRepositoryFilter;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>原生的获取<code>session</code>时是通过<code>HttpServletRequest</code>获取的</li>
<li>这里对 request 进行包装，并且重写了包装 request 的<code>getSession()</code>方法</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@Override &#x2F;&#x2F; SessionRepositoryFilter.java
protected void doFilterInternal(HttpServletRequest request,
                                HttpServletResponse response, 
                                FilterChain filterChain) &#123;
    
    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);

    &#x2F;&#x2F;对原生的request、response进行包装
    &#x2F;&#x2F; SessionRepositoryRequestWrapper.getSession()
    SessionRepositoryRequestWrapper wrappedRequest &#x3D; new SessionRepositoryRequestWrapper(
        request, response, this.servletContext);
    SessionRepositoryResponseWrapper wrappedResponse &#x3D; new SessionRepositoryResponseWrapper(
        wrappedRequest, response);

    try &#123;
        filterChain.doFilter(wrappedRequest, wrappedResponse);
    &#125;
    finally &#123;
        wrappedRequest.commitSession();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>绣花前面的代码，controller 层加参数 HttpSession，直接 session.setAttribute(“user”,user) 即可</p>
<p>前端页面的显示可以用<code>&lt;li th:if=&quot;$&#123;session.loginUser&#125; ==null&quot;&gt;</code></p>
<h3 id="分布式登录总结"><a class="header-anchor" href="#分布式登录总结">¶</a>分布式登录总结</h3>
<p>登录 url：<a target="_blank" rel="noopener" href="http://auth.gulimall.com/login.html">http://auth.gulimall.com/login.html</a><br>
（注意是 url，不是页面。）<br>
判断 session 中是否有 user 对象</p>
<ul>
<li>没有 user 对象，渲染 login.html 页面<br>
用户输入账号密码后发送给<br>
url:auth.gulimall.com/login<br>
根据表单传过来的 VO 对象，远程调用 memberFeignService 验证密码
<ul>
<li>如果验证失败，取出远程调用返回的错误信息，放到新的请求域，重定向到登录 url</li>
<li>如果验证成功，远程服务就返回了对应的 MemberRespVo 对象，<br>
然后放到分布式 redis-session 中，key 为 “loginUser”，重定向到首页 <a target="_blank" rel="noopener" href="http://gulimall.com">gulimall.com</a>，<br>
同时也会带着的 GULISESSIONID
<ul>
<li>重定向到非 auth 项目后，先经过拦截器看 session 里有没有 loginUser 对象</li>
<li>有，放到静态 threadLocal 中，这样就可以操作本地内存，无需远程调用 session</li>
<li>没有，重定向到登录页</li>
</ul>
</li>
</ul>
</li>
<li>有 user 对象，代表登录过了，重定向到首页，session 数据还依靠 sessionID 持有着</li>
</ul>
<p>额外说明：</p>
<p>问题 1：我们有 sessionId 不就可以了吗？为什么还要在 session 中放到 User 对象？<br>
为了其他服务可以根据这个 user 查数据库，只有 session 的话不能再次找到登录 session 的用户</p>
<p>问题 2：threadlocal 的作用？</p>
<p>他是为了放到当前 session 的线程里，threadlocal 就是这个作用，随着线程创建和消亡，把 threadlocal 定义为 static 的，这样任何代码地方都可以获取到。如果只是在 session 中的话，一是每次还得去 redis 查询，二是去调用 service 还得传入 session 参数，多麻烦啊</p>
<p>问题 3：cookie 怎么回事？不是在 config 中定义了 cookie 的 key 和序列化器？</p>
<p>序列化器没什么好讲的，就是为了易读和来回转换。而 cookie 的 key 其实是无所谓的，只要两个项目里的 key 相同，然后访问同一个域名都带着该 cookie 即可。</p>
<h3 id="5-单点登录"><a class="header-anchor" href="#5-单点登录">¶</a>5 单点登录</h3>
<p>上面解决了同域名的 session 问题，但如果 <a target="_blank" rel="noopener" href="http://taobao.com">taobao.com</a> 和 <a target="_blank" rel="noopener" href="http://tianmao.com">tianmao.com</a> 这种不同的域名也想共享 session 呢？</p>
<p>去百度了解下：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bingyimeiling/p/11698468.html">https://www.cnblogs.com/bingyimeiling/p/11698468.html</a></p>
<blockquote>
<p>spring session 已经解决不了不同域名的问题了。无法扩大域名</p>
</blockquote>
<h4 id="sso-思路"><a class="header-anchor" href="#sso-思路">¶</a>sso 思路</h4>
<ul>
<li>server：登录服务器、8080 、<a target="_blank" rel="noopener" href="http://ssoserver.com">ssoserver.com</a></li>
<li>web-sample1：项目 1 、8081 、<a target="_blank" rel="noopener" href="http://client1.com">client1.com</a></li>
<li>web-sample2：项目 1 、8082 、<a target="_blank" rel="noopener" href="http://client2.com">client2.com</a></li>
</ul>
<p>3 个系统即使域名不一样，想办法给三个系统同步同一个用户的票据；</p>
<ul>
<li>中央认证服务器</li>
<li>其他系统都去【中央认证服务器】登录，登录成功后跳转回原服务</li>
<li>一个系统登录，都登录；一个系统登出，都登出</li>
<li>全系统统一一个 sso-sessionId</li>
</ul>
<h4 id="开源项目"><a class="header-anchor" href="#开源项目">¶</a>开源项目</h4>
<p>先看一下开源 sso 的项目：<a target="_blank" rel="noopener" href="https://gitee.com/xuxueli0323/xxl-sso">https://gitee.com/xuxueli0323/xxl-sso</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://ssoserver.com">ssoserver.com</a> 登录认证服务</li>
<li><a target="_blank" rel="noopener" href="http://client1.com">client1.com</a></li>
<li><a target="_blank" rel="noopener" href="http://cleitn2.com">cleitn2.com</a></li>
</ul>
<p>修改 HOSTS：127.0.0.1 <a target="_blank" rel="noopener" href="http://ssoserver.com+client1.com+client2.com">ssoserver.com+client1.com+client2.com</a></p>
<ul>
<li>server：登录服务器、8080 、<a target="_blank" rel="noopener" href="http://ssoserver.com">ssoserver.com</a></li>
<li>web-sample1：项目 1 、8081 、<a target="_blank" rel="noopener" href="http://client1.com">client1.com</a></li>
<li>web-sample2：项目 1 、8082 、<a target="_blank" rel="noopener" href="http://client2.com">client2.com</a></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none"># 根项目下
mvn clean package -Dmaven.skip.test&#x3D;true
# 打包生成了server和client包
# 启动server和client
#server8080  cient1:web-sample8081 cient2:web-sample8082
# 让client12登录一次即可
java -jar server.jar # 8080
java -jar client.jar 
# 启动多个web-sample模拟多个微服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把 core 项目 mvc install 。启动 server</p>
<h4 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h4>
<ul>
<li>发送 8081/employees 请求，判断没登录就跳转到 <a target="_blank" rel="noopener" href="http://server.com:8080/login.html">server.com:8080/login.html</a> 登录页，并带上现 url</li>
<li>server 登录页的时候，有之前带过来的 url 信息，发送登录请求的时候也把 url 继续带着
<ul>
<li>doLogin 登录成功后返回一个 token（保存到 server 域名下）然后重定向</li>
</ul>
</li>
<li>登录完后重定向到带的 url 参数的地址。</li>
<li>跳转回业务层的时候，业务层要能感知是登录过的，调回去的时候带个 uuid，用 uuid 去 redis 里看 user 信息，保存到 session</li>
<li>以后无论哪个系统访问，自己的 session 里面都保存了 token 对应的用户信息</li>
</ul>
<blockquote>
<p>问题：实际的业务层我们应该先用拦截器拦截到未登录的请求，然后重定向到登录页，登录后重定向回原来请求页</p>
<p>请求登录过的业务页时，在拦截器中，用 uuid 查</p>
</blockquote>
<h4 id="sso-解决"><a class="header-anchor" href="#sso-解决">¶</a>sso 解决</h4>
<p><a target="_blank" rel="noopener" href="http://client1.com">client1.com</a> 8081 和 <a target="_blank" rel="noopener" href="http://client2.com">client2.com</a> 8082 都跳转到 ssoserver 8080</p>
<ul>
<li>给登录服务器留下痕迹</li>
<li>登录服务器要将 token 信息重定向的时候，带到 url 地址上</li>
<li>其他系统要处理 url 地址上的 token，只要有，将 token 对应的用户保存到自己的 session</li>
<li>自己系统将用户保存在自己的 session 中</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;&#x2F;employee&quot;)
public String employees(@RequestParam(value &#x3D; &quot;username&quot;) String username ,
                        @RequestParam(value &#x3D; &quot;token&quot;,required &#x3D; false) String token,
                        HttpSession session)&#123;


    &#x2F;&#x2F; token不为空，去看redis里是否有token对应的信息
    if(!StringUtils.isEmpty(token))&#123;
        RestTemplate restTemplate &#x3D; new RestTemplate();
        ResponseEntity&lt;String&gt; entity &#x3D; restTemplate.getForEntity(&quot;http:&#x2F;&#x2F;ssoserver.com:8080&#x2F;userInfo?token&#x3D;&quot; + token, String.class);
        String body &#x3D; entity.getBody();
        System.out.println(body);
        &#x2F;&#x2F; 没登录
        return &quot;redirect:&quot; + this.ssoServer + &quot;?url&#x3D;http:&#x2F;&#x2F;clienta.com&#x2F;employee&amp;username&#x3D;&quot; + username;
    &#125;

    ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
    list.add(&quot;zjl&quot;);
    list.add(&quot;xjs&quot;);
    list.add(&quot;nay&quot;);
    list.add(&quot;mqs&quot;);
    session.setAttribute(&quot;user&quot;, username);
    session.setAttribute(&quot;emps&quot;, list);
    return &quot;list&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="server"><a class="header-anchor" href="#server">¶</a>server</h5>
<p>server 端的登录：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; CookieValue第一次非必须，第二个来的时候就可能携带了
@GetMapping(&quot;&#x2F;login.html&quot;)
public String loginPage(User user, Model model,
                        @CookieValue(value &#x3D; &quot;sso_token&quot;,required &#x3D; false) String sso_token)&#123;
    &#x2F;&#x2F;  
    if(!StringUtils.isEmpty(sso_token))&#123;
        &#x2F;&#x2F; 有人登录过
        return &quot;redirect:&quot; + user.getUrl() + &quot;?user + sso_token;
    &#125;
    model.addAttribute(&quot;url&quot;, user.getUrl());
    model.addAttribute(&quot;username&quot;, user.getUsername());
    return &quot;login&quot;;
&#125;

@PostMapping(&quot;&#x2F;doLogin&quot;) &#x2F;&#x2F; server端统一认证 &#x2F;&#x2F; user有属性name passwd url
public String doLogin(User user, HttpServletResponse response)&#123;
    &#x2F;&#x2F; 确认用户后，生成cookie、redis中存储
    if(!StringUtils.isEmpty(user.getUsername()) &amp;&amp; !StringUtils.isEmpty(user.getPassword())
       &amp;&amp; &quot;test&quot;.equals(user.getUsername()) &amp;&amp; &quot;test&quot;.equals(user.getPassword()))&#123;
        &#x2F;&#x2F; 登录成功跳转 跳回之前的页面
        String uuid &#x3D; UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        &#x2F;&#x2F; 存储cookie
        Cookie cookie &#x3D; new Cookie(&quot;sso_token&quot;, uuid);
        response.addCookie(cookie);
        &#x2F;&#x2F; redis中存储
        stringRedisTemplate.opsForValue().set(user.getUser(), uuid, 30, TimeUnit.MINUTES);
        &#x2F;&#x2F; user中存储的url  重定向时候带着token
        return &quot;redirect:&quot; + user.getUrl() + &quot;?user + uuid;
    &#125;
    &#x2F;&#x2F; 登录失败
    return &quot;login&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>momo</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/" title="认证服务_验证码、社交登录、分布式 session、单点登录">https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/Redis%E7%AC%94%E8%AE%B0(%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%BB%91%E9%A9%AC%E6%95%B4%E5%90%88)/" rel="prev" title="Redis笔记(尚硅谷黑马整合)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Redis笔记(尚硅谷黑马整合)</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/" rel="next" title="谷粒商城_分布式锁redisson与缓存"><span class="post-nav-text">谷粒商城_分布式锁redisson与缓存</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> momo</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>