<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="momo"><meta name="copyright" content="momo"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>谷粒商城_分布式锁redisson与缓存 | 我的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ppxiaodi.gitee.io","root":"/","title":"momo的小站","version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="谷粒商城_分布式锁redisson与缓存  本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net  ¶缓存  本地缓存：和微服务同一个进程。缺点：分布式时 分布式缓存：缓存中间件  ¶1. 本地缓存 category、brand、product ¶redis  redis 学习笔记：https:&#x2F;&#x2F;blog.csdn.net&#x2F;hancoder&#x2F;article&#x2F;details">
<meta property="og:type" content="article">
<meta property="og:title" content="谷粒商城_分布式锁redisson与缓存">
<meta property="og:url" content="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="谷粒商城_分布式锁redisson与缓存  本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net  ¶缓存  本地缓存：和微服务同一个进程。缺点：分布式时 分布式缓存：缓存中间件  ¶1. 本地缓存 category、brand、product ¶redis  redis 学习笔记：https:&#x2F;&#x2F;blog.csdn.net&#x2F;hancoder&#x2F;article&#x2F;details">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/4de06a06f282444c4399add9dd75ba12.png">
<meta property="article:published_time" content="2020-03-13T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-11T08:54:54.211Z">
<meta property="article:author" content="momo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="谷粒商城">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/4de06a06f282444c4399add9dd75ba12.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="momo"><img width="96" loading="lazy" src="/yun.png" alt="momo"></a><div class="site-author-name"><a href="/about/">momo</a></div><a class="site-name" href="/about/site.html">我的笔记</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">198</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">58</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ 群 1050458482" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">谷粒商城_分布式锁redisson与缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 本地缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redis-%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-bug"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">redis 堆外内存溢出 bug</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">3) 缓存失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E5%8A%A0%E9%94%81"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">4) 缓存击穿: 加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">如何复制微服务：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 分布式缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">分布式锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-number">1.1.3.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">(1) 环境搭建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Reentrant-Lock%EF%BC%89"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">(2) 可重入锁（Reentrant Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88ReadWriteLock%EF%BC%89"><span class="toc-number">1.1.3.0.3.</span> <span class="toc-text">(3) 读写锁（ReadWriteLock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="toc-number">1.1.3.0.4.</span> <span class="toc-text">(4) 信号量（Semaphore）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%97%AD%E9%94%81%EF%BC%88CountDownLatch%EF%BC%89"><span class="toc-number">1.1.3.0.5.</span> <span class="toc-text">(5) 闭锁（CountDownLatch）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.1.4.</span> <span class="toc-text">缓存和数据库一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringCache"><span class="toc-number">1.1.5.</span> <span class="toc-text">SpringCache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1) 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2) 缓存自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3) 缓存使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-SpringCache-%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">4) SpringCache 原理与不足</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="momo"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">谷粒商城_分布式锁redisson与缓存</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">2020-03-14</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-07-11 16:54:54" itemprop="dateModified" datetime="2021-07-11T16:54:54+08:00">2021-07-11</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">谷粒商城</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">java</span></a><a class="tag-item" href="/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">谷粒商城</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1>谷粒商城_分布式锁redisson与缓存</h1>
<blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/114004280">blog.csdn.net</a></p>
</blockquote>
<h2 id="缓存"><a class="header-anchor" href="#缓存">¶</a>缓存</h2>
<ul>
<li>本地缓存：和微服务同一个进程。缺点：分布式时</li>
<li>分布式缓存：缓存中间件</li>
</ul>
<h3 id="1-本地缓存"><a class="header-anchor" href="#1-本地缓存">¶</a>1. 本地缓存</h3>
<p>category、brand、product</p>
<h4 id="redis"><a class="header-anchor" href="#redis">¶</a>redis</h4>
<blockquote>
<p>redis 学习笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hancoder/article/details/105694186">https://blog.csdn.net/hancoder/article/details/105694186</a></p>
</blockquote>
<p>安装 docker-redis</p>
<p>product 导入依赖</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置 redis 主机地址</p>
<pre class="line-numbers language-none"><code class="language-none">spring:
  redis:
    host: 192.168.56.10
    port: 6379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>自动注入了 RedisTemplate</p>
<p>优化菜单获取业务 getCatalogJson</p>
<pre class="line-numbers language-none"><code class="language-none">ValueOperations&lt;String, String&gt; ops &#x3D; stringRedisTemplate.opsForValue();
String catalogJson &#x3D; ops.get(&quot;catalogJson&quot;);
if (catalogJson &#x3D;&#x3D; null) &#123;
    Map&lt;String, List&lt;Catalog2Vo&gt;&gt; categoriesDb &#x3D; getCategoriesDb();
    String toJSONString &#x3D; JSON.toJSONString(categoriesDb);
    ops.set(&quot;catalogJson&quot;,toJSONString);
    return categoriesDb;
&#125;
Map&lt;String, List&lt;Catalog2Vo&gt;&gt; listMap &#x3D; JSON.parseObject(catalogJson, new TypeReference&lt;Map&lt;String, List&lt;Catalog2Vo&gt;&gt;&gt;() &#123;&#125;);
return listMap;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="redis-堆外内存溢出-bug"><a class="header-anchor" href="#redis-堆外内存溢出-bug">¶</a>redis 堆外内存溢出 bug</h5>
<p>当进行压力测试时后期后出现<strong>堆外内存溢出 OutOfDirectMemoryError</strong></p>
<p>产生原因：</p>
<p>1)、springboot2.0 以后默认使用<code>lettuce</code>作为操作 redis 的客户端，它使用 netty 进行网络通信</p>
<p>2)、lettuce 的 bug 导致 netty 堆外内存溢出。netty 如果没有指定堆外内存，默认使用 Xms 的值，可以使用 - Dio.netty.maxDirectMemory 进行设置</p>
<p>解决方案：由于是 lettuce 的 bug 造成，不能直接使用 - Dio.netty.maxDirectMemory 去调大虚拟机堆外内存，治标不治本。</p>
<ul>
<li>1)、升级 lettuce 客户端。但是没有解决的</li>
<li>2）、切换使用 jedis</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;
        &lt;&#x2F;exclusion&gt;
    &lt;&#x2F;exclusions&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>lettuce 和 jedis 是操作 redis 的底层客户端，RedisTemplate 是再次封装</p>
<h4 id="3-缓存失效"><a class="header-anchor" href="#3-缓存失效">¶</a>3) 缓存失效</h4>
<p><strong>缓存穿透</strong></p>
<p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为 id 为 “-1” 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p>解决：缓存空对象、布隆过滤器、mvc 拦截器</p>
<p><strong>缓存雪崩</strong></p>
<p>缓存雪崩是指在我们设置缓存时 key 采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。</p>
<p>解决方案：</p>
<ul>
<li>规避雪崩：缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是<strong>分布式部署</strong>，将热点数据均匀分布在不同缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
<li>出现雪崩：降级 熔断</li>
<li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地 ehcache 缓存 + hystrix 限流 &amp; 降级，避免 MySQL 崩掉</li>
<li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<p><strong>缓存击穿</strong></p>
<p>缓存雪崩和缓存击穿不同的是：</p>
<ul>
<li><strong>缓存击穿 指 并发查同一条数据</strong>。缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</li>
<li><strong>缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</strong></li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁：业界比较常用的做法，是使用 mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db 去数据库加载，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的<code>SETNX</code>或者 Memcache 的<code>ADD</code>）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。</li>
</ul>
<h4 id="4-缓存击穿-加锁"><a class="header-anchor" href="#4-缓存击穿-加锁">¶</a>4) 缓存击穿: 加锁</h4>
<p>不好的方法是 synchronized(this)，肯定不能这么写 ，不具体写了</p>
<p>锁时序问题：之前的逻辑是查缓存没有，然后取竞争锁查数据库，这样就造成多次查数据库。</p>
<p>解决方法：竞争到锁后，再次确认缓存中没有，再去查数据库。</p>
<img src="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/4de06a06f282444c4399add9dd75ba12.png" class="" loading="lazy">
<h5 id="如何复制微服务："><a class="header-anchor" href="#如何复制微服务：">¶</a>如何复制微服务：</h5>
<blockquote>
<p>右键点击服务，copy configuration</p>
<p>在<code>program arguments: --server.port=10003</code></p>
</blockquote>
<h3 id="2-分布式缓存"><a class="header-anchor" href="#2-分布式缓存">¶</a>2. 分布式缓存</h3>
<p>本地缓存问题：每个微服务都要有缓存服务、数据更新时只更新自己的缓存，造成<strong>缓存数据不一致</strong></p>
<p>解决方案：分布式缓存，微服务共用 缓存中间件</p>
<h4 id="分布式锁"><a class="header-anchor" href="#分布式锁">¶</a>分布式锁</h4>
<p>分布式项目时，但本地锁只能锁住当前服务，需要分布式锁</p>
<p>redis 分布式锁的原理：setnx，同一时刻只能设置成功一个</p>
<blockquote>
<p>前提，锁的 key 是一定的，value 可以变</p>
</blockquote>
<ul>
<li>
<p>没获取到锁阻塞或者 sleep 一会</p>
</li>
<li>
<p>设置好了锁，玩意服务出现宕机，没有执行删除锁逻辑，这就造成了死锁</p>
<ul>
<li>解决：设置过期时间</li>
</ul>
</li>
<li>
<p>业务还没执行完锁就过期了，别人拿到锁，自己执行完去删了别人的锁</p>
<ul>
<li>解决：锁续期（redisson 有看门狗），。删锁的时候明确是自己的锁。如 uuid</li>
</ul>
</li>
<li>
<p>判断 uuid 对了，但是将要删除的时候锁过期了，别人设置了新值，那删除了别人的锁</p>
<ul>
<li>
<p>解决：删除锁必须保证原子性（保证判断和删锁是原子的）。使用 redis+Lua 脚本完成，脚本是原子的</p>
</li>
<li>
<pre><code>if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] 
then
	return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end;
<pre class="line-numbers language-none"><code class="language-none">    
*   &#96;&#96;&#96;
    stringRedisTemplate.execute(
        new DefaultRedisScript&lt;Long返回值类型&gt;(script脚本支付非常, Long.class返回值类型), 
        Arrays.asList(&quot;lock&quot;)键key的集合, 
        lockValue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

http://redis.cn/commands/set.html


</code></pre>
</li>
</ul>
</li>
</ul>
<p>最终代码：</p>
<pre class="line-numbers language-none"><code class="language-none">public Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithRedisLock() &#123;
    String uuid &#x3D; UUID.randomUUID().toString();
    ValueOperations&lt;String, String&gt; ops &#x3D; stringRedisTemplate.opsForValue();
    Boolean lock &#x3D; ops.setIfAbsent(&quot;lock&quot;, uuid,500, TimeUnit.SECONDS);
    if (lock) &#123;
        Map&lt;String, List&lt;Catalog2Vo&gt;&gt; categoriesDb &#x3D; getCategoryMap();
        String lockValue &#x3D; ops.get(&quot;lock&quot;);
        String script &#x3D; &quot;if redis.call(\&quot;get\&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then\n&quot; +
            &quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot; +
            &quot;else\n&quot; +
            &quot;    return 0\n&quot; +
            &quot;end&quot;;
        stringRedisTemplate.execute(
            new DefaultRedisScript&lt;Long&gt;(script, Long.class),
            Arrays.asList(&quot;lock&quot;),
            lockValue);
        return categoriesDb;
    &#125;else &#123;
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        &#x2F;&#x2F; 睡眠0.1s后，重新调用&#x2F;&#x2F;自旋
        return getCatalogJsonDbWithRedisLock();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的 lua 脚本写法每次用分布式锁时比较麻烦，我们可以采用 redisson 现有框架</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>
<h3 id="Redisson"><a class="header-anchor" href="#Redisson">¶</a>Redisson</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p>
<p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。其中包括 (<code>BitSet</code>, <code>Set</code>, <code>Multimap</code>, <code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>BlockingQueue</code>, <code>Deque</code>, <code>BlockingDeque</code>, <code>Semaphore</code>, <code>Lock</code>, <code>AtomicLong</code>, <code>CountDownLatch</code>, <code>Publish / Subscribe</code>, <code>Bloom filter</code>, <code>Remote service</code>, <code>Spring cache</code>, <code>Executor service</code>, <code>Live Object service</code>, <code>Scheduler service</code>) Redisson 提供了使用 Redis 的最简单和最便捷的方法。Redisson 的宗旨是促进使用者对 Redis 的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p>本文我们仅关注分布式锁的实现，更多请参考<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">官方文档</a></p>
<h5 id="1-环境搭建"><a class="header-anchor" href="#1-环境搭建">¶</a>(1) 环境搭建</h5>
<p><strong>导入依赖</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;redisson&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.13.4&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;
这个用作连续，后面可以使用redisson-spring-boot-starter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开启配置 <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">https://github.com/redisson/redisson/wiki/2.-配置方法</a></p>
<pre class="line-numbers language-none"><code class="language-none">@Configuration
public class MyRedisConfig &#123;

    @Value(&quot;$&#123;ipAddr&#125;&quot;)
    private String ipAddr;

    &#x2F;&#x2F; redission通过redissonClient对象使用 &#x2F;&#x2F; 如果是多个redis集群，可以配置
    @Bean(destroyMethod &#x3D; &quot;shutdown&quot;)
    public RedissonClient redisson() &#123;
        Config config &#x3D; new Config();
        &#x2F;&#x2F; 创建单例模式的配置
        config.useSingleServer().setAddress(&quot;redis:&#x2F;&#x2F;&quot; + ipAddr + &quot;:6379&quot;);
        return Redisson.create(config);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="2-可重入锁（Reentrant-Lock）"><a class="header-anchor" href="#2-可重入锁（Reentrant-Lock）">¶</a>(2) 可重入锁（Reentrant Lock）</h5>
<p>分布式锁：<a target="_blank" rel="noopener" href="http://github.com/redisson/redisson/wiki/8.-">github.com/redisson/redisson/wiki/8.-</a> 分布式锁和同步器</p>
<p>A 调用 B。AB 都需要同一锁，此时可重入锁就可以重入，A 就可以调用 B。不可重入锁时，A 调用 B 将死锁</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 参数为锁名字
RLock lock &#x3D; redissonClient.getLock(&quot;CatalogJson-Lock&quot;);&#x2F;&#x2F;该锁实现了JUB.locks.lock接口
lock.lock();&#x2F;&#x2F;阻塞等待
&#x2F;&#x2F; 解锁放到finally &#x2F;&#x2F; 如果这里宕机：有看门狗，不用担心
lock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基于 Redis 的 Redisson 分布式可重入锁 <a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLock.html"><code>RLock</code></a> Java 对象实现了<code>java.util.concurrent.locks.Lock</code>接口。同时还提供了<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html">异步（Async）</a>、<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html">反射式（Reactive）</a>和 <a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html">RxJava2 标准</a>的接口。</p>
<p>大家都知道，如果负责储存这个分布式锁的 Redisson 节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson 内部提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是 30 秒钟（每到 20s 就会自动续借成 30s，是 1/3 的关系），也可以通过修改 <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95#lockwatchdogtimeout%E7%9B%91%E6%8E%A7%E9%94%81%E7%9A%84%E7%9C%8B%E9%97%A8%E7%8B%97%E8%B6%85%E6%97%B6%E5%8D%95%E4%BD%8D%E6%AF%AB%E7%A7%92">Config.lockWatchdogTimeout</a> 来另行指定。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 加锁以后10秒钟自动解锁，看门狗不续命
&#x2F;&#x2F; 无需调用unlock方法手动解锁
lock.lock(10, TimeUnit.SECONDS);

&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);
if (res) &#123;
   try &#123;
     ...
   &#125; finally &#123;
       lock.unlock();
   &#125;
&#125;
如果传递了锁的超时时间，就执行脚本，进行占锁;
如果没传递锁时间，使用看门狗的时间，占锁。如果返回占锁成功future，调用future.onComplete();
没异常的话调用scheduleExpirationRenewal(threadId);
重新设置过期时间，定时任务;
看门狗的原理是定时任务：重新给锁设置过期时间，新的过期时间就是看门狗的默认时间;
锁时间&#x2F;3是定时任务周期;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Redisson 同时还为分布式锁提供了异步执行的相关方法：</p>
<pre class="line-numbers language-none"><code class="language-none">RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);
lock.lockAsync();
lock.lockAsync(10, TimeUnit.SECONDS);
Future&lt;Boolean&gt; res &#x3D; lock.tryLockAsync(100, 10, TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>RLock</code>对象完全符合 Java 的 Lock 规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出<code>IllegalMonitorStateException</code>错误。但是如果遇到需要其他进程也能解锁的情况，请使用<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#86-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore">分布式信号量<code>Semaphore</code></a> 对象.</p>
<pre class="line-numbers language-none"><code class="language-none">public Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithRedisson() &#123;
    Map&lt;String, List&lt;Catalog2Vo&gt;&gt; categoryMap&#x3D;null;
    RLock lock &#x3D; redissonClient.getLock(&quot;CatalogJson-Lock&quot;);
    lock.lock();
    try &#123;
        Thread.sleep(30000);
        categoryMap &#x3D; getCategoryMap();
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;finally &#123;
        lock.unlock();
        return categoryMap;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最佳实战：自己指定锁时间，时间长点即可</p>
<h5 id="3-读写锁（ReadWriteLock）"><a class="header-anchor" href="#3-读写锁（ReadWriteLock）">¶</a>(3) 读写锁（ReadWriteLock）</h5>
<p>基于 Redis 的 Redisson 分布式可重入读写锁 <a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.4.3/org/redisson/api/RReadWriteLock.html"><code>RReadWriteLock</code></a> Java 对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了 <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock">RLock</a> 接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<pre class="line-numbers language-none"><code class="language-none">RReadWriteLock rwlock &#x3D; redisson.getReadWriteLock(&quot;anyRWLock&quot;);
&#x2F;&#x2F; 最常见的使用方法
rwlock.readLock().lock();
&#x2F;&#x2F; 或
rwlock.writeLock().lock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 10秒钟以后自动解锁
&#x2F;&#x2F; 无需调用unlock方法手动解锁
rwlock.readLock().lock(10, TimeUnit.SECONDS);
&#x2F;&#x2F; 或
rwlock.writeLock().lock(10, TimeUnit.SECONDS);

&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res &#x3D; rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);
&#x2F;&#x2F; 或
boolean res &#x3D; rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);
...
lock.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上锁时在 redis 的状态</p>
<pre class="line-numbers language-none"><code class="language-none">HashWrite-Lock
key:mode  value:read
key:sasdsdffsdfsdf... value:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5 id="4-信号量（Semaphore）"><a class="header-anchor" href="#4-信号量（Semaphore）">¶</a>(4) 信号量（Semaphore）</h5>
<p>信号量为存储在 redis 中的一个数字，当这个数字大于 0 时，即可以调用<code>acquire()</code>方法增加数量，也可以调用<code>release()</code>方法减少数量，但是当调用<code>release()</code>之后小于 0 的话方法就会阻塞，直到数字大于 0</p>
<p>基于 Redis 的 Redisson 的分布式信号量（<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html">Semaphore</a>）Java 对象<code>RSemaphore</code>采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreAsync.html">异步（Async）</a>、<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreReactive.html">反射式（Reactive）</a>和 <a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreRx.html">RxJava2 标准</a>的接口。</p>
<pre class="line-numbers language-none"><code class="language-none">RSemaphore semaphore &#x3D; redisson.getSemaphore(&quot;semaphore&quot;);
semaphore.acquire();
&#x2F;&#x2F;或
semaphore.acquireAsync();
semaphore.acquire(23);
semaphore.tryAcquire();
&#x2F;&#x2F;或
semaphore.tryAcquireAsync();
semaphore.tryAcquire(23, TimeUnit.SECONDS);
&#x2F;&#x2F;或
semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);
semaphore.release(10);
semaphore.release();
&#x2F;&#x2F;或
semaphore.releaseAsync();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;&#x2F;park&quot;)
@ResponseBody
public String park() &#123;
    RSemaphore park &#x3D; redissonClient.getSemaphore(&quot;park&quot;);
    try &#123;
        park.acquire(2);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    return &quot;停进2&quot;;
&#125;

@GetMapping(&quot;&#x2F;go&quot;)
@ResponseBody
public String go() &#123;
    RSemaphore park &#x3D; redissonClient.getSemaphore(&quot;park&quot;);
    park.release(2);
    return &quot;开走2&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="5-闭锁（CountDownLatch）"><a class="header-anchor" href="#5-闭锁（CountDownLatch）">¶</a>(5) 闭锁（CountDownLatch）</h5>
<p>基于 Redisson 的 Redisson 分布式闭锁（<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RCountDownLatch.html">CountDownLatch</a>）Java 对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p>
<p>以下代码只有<code>offLatch()</code>被调用 5 次后 <code>setLatch()</code>才能继续执行</p>
<pre class="line-numbers language-none"><code class="language-none">RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);
latch.trySetCount(1);
latch.await();

&#x2F;&#x2F; 在其他线程或其他JVM里
RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);
latch.countDown();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="缓存和数据库一致性"><a class="header-anchor" href="#缓存和数据库一致性">¶</a>缓存和数据库一致性</h3>
<ul>
<li>双写模式：写数据库后，写缓存
<ul>
<li>问题：并发时，2 写进入，写完 DB 后都写缓存。有暂时的脏数据</li>
</ul>
</li>
<li>失效模式：写完数据库后，删缓存
<ul>
<li>问题：还没存入数据库呢，线程 2 又读到旧的 DB 了</li>
<li>解决：缓存设置过期时间，定期更新</li>
<li>解决：写数据写时，加分布式的读写锁。</li>
</ul>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可</li>
<li>如果是菜单，商品介绍等基础数据，也可以去使用 canal 订阅 binlog 的方式</li>
<li>缓存数据 + 过期时间也足够解决大部分业务对于缓存的要求。</li>
<li>通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）；</li>
</ul>
<p>总结：</p>
<ul>
<li>我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。</li>
<li>我们不应该过度设计，增加系统的复杂性</li>
<li>遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。</li>
</ul>
<p>[外链图片转存失败, 源站可能有防盗链机制, 建议将图片保存下来直接上传 (img-s5K1NZgw-1614153406119)(<a target="_blank" rel="noopener" href="https://fermhan.oss-cn-qingdao.aliyuncs.com/img/20210223231209.png">https://fermhan.oss-cn-qingdao.aliyuncs.com/img/20210223231209.png</a>)]</p>
<h3 id="SpringCache"><a class="header-anchor" href="#SpringCache">¶</a>SpringCache</h3>
<blockquote>
<p>随便找篇 cache 文章阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/er_ving/article/details/105421572">https://blog.csdn.net/er_ving/article/details/105421572</a></p>
</blockquote>
<p>每次都那样写缓存太麻烦了，spring 从 3.1 开始定义了 Cache、CacheManager 接口来统一不同的缓存技术。并支持使用 JCache(JSR-107) 注解简化我们的开发</p>
<p>Cache 接口的实现包括 RedisCache、EhCacheCache、ConcurrentMapCache 等</p>
<p>每次调用需要缓存功能的方法时，spring 会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p>
<p>使用 Spring 缓存抽象时我们需要关注以下两点：</p>
<p>1、确定方法需要缓存以及他们的缓存策略<br>
2、从缓存中读取之前缓存存储的数据</p>
<h4 id="1-配置"><a class="header-anchor" href="#1-配置">¶</a>1) 配置</h4>
<p>依赖</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.b oot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>指定缓存类型并在主配置类上加上注解<code>@EnableCaching</code></p>
<pre class="line-numbers language-none"><code class="language-none">spring:
  cache:
  	#指定缓存类型为redis
    type: redis
    redis:
      # 指定redis中的过期时间为1h
      time-to-live: 3600000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认使用 jdk 进行序列化（可读性差），默认 ttl 为 - 1 永不过期，自定义序列化方式需要编写配置类</p>
<pre class="line-numbers language-none"><code class="language-none">@Configuration
public class MyCacheConfig &#123;
    @Bean
    public org.springframework.data.redis.cache.RedisCacheConfiguration redisCacheConfiguration(
        CacheProperties cacheProperties) &#123;
        CacheProperties.Redis redisProperties &#x3D; cacheProperties.getRedis();
        org.springframework.data.redis.cache.RedisCacheConfiguration config &#x3D; org.springframework.data.redis.cache.RedisCacheConfiguration
            .defaultCacheConfig();
        &#x2F;&#x2F;指定缓存序列化方式为json
        config &#x3D; config.serializeValuesWith(
            RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        &#x2F;&#x2F;设置配置文件中的各项配置，如过期时间
        if (redisProperties.getTimeToLive() !&#x3D; null) &#123;
            config &#x3D; config.entryTtl(redisProperties.getTimeToLive());
        &#125;
        if (redisProperties.getKeyPrefix() !&#x3D; null) &#123;
            config &#x3D; config.prefixKeysWith(redisProperties.getKeyPrefix());
        &#125;
        if (!redisProperties.isCacheNullValues()) &#123;
            config &#x3D; config.disableCachingNullValues();
        &#125;
        if (!redisProperties.isUseKeyPrefix()) &#123;
            config &#x3D; config.disableKeyPrefix();
        &#125;
        return config;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-缓存自动配置"><a class="header-anchor" href="#2-缓存自动配置">¶</a>2) 缓存自动配置</h4>
<pre class="line-numbers language-none"><code class="language-none">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnClass(CacheManager.class)
@ConditionalOnBean(CacheAspectSupport.class)
@ConditionalOnMissingBean(value &#x3D; CacheManager.class, name &#x3D; &quot;cacheResolver&quot;)
@EnableConfigurationProperties(CacheProperties.class)
@AutoConfigureAfter(&#123; CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class,
                     HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class &#125;)
@Import(&#123; CacheConfigurationImportSelector.class, &#x2F;&#x2F; 看导入什么CacheConfiguration
         CacheManagerEntityManagerFactoryDependsOnPostProcessor.class &#125;)
public class CacheAutoConfiguration &#123;

    @Bean
    @ConditionalOnMissingBean
    public CacheManagerCustomizers cacheManagerCustomizers(ObjectProvider&lt;CacheManagerCustomizer&lt;?&gt;&gt; customizers) &#123;
        return new CacheManagerCustomizers(customizers.orderedStream().collect(Collectors.toList()));
    &#125;

    @Bean
    public CacheManagerValidator cacheAutoConfigurationValidator(CacheProperties cacheProperties,
                                                                 ObjectProvider&lt;CacheManager&gt; cacheManager) &#123;
        return new CacheManagerValidator(cacheProperties, cacheManager);
    &#125;

    @ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)
    @ConditionalOnBean(AbstractEntityManagerFactoryBean.class)
    static class CacheManagerEntityManagerFactoryDependsOnPostProcessor
        extends EntityManagerFactoryDependsOnPostProcessor &#123;

        CacheManagerEntityManagerFactoryDependsOnPostProcessor() &#123;
            super(&quot;cacheManager&quot;);
        &#125;

    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnClass(RedisConnectionFactory.class)
@AutoConfigureAfter(RedisAutoConfiguration.class)
@ConditionalOnBean(RedisConnectionFactory.class)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class RedisCacheConfiguration &#123;

    @Bean &#x2F;&#x2F; 放入缓存管理器
    RedisCacheManager cacheManager(CacheProperties cacheProperties, 
                                   CacheManagerCustomizers cacheManagerCustomizers,
                                   ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,
                                   ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,
                                   RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) &#123;
        RedisCacheManagerBuilder builder &#x3D; RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(
            determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));
        List&lt;String&gt; cacheNames &#x3D; cacheProperties.getCacheNames();
        if (!cacheNames.isEmpty()) &#123;
            builder.initialCacheNames(new LinkedHashSet&lt;&gt;(cacheNames));
        &#125;
        redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));
        return cacheManagerCustomizers.customize(builder.build());
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>[外链图片转存失败, 源站可能有防盗链机制, 建议将图片保存下来直接上传 (img-FsGXLKgG-1614153406127)(D:images/Snipaste_2020-09-10_19-40-20.png)]</p>
<h4 id="3-缓存使用"><a class="header-anchor" href="#3-缓存使用">¶</a>3) 缓存使用</h4>
<p>第一个方法存放缓存，第二个方法清空缓存</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调用该方法时会将结果缓存，缓存名为category，key为方法名
&#x2F;&#x2F; sync表示该方法的缓存被读取时会加锁 &#x2F;&#x2F; value等同于cacheNames &#x2F;&#x2F; key如果是字符串&quot;&#39;&#39;&quot;
@Cacheable(value &#x3D; &#123;&quot;category&quot;&#125;,key &#x3D; &quot;#root.methodName&quot;,sync &#x3D; true)
public Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithSpringCache() &#123;
    return getCategoriesDb();
&#125;

&#x2F;&#x2F;调用该方法会删除缓存category下的所有cache，如果要删除某个具体，用key&#x3D;&quot;&#39;&#39;&quot;
@Override
@CacheEvict(value &#x3D; &#123;&quot;category&quot;&#125;,allEntries &#x3D; true)
public void updateCascade(CategoryEntity category) &#123;
    this.updateById(category);
    if (!StringUtils.isEmpty(category.getName())) &#123;
        categoryBrandRelationService.updateCategory(category);
    &#125;
&#125;

如果要清空多个缓存，用@Caching(evict&#x3D;&#123;@CacheEvict(value&#x3D;&quot;&quot;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-SpringCache-原理与不足"><a class="header-anchor" href="#4-SpringCache-原理与不足">¶</a>4) SpringCache 原理与不足</h4>
<p>1）、读模式</p>
<ul>
<li>缓存穿透：查询一个 null 数据。解决方案：缓存空数据，可通过<code>spring.cache.redis.cache-null-values=true</code></li>
<li>缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? 默认是无加锁的;
<ul>
<li>使用<code>sync = true</code>来解决击穿问题</li>
</ul>
</li>
<li>缓存雪崩：大量的 key 同时过期。解决：加随机时间。</li>
</ul>
<p>2)、写模式：（缓存与数据库一致）</p>
<ul>
<li>读写加锁。</li>
<li>引入 Canal，感知到 MySQL 的更新去更新 Redis</li>
<li>读多写多，直接去数据库查询就行</li>
</ul>
<p>3）、总结：</p>
<p>常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用 Spring-Cache）：</p>
<p>写模式 (只要缓存的数据有过期时间就足够了)</p>
<p>特殊数据：特殊设计</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>momo</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/" title="谷粒商城_分布式锁redisson与缓存">https://ppxiaodi.gitee.io/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E4%B8%8E%E7%BC%93%E5%AD%98/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A0%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/" rel="prev" title="线程池加异步编排"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">线程池加异步编排</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/03/14/CollectionNote/java/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E7%AC%94%E8%AE%B0_%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A73/" rel="next" title="谷粒商城笔记_分布式高级3"><span class="post-nav-text">谷粒商城笔记_分布式高级3</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> momo</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>